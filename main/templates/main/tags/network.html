{% extends "main/base.html" %}
{% load static %}

{% block title %}Tags Network - IdeaGraph v1.0{% endblock %}

{% block extra_css %}
<style>
    #network-container {
        width: 100%;
        height: 85vh;
        min-height: 700px;
        border: 2px solid var(--autumn-primary);
        border-radius: 15px;
        background: rgba(31, 41, 55, 0.8);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }
    
    .legend {
        background: rgba(31, 41, 55, 0.95);
        border: 1px solid var(--autumn-primary);
        border-radius: 10px;
        padding: 1rem;
        margin-top: 1rem;
    }
    
    .legend-item {
        display: inline-flex;
        align-items: center;
        margin-right: 1.5rem;
        margin-bottom: 0.5rem;
    }
    
    .legend-icon {
        display: inline-block;
        margin-right: 0.5rem;
    }
    
    .legend-dot {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 2px solid #fff;
    }
    
    .legend-box {
        width: 20px;
        height: 20px;
        border: 2px solid #fff;
    }
    
    .legend-diamond {
        width: 14px;
        height: 14px;
        border: 2px solid #fff;
        transform: rotate(45deg);
    }
    
    .controls {
        background: rgba(31, 41, 55, 0.95);
        border: 1px solid var(--autumn-primary);
        border-radius: 10px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .loading-spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
    }
    
    .hidden {
        display: none;
    }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4">
    <div class="row">
        <div class="col-12">
            <div class="card fade-in-up">
                <div class="card-header">
                    <h1 class="h3 mb-0">
                        <i class="bi bi-diagram-3-fill"></i> Tags Network Graph
                    </h1>
                </div>
                <div class="card-body">
                    <div class="controls">
                        <div class="row align-items-center mb-3">
                            <div class="col-md-8">
                                <p class="mb-2">
                                    <i class="bi bi-info-circle"></i> 
                                    Visualisierung der Verbindungen zwischen Tags, Items und Tasks. 
                                    Klicken Sie auf einen Knoten, um Details zu öffnen. Verwenden Sie die Maus zum Zoomen und Verschieben.
                                </p>
                            </div>
                            <div class="col-md-4 text-end">
                                <button id="rearrangeBtn" class="btn btn-outline-success me-2">
                                    <i class="bi bi-shuffle"></i> Neu anordnen
                                </button>
                                <button id="resetViewBtn" class="btn btn-outline-primary">
                                    <i class="bi bi-arrow-clockwise"></i> Ansicht zurücksetzen
                                </button>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-12">
                                <div class="btn-group" role="group" aria-label="Filter controls">
                                    <button id="toggleItemsBtn" class="btn btn-sm btn-success" title="Items ein-/ausblenden">
                                        <i class="bi bi-eye"></i> Items
                                    </button>
                                    <button id="toggleTasksBtn" class="btn btn-sm btn-success" title="Tasks ein-/ausblenden">
                                        <i class="bi bi-eye"></i> Tasks
                                    </button>
                                </div>
                                <small class="text-muted ms-3">
                                    <i class="bi bi-funnel"></i> Filter: Blenden Sie Items oder Tasks aus, um sich auf relevante Verbindungen zu fokussieren
                                </small>
                            </div>
                        </div>
                    </div>
                    
                    <div style="position: relative;">
                        <div id="loading" class="loading-spinner">
                            <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                        <div id="network-container"></div>
                    </div>
                    
                    <div class="legend">
                        <h5 class="mb-3"><i class="bi bi-card-list"></i> Legende</h5>
                        <div class="row">
                            <div class="col-md-4">
                                <h6>Knotentypen:</h6>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <circle cx="12" cy="12" r="10" fill="#f59e0b" stroke="#fff" stroke-width="2"/>
                                        </svg>
                                    </span>
                                    <span>Tag</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <rect x="2" y="6" width="20" height="12" fill="#3b82f6" stroke="#fff" stroke-width="2" rx="2"/>
                                        </svg>
                                    </span>
                                    <span>Item</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <polygon points="12,2 22,12 12,22 2,12" fill="#8b5cf6" stroke="#fff" stroke-width="2"/>
                                        </svg>
                                    </span>
                                    <span>Task</span>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <h6>Item Status:</h6>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <rect x="2" y="6" width="20" height="12" fill="#6366f1" stroke="#fff" stroke-width="2" rx="2"/>
                                        </svg>
                                    </span>
                                    <span>Neu</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <rect x="2" y="6" width="20" height="12" fill="#f59e0b" stroke="#fff" stroke-width="2" rx="2"/>
                                        </svg>
                                    </span>
                                    <span>Working</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <rect x="2" y="6" width="20" height="12" fill="#22c55e" stroke="#fff" stroke-width="2" rx="2"/>
                                        </svg>
                                    </span>
                                    <span>Ready</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <rect x="2" y="6" width="20" height="12" fill="#10b981" stroke="#fff" stroke-width="2" rx="2"/>
                                        </svg>
                                    </span>
                                    <span>Erledigt</span>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <h6>Task Status:</h6>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <polygon points="12,2 22,12 12,22 2,12" fill="#6366f1" stroke="#fff" stroke-width="2"/>
                                        </svg>
                                    </span>
                                    <span>Neu</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <polygon points="12,2 22,12 12,22 2,12" fill="#f59e0b" stroke="#fff" stroke-width="2"/>
                                        </svg>
                                    </span>
                                    <span>Working</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <polygon points="12,2 22,12 12,22 2,12" fill="#22c55e" stroke="#fff" stroke-width="2"/>
                                        </svg>
                                    </span>
                                    <span>Ready</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-icon">
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <polygon points="12,2 22,12 12,22 2,12" fill="#10b981" stroke="#fff" stroke-width="2"/>
                                        </svg>
                                    </span>
                                    <span>Erledigt</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Simple force-directed graph implementation without external dependencies
document.addEventListener('DOMContentLoaded', function() {
    const container = document.getElementById('network-container');
    const loadingSpinner = document.getElementById('loading');
    const resetViewBtn = document.getElementById('resetViewBtn');
    
    // Fetch network data from API
    fetch('{% url "main:api_tags_network_data" %}')
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                throw new Error(data.error || 'Failed to load network data');
            }
            
            // Hide loading spinner
            loadingSpinner.classList.add('hidden');
            
            // Create SVG canvas
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.style.width = '100%';
            svg.style.height = '100%';
            container.appendChild(svg);
            
            // Create groups for edges and nodes
            const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(edgeGroup);
            svg.appendChild(nodeGroup);
            
            // Initialize node positions randomly
            const nodes = data.nodes.map(node => ({
                ...node,
                x: Math.random() * width,
                y: Math.random() * height,
                vx: 0,
                vy: 0
            }));
            
            const edges = data.edges;
            
            // Create node index map
            const nodeMap = {};
            nodes.forEach(node => {
                nodeMap[node.id] = node;
            });
            
            // Draw edges
            edges.forEach(edge => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('stroke', edge.color?.color || '#9ca3af');
                line.setAttribute('stroke-width', edge.width || 1);
                line.setAttribute('stroke-opacity', edge.color?.opacity || 0.5);
                if (edge.dashes) {
                    line.setAttribute('stroke-dasharray', '5,5');
                }
                edge.element = line;
                edgeGroup.appendChild(line);
            });
            
            // Draw nodes
            nodes.forEach(node => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.style.cursor = node.url ? 'pointer' : 'default';
                
                let shape;
                if (node.shape === 'dot') {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    shape.setAttribute('r', node.size || 20);
                    shape.setAttribute('fill', node.color);
                } else if (node.shape === 'diamond') {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const size = node.size || 15;
                    shape.setAttribute('points', `0,${-size} ${size},0 0,${size} ${-size},0`);
                    shape.setAttribute('fill', node.color);
                } else {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    const size = node.size || 20;
                    shape.setAttribute('width', size * 2);
                    shape.setAttribute('height', size * 1.5);
                    shape.setAttribute('x', -size);
                    shape.setAttribute('y', -size * 0.75);
                    shape.setAttribute('rx', 3);
                    shape.setAttribute('fill', node.color);
                }
                
                shape.setAttribute('stroke', '#ffffff');
                shape.setAttribute('stroke-width', 2);
                g.appendChild(shape);
                
                // Add label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('fill', node.font?.color || '#ffffff');
                text.setAttribute('font-size', node.font?.size || 12);
                text.setAttribute('y', (node.size || 20) + 15);
                text.textContent = node.label;
                g.appendChild(text);
                
                // Add title for tooltip
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                title.textContent = node.title || node.label;
                g.appendChild(title);
                
                // Click handler
                if (node.url) {
                    g.addEventListener('click', () => {
                        window.location.href = node.url;
                    });
                }
                
                node.element = g;
                nodeGroup.appendChild(g);
            });
            
            // Simple force simulation
            let scale = 1;
            let translateX = 0;
            let translateY = 0;
            let showItems = true;
            let showTasks = true;
            
            // Filter functionality
            const toggleItemsBtn = document.getElementById('toggleItemsBtn');
            const toggleTasksBtn = document.getElementById('toggleTasksBtn');
            
            function updateNodeVisibility() {
                nodes.forEach(node => {
                    let shouldHide = false;
                    
                    // Hide items if toggled off
                    if (node.group === 'item' && !showItems) {
                        shouldHide = true;
                    }
                    
                    // Hide tasks if toggled off
                    if (node.group === 'task' && !showTasks) {
                        shouldHide = true;
                    }
                    
                    // Update node visibility
                    if (shouldHide) {
                        node.element.style.display = 'none';
                    } else {
                        node.element.style.display = '';
                    }
                });
                
                // Update edge visibility based on node visibility
                edges.forEach(edge => {
                    const source = nodeMap[edge.from];
                    const target = nodeMap[edge.to];
                    let shouldHide = false;
                    
                    // Hide edge if either node is hidden
                    if (source && source.group === 'item' && !showItems) {
                        shouldHide = true;
                    }
                    if (target && target.group === 'item' && !showItems) {
                        shouldHide = true;
                    }
                    if (source && source.group === 'task' && !showTasks) {
                        shouldHide = true;
                    }
                    if (target && target.group === 'task' && !showTasks) {
                        shouldHide = true;
                    }
                    
                    // Update edge visibility
                    if (shouldHide) {
                        edge.element.style.display = 'none';
                    } else {
                        edge.element.style.display = '';
                    }
                });
            }
            
            toggleItemsBtn.addEventListener('click', function() {
                showItems = !showItems;
                
                // Update button state
                if (showItems) {
                    toggleItemsBtn.classList.remove('btn-outline-success');
                    toggleItemsBtn.classList.add('btn-success');
                    toggleItemsBtn.querySelector('i').className = 'bi bi-eye';
                } else {
                    toggleItemsBtn.classList.remove('btn-success');
                    toggleItemsBtn.classList.add('btn-outline-success');
                    toggleItemsBtn.querySelector('i').className = 'bi bi-eye-slash';
                }
                
                updateNodeVisibility();
            });
            
            toggleTasksBtn.addEventListener('click', function() {
                showTasks = !showTasks;
                
                // Update button state
                if (showTasks) {
                    toggleTasksBtn.classList.remove('btn-outline-success');
                    toggleTasksBtn.classList.add('btn-success');
                    toggleTasksBtn.querySelector('i').className = 'bi bi-eye';
                } else {
                    toggleTasksBtn.classList.remove('btn-success');
                    toggleTasksBtn.classList.add('btn-outline-success');
                    toggleTasksBtn.querySelector('i').className = 'bi bi-eye-slash';
                }
                
                updateNodeVisibility();
            });
            
            function forceSimulation() {
                const centerX = width / 2;
                const centerY = height / 2;
                const repulsionStrength = 3000;
                const attractionStrength = 0.01;
                const damping = 0.8;
                
                // Apply forces
                nodes.forEach((node, i) => {
                    let fx = 0, fy = 0;
                    
                    // Repulsion between all nodes
                    nodes.forEach((other, j) => {
                        if (i === j) return;
                        const dx = node.x - other.x;
                        const dy = node.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = repulsionStrength / (dist * dist);
                        fx += (dx / dist) * force;
                        fy += (dy / dist) * force;
                    });
                    
                    // Attraction along edges
                    edges.forEach(edge => {
                        if (edge.from === node.id) {
                            const target = nodeMap[edge.to];
                            if (target) {
                                const dx = target.x - node.x;
                                const dy = target.y - node.y;
                                fx += dx * attractionStrength;
                                fy += dy * attractionStrength;
                            }
                        } else if (edge.to === node.id) {
                            const target = nodeMap[edge.from];
                            if (target) {
                                const dx = target.x - node.x;
                                const dy = target.y - node.y;
                                fx += dx * attractionStrength;
                                fy += dy * attractionStrength;
                            }
                        }
                    });
                    
                    // Pull towards center
                    fx += (centerX - node.x) * 0.001;
                    fy += (centerY - node.y) * 0.001;
                    
                    node.vx = (node.vx + fx) * damping;
                    node.vy = (node.vy + fy) * damping;
                });
                
                // Update positions
                nodes.forEach(node => {
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    // Keep within bounds
                    node.x = Math.max(50, Math.min(width - 50, node.x));
                    node.y = Math.max(50, Math.min(height - 50, node.y));
                });
                
                // Update visual positions
                nodes.forEach(node => {
                    node.element.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                });
                
                edges.forEach(edge => {
                    const source = nodeMap[edge.from];
                    const target = nodeMap[edge.to];
                    if (source && target) {
                        edge.element.setAttribute('x1', source.x);
                        edge.element.setAttribute('y1', source.y);
                        edge.element.setAttribute('x2', target.x);
                        edge.element.setAttribute('y2', target.y);
                    }
                });
            }
            
            // Run simulation
            let iterations = 0;
            const maxIterations = 500;
            let interval = setInterval(() => {
                forceSimulation();
                iterations++;
                if (iterations >= maxIterations) {
                    clearInterval(interval);
                }
            }, 16);
            
            // Zoom and pan functionality
            let isDragging = false;
            let startX, startY;
            
            svg.addEventListener('mousedown', (e) => {
                if (e.target === svg || e.target === edgeGroup || e.target === nodeGroup) {
                    isDragging = true;
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                }
            });
            
            svg.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    translateX = e.clientX - startX;
                    translateY = e.clientY - startY;
                    updateTransform();
                }
            });
            
            svg.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            svg.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            svg.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                scale *= delta;
                scale = Math.max(0.1, Math.min(5, scale));
                updateTransform();
            });
            
            function updateTransform() {
                nodeGroup.setAttribute('transform', `translate(${translateX}, ${translateY}) scale(${scale})`);
                edgeGroup.setAttribute('transform', `translate(${translateX}, ${translateY}) scale(${scale})`);
            }
            
            // Reset view button
            resetViewBtn.addEventListener('click', function() {
                scale = 1;
                translateX = 0;
                translateY = 0;
                updateTransform();
            });
            
            // Rearrange button - restart simulation with new random positions
            const rearrangeBtn = document.getElementById('rearrangeBtn');
            rearrangeBtn.addEventListener('click', function() {
                // Randomize positions
                nodes.forEach(node => {
                    node.x = Math.random() * width;
                    node.y = Math.random() * height;
                    node.vx = 0;
                    node.vy = 0;
                });
                
                // Restart simulation
                clearInterval(interval);
                iterations = 0;
                interval = setInterval(() => {
                    forceSimulation();
                    iterations++;
                    if (iterations >= maxIterations) {
                        clearInterval(interval);
                    }
                }, 16);
            });
        })
        .catch(error => {
            console.error('Error loading network data:', error);
            loadingSpinner.innerHTML = `
                <div class="alert alert-danger" role="alert">
                    <i class="bi bi-exclamation-triangle"></i> 
                    Fehler beim Laden der Netzwerkdaten: ${error.message}
                </div>
            `;
        });
});
</script>
{% endblock %}
