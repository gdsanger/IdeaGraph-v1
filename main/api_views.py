"""
API views for user management and authentication.
"""
import json
import base64
import logging
from urllib.parse import urlparse
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.core.paginator import Paginator
from django.utils import timezone
from .models import User
from .auth_utils import generate_jwt_token, decode_jwt_token, validate_password
from core.services.graph_service import GraphService, GraphServiceError
from core.services.github_service import GitHubService, GitHubServiceError
from core.services.kigate_service import KiGateService, KiGateServiceError
from core.services.openai_service import OpenAIService, OpenAIServiceError
from core.services.weaviate_task_sync_service import WeaviateTaskSyncService, WeaviateTaskSyncServiceError
from core.services.support_advisor_service import SupportAdvisorService, SupportAdvisorServiceError
from core.services.task_file_service import TaskFileService, TaskFileServiceError
from core.services.teams_service import TeamsService, TeamsServiceError

logger = logging.getLogger(__name__)


def clean_tag_name(tag_text):
    """
    Clean tag text by removing special characters, bullets, numbering, and quotes.
    
    This function ensures that tags generated by AI (e.g., from text-keyword-extractor-de)
    are properly cleaned before being stored in the database.
    
    Args:
        tag_text: Raw tag text from AI response
        
    Returns:
        Cleaned tag name or None if empty after cleaning
    """
    if not tag_text:
        return None
    
    # Remove common prefixes (numbers, bullets, brackets, quotes)
    # Format: "1. tag", "- tag", "* tag", "[tag]", '"tag"', etc.
    cleaned = tag_text.strip()
    
    # Remove leading characters: numbers, dots, dashes, asterisks, brackets, quotes, parentheses, bullets
    # This handles formats like: "1.", "2)", "-", "*", "[", '"', "(", "•", etc.
    while cleaned and cleaned[0] in '0123456789.-)(*["\' •':
        cleaned = cleaned[1:]
    
    # Remove trailing brackets, quotes, parentheses, asterisks, and whitespace
    while cleaned and cleaned[-1] in '])"\' *':
        cleaned = cleaned[:-1]
    
    # Final cleanup: strip any remaining whitespace
    cleaned = cleaned.strip()
    
    # Return None if the tag is empty after cleaning
    return cleaned if cleaned else None


def strip_quotes_from_title(title_text):
    """
    Remove quotation marks from the beginning and end of AI-generated titles.
    
    The text-to-title-generator agent often returns titles wrapped in quotation marks.
    This function removes both single and double quotation marks from the start and end
    of the title string.
    
    Args:
        title_text: Raw title text from AI response
        
    Returns:
        Title without surrounding quotation marks
    """
    if not title_text:
        return title_text
    
    cleaned = title_text.strip()
    
    # Remove leading and trailing quotation marks (both single and double)
    if cleaned and cleaned[0] in '"\'':
        cleaned = cleaned[1:]
    if cleaned and cleaned[-1] in '"\'':
        cleaned = cleaned[:-1]
    
    # Final cleanup: strip any whitespace that was inside the quotes
    return cleaned.strip()


def get_user_from_token(request):
    """Extract and validate user from JWT token in Authorization header"""
    auth_header = request.headers.get('Authorization', '')
    if not auth_header.startswith('Bearer '):
        return None
    
    token = auth_header[7:]
    payload = decode_jwt_token(token)
    if not payload:
        return None
    
    try:
        user = User.objects.get(id=payload['user_id'], is_active=True)
        return user
    except User.DoesNotExist:
        return None


def get_user_from_request(request):
    """
    Extract and validate user from either JWT token or session.
    This supports both API authentication (JWT) and web view authentication (session).
    """
    # First, try JWT authentication
    user = get_user_from_token(request)
    if user:
        return user
    
    # Fall back to session authentication
    user_id = request.session.get('user_id')
    if not user_id:
        return None
    
    try:
        user = User.objects.get(id=user_id, is_active=True)
        return user
    except User.DoesNotExist:
        return None


def require_admin(view_func):
    """Decorator to require admin role for API endpoints"""
    def wrapper(request, *args, **kwargs):
        user = get_user_from_request(request)  # Check both token and session
        if not user or user.role != 'admin':
            return JsonResponse({'error': 'Admin access required'}, status=403)
        request.user_obj = user
        return view_func(request, *args, **kwargs)
    return wrapper


@csrf_exempt
@require_http_methods(["POST"])
def api_login(request):
    """
    API endpoint for user authentication.
    POST /api/auth/login
    Body: {"username": "...", "password": "..."}
    """
    try:
        data = json.loads(request.body)
        username = data.get('username', '').strip()
        password = data.get('password', '')
        
        if not username or not password:
            return JsonResponse({'error': 'Username and password are required'}, status=400)
        
        # Find user
        try:
            user = User.objects.get(username=username)
        except User.DoesNotExist:
            return JsonResponse({'error': 'Invalid credentials'}, status=401)
        
        # Check if user is active
        if not user.is_active:
            return JsonResponse({'error': 'Account is inactive'}, status=401)
        
        # Verify password
        if not user.check_password(password):
            return JsonResponse({'error': 'Invalid credentials'}, status=401)
        
        # Update last login
        user.update_last_login()
        
        # Generate JWT token
        token = generate_jwt_token(user)
        
        return JsonResponse({
            'token': token,
            'user': {
                'id': str(user.id),
                'username': user.username,
                'email': user.email,
                'role': user.role,
                'is_active': user.is_active,
            }
        })
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Login error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during login'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_logout(request):
    """
    API endpoint for user logout.
    POST /api/auth/logout
    Note: Since JWT is stateless, this is mainly for client-side token removal
    """
    return JsonResponse({'message': 'Logged out successfully'})


@csrf_exempt
@require_http_methods(["GET"])
def api_user_list(request):
    """
    API endpoint to list all users (admin only).
    GET /api/users?page=1&per_page=10
    """
    user = get_user_from_token(request)
    if not user or user.role != 'admin':
        return JsonResponse({'error': 'Admin access required'}, status=403)
    
    try:
        page = int(request.GET.get('page', 1))
        per_page = int(request.GET.get('per_page', 10))
        per_page = min(per_page, 100)  # Max 100 per page
        
        users = User.objects.all().order_by('-created_at')
        paginator = Paginator(users, per_page)
        page_obj = paginator.get_page(page)
        
        users_data = [{
            'id': str(u.id),
            'username': u.username,
            'email': u.email,
            'role': u.role,
            'is_active': u.is_active,
            'created_at': u.created_at.isoformat(),
            'last_login': u.last_login.isoformat() if u.last_login else None,
            'ai_classification': u.ai_classification,
        } for u in page_obj]
        
        return JsonResponse({
            'users': users_data,
            'page': page,
            'per_page': per_page,
            'total': paginator.count,
            'total_pages': paginator.num_pages,
        })
        
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User list error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while retrieving users'}, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_user_detail(request, user_id):
    """
    API endpoint to get a specific user.
    GET /api/users/{user_id}
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    # Admin can view any user, regular users can only view themselves
    if user.role != 'admin' and str(user.id) != user_id:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        target_user = User.objects.get(id=user_id)
        return JsonResponse({
            'id': str(target_user.id),
            'username': target_user.username,
            'email': target_user.email,
            'role': target_user.role,
            'is_active': target_user.is_active,
            'created_at': target_user.created_at.isoformat(),
            'last_login': target_user.last_login.isoformat() if target_user.last_login else None,
            'ai_classification': target_user.ai_classification,
        })
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User detail error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while retrieving user details'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_user_create(request):
    """
    API endpoint to create a new user (admin only).
    POST /api/users
    Body: {"username": "...", "email": "...", "password": "...", "role": "...", "is_active": true}
    """
    try:
        data = json.loads(request.body)
        
        username = data.get('username', '').strip()
        email = data.get('email', '').strip()
        password = data.get('password', '')
        role = data.get('role', 'user')
        is_active = data.get('is_active', True)
        ai_classification = data.get('ai_classification', '')
        
        # Validation
        if not username:
            return JsonResponse({'error': 'Username is required'}, status=400)
        if not email:
            return JsonResponse({'error': 'Email is required'}, status=400)
        if not password:
            return JsonResponse({'error': 'Password is required'}, status=400)
        
        # Check if username or email already exists
        if User.objects.filter(username=username).exists():
            return JsonResponse({'error': 'Username already exists'}, status=400)
        if User.objects.filter(email=email).exists():
            return JsonResponse({'error': 'Email already exists'}, status=400)
        
        # Validate password
        is_valid, error_msg = validate_password(password)
        if not is_valid:
            return JsonResponse({'error': error_msg}, status=400)
        
        # Validate role
        valid_roles = ['admin', 'developer', 'user', 'viewer']
        if role not in valid_roles:
            return JsonResponse({'error': f'Invalid role. Must be one of: {", ".join(valid_roles)}'}, status=400)
        
        # Create user
        user = User(
            username=username,
            email=email,
            role=role,
            is_active=is_active,
            ai_classification=ai_classification
        )
        user.set_password(password)
        user.save()
        
        return JsonResponse({
            'id': str(user.id),
            'username': user.username,
            'email': user.email,
            'role': user.role,
            'is_active': user.is_active,
            'created_at': user.created_at.isoformat(),
            'ai_classification': user.ai_classification,
        }, status=201)
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User create error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while creating user'}, status=500)


@csrf_exempt
@require_http_methods(["PUT"])
def api_user_update(request, user_id):
    """
    API endpoint to update a user.
    PUT /api/users/{user_id}
    Body: {"email": "...", "role": "...", "is_active": true, "password": "..." (optional)}
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    # Admin can update any user, regular users can only update themselves (limited fields)
    if user.role != 'admin' and str(user.id) != user_id:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        target_user = User.objects.get(id=user_id)
        data = json.loads(request.body)
        
        # Regular users can only update their own email and password
        if user.role != 'admin':
            if 'email' in data:
                email = data['email'].strip()
                if email and email != target_user.email:
                    if User.objects.filter(email=email).exclude(id=user_id).exists():
                        return JsonResponse({'error': 'Email already exists'}, status=400)
                    target_user.email = email
            
            if 'password' in data and data['password']:
                password = data['password']
                is_valid, error_msg = validate_password(password)
                if not is_valid:
                    return JsonResponse({'error': error_msg}, status=400)
                target_user.set_password(password)
        else:
            # Admin can update all fields
            if 'email' in data:
                email = data['email'].strip()
                if email and email != target_user.email:
                    if User.objects.filter(email=email).exclude(id=user_id).exists():
                        return JsonResponse({'error': 'Email already exists'}, status=400)
                    target_user.email = email
            
            if 'role' in data:
                role = data['role']
                valid_roles = ['admin', 'developer', 'user', 'viewer']
                if role not in valid_roles:
                    return JsonResponse({'error': f'Invalid role. Must be one of: {", ".join(valid_roles)}'}, status=400)
                target_user.role = role
            
            if 'is_active' in data:
                target_user.is_active = bool(data['is_active'])
            
            if 'ai_classification' in data:
                target_user.ai_classification = data['ai_classification']
            
            if 'password' in data and data['password']:
                password = data['password']
                is_valid, error_msg = validate_password(password)
                if not is_valid:
                    return JsonResponse({'error': error_msg}, status=400)
                target_user.set_password(password)
        
        target_user.save()
        
        return JsonResponse({
            'id': str(target_user.id),
            'username': target_user.username,
            'email': target_user.email,
            'role': target_user.role,
            'is_active': target_user.is_active,
            'created_at': target_user.created_at.isoformat(),
            'last_login': target_user.last_login.isoformat() if target_user.last_login else None,
            'ai_classification': target_user.ai_classification,
        })
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User update error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while updating user'}, status=500)


@csrf_exempt
@require_http_methods(["DELETE"])
@require_admin
def api_user_delete(request, user_id):
    """
    API endpoint to delete a user (admin only).
    DELETE /api/users/{user_id}
    """
    try:
        target_user = User.objects.get(id=user_id)
        
        # Prevent self-deletion
        if str(request.user_obj.id) == user_id:
            return JsonResponse({'error': 'Cannot delete your own account'}, status=400)
        
        username = target_user.username
        target_user.delete()
        
        return JsonResponse({'message': f'User "{username}" deleted successfully'})
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User delete error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while deleting user'}, status=500)


# Graph API Endpoints

@csrf_exempt
@require_http_methods(["GET"])
@require_admin
def api_graph_sharepoint_files(request):
    """
    API endpoint to list SharePoint files (admin only).
    GET /api/graph/sharepoint/files?folder_path=Documents
    """
    try:
        folder_path = request.GET.get('folder_path', '')
        
        graph = GraphService()
        result = graph.get_sharepoint_file_list(folder_path)
        
        return JsonResponse(result)
        
    except GraphServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'Graph API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'SharePoint files list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing files',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_graph_sharepoint_upload(request):
    """
    API endpoint to upload a file to SharePoint (admin only).
    POST /api/graph/sharepoint/upload
    Body: {"folder_path": "Documents", "file_name": "test.txt", "content": "base64_encoded_content"}
    """
    try:
        data = json.loads(request.body)
        
        folder_path = data.get('folder_path', '')
        file_name = data.get('file_name')
        content_b64 = data.get('content')
        
        if not file_name:
            return JsonResponse({'error': 'file_name is required'}, status=400)
        
        if not content_b64:
            return JsonResponse({'error': 'content is required'}, status=400)
        
        # Decode base64 content
        try:
            content = base64.b64decode(content_b64)
        except Exception as e:
            return JsonResponse({'error': 'Invalid base64 content', 'details': 'An error occurred'}, status=400)
        
        graph = GraphService()
        result = graph.upload_sharepoint_file(folder_path, file_name, content)
        
        return JsonResponse(result, status=201)
        
    except GraphServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'Graph API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'SharePoint upload error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while uploading file',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_graph_mail_send(request):
    """
    API endpoint to send a test email via Graph API (admin only).
    POST /api/graph/mail/send
    Body: {"to": ["user@domain.com"], "subject": "Test", "body": "Test message"}
    """
    try:
        data = json.loads(request.body)
        
        to = data.get('to')
        subject = data.get('subject')
        body = data.get('body')
        
        if not to or not isinstance(to, list):
            return JsonResponse({'error': 'to must be a list of email addresses'}, status=400)
        
        if not subject:
            return JsonResponse({'error': 'subject is required'}, status=400)
        
        if not body:
            return JsonResponse({'error': 'body is required'}, status=400)
        
        graph = GraphService()
        result = graph.send_mail(to, subject, body)
        
        return JsonResponse(result)
        
    except GraphServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'Graph API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Mail send error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while sending email',
            'details': 'An error occurred'
        }, status=500)


# GitHub API Endpoints

def require_developer(view_func):
    """Decorator to require admin or developer role for API endpoints"""
    def wrapper(request, *args, **kwargs):
        user = get_user_from_token(request)
        if not user or user.role not in ['admin', 'developer']:
            return JsonResponse({'error': 'Admin or developer access required'}, status=403)
        request.user_obj = user
        return view_func(request, *args, **kwargs)
    return wrapper


@csrf_exempt
@require_http_methods(["GET"])
@require_developer
def api_github_repos(request):
    """
    API endpoint to list GitHub repositories (admin/developer only).
    GET /api/github/repos?owner=username&per_page=30&page=1
    """
    try:
        owner = request.GET.get('owner')
        per_page = int(request.GET.get('per_page', 30))
        page = int(request.GET.get('page', 1))
        
        github = GitHubService()
        result = github.get_repositories(owner=owner, per_page=per_page, page=page)
        
        return JsonResponse(result)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub repos list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing repositories'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_developer
def api_github_create_issue(request):
    """
    API endpoint to create a GitHub issue (admin/developer only).
    POST /api/github/create-issue
    Body: {"owner": "...", "repo": "...", "title": "...", "body": "...", "labels": ["..."], "assignees": ["..."]}
    """
    try:
        data = json.loads(request.body)
        
        title = data.get('title')
        body = data.get('body')
        owner = data.get('owner')
        repo = data.get('repo')
        labels = data.get('labels', [])
        assignees = data.get('assignees', [])
        
        if not title:
            return JsonResponse({'error': 'title is required'}, status=400)
        
        if not body:
            return JsonResponse({'error': 'body is required'}, status=400)
        
        github = GitHubService()
        result = github.create_issue(
            title=title,
            body=body,
            owner=owner,
            repo=repo,
            labels=labels,
            assignees=assignees
        )
        
        return JsonResponse(result, status=201)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub create issue error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while creating issue'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
@require_developer
def api_github_get_issue(request, owner, repo, issue_number):
    """
    API endpoint to get a specific GitHub issue (admin/developer only).
    GET /api/github/issue/{owner}/{repo}/{issue_number}
    """
    try:
        github = GitHubService()
        result = github.get_issue(
            issue_number=int(issue_number),
            owner=owner,
            repo=repo
        )
        
        return JsonResponse(result)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except ValueError:
        return JsonResponse({'error': 'Invalid issue number'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub get issue error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while retrieving issue'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
@require_developer
def api_github_list_issues(request, owner, repo):
    """
    API endpoint to list GitHub issues in a repository (admin/developer only).
    GET /api/github/issues/{owner}/{repo}?state=open&labels=bug,feature&per_page=30&page=1
    """
    try:
        state = request.GET.get('state', 'open')
        labels_str = request.GET.get('labels')
        labels = labels_str.split(',') if labels_str else None
        per_page = int(request.GET.get('per_page', 30))
        page = int(request.GET.get('page', 1))
        
        github = GitHubService()
        result = github.list_issues(
            owner=owner,
            repo=repo,
            state=state,
            labels=labels,
            per_page=per_page,
            page=page
        )
        
        return JsonResponse(result)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub list issues error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing issues'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_github_sync_issues_to_tasks(request, item_id):
    """
    API endpoint to sync GitHub issues to IdeaGraph tasks for a specific item.
    POST /api/github/sync-issues-to-tasks/<item_id>
    
    Request body (JSON):
    {
        "owner": "optional-owner",  // defaults to settings or item's repo
        "repo": "optional-repo",    // defaults to item's github_repo
        "state": "all"              // 'open', 'closed', or 'all' (default: 'all')
    }
    
    Response:
    {
        "success": true,
        "issues_checked": 15,
        "tasks_created": 10,
        "duplicates_by_id": 3,
        "duplicates_by_title": 2,
        "errors": []
    }
    """
    from core.services.github_task_sync_service import GitHubTaskSyncService, GitHubTaskSyncServiceError
    from .models import Item, User
    
    try:
        # Get user from session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({
                'success': False,
                'error': 'Authentication required'
            }, status=401)
        
        user = User.objects.filter(id=user_id).first()
        if not user:
            return JsonResponse({
                'success': False,
                'error': 'User not found'
            }, status=401)
        
        # Get the item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Item not found'
            }, status=404)
        
        # Check permissions (admin or item owner)
        if user.role != 'admin' and item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Parse request body
        try:
            data = json.loads(request.body) if request.body else {}
        except json.JSONDecodeError:
            data = {}
        
        owner = data.get('owner')
        repo = data.get('repo')
        state = data.get('state', 'all')
        
        # Initialize sync service
        sync_service = GitHubTaskSyncService()
        
        # Perform synchronization
        result = sync_service.sync_github_issues_to_tasks(
            item=item,
            owner=owner,
            repo=repo,
            state=state,
            created_by=user
        )
        
        # Sanitize error messages to prevent information leakage
        if 'errors' in result and result['errors']:
            # Keep count but don't expose detailed error messages
            result['error_count'] = len(result['errors'])
            result['errors'] = []  # Clear detailed errors for security
        
        return JsonResponse(result)
        
    except GitHubTaskSyncServiceError as e:
        logger.error(f'GitHub task sync error: {e.message}')
        # Don't expose internal details to external users
        return JsonResponse({
            'success': False,
            'error': e.message
        }, status=500)
    except Exception as e:
        logger.exception(f'Unexpected error in GitHub task sync: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An unexpected error occurred during synchronization'
        }, status=500)


# ==================== KiGate API Endpoints ====================

@csrf_exempt
@require_http_methods(["GET"])
def api_kigate_agents(request):
    """
    API endpoint to list all available KiGate agents.
    GET /api/kigate/agents
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        kigate = KiGateService()
        result = kigate.get_agents()
        
        return JsonResponse(result)
        
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate agents list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing agents'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_kigate_execute(request):
    """
    API endpoint to execute a KiGate agent.
    POST /api/kigate/execute
    Body: {
        "agent_name": "...",
        "provider": "...",
        "model": "...",
        "message": "...",
        "user_id": "...",
        "parameters": {...}  // optional
    }
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        data = json.loads(request.body)
        
        agent_name = data.get('agent_name')
        provider = data.get('provider')
        model = data.get('model')
        message = data.get('message')
        user_id = data.get('user_id')
        parameters = data.get('parameters')
        
        # Validate required fields
        if not agent_name:
            return JsonResponse({'error': 'agent_name is required'}, status=400)
        if not provider:
            return JsonResponse({'error': 'provider is required'}, status=400)
        if not model:
            return JsonResponse({'error': 'model is required'}, status=400)
        if not message:
            return JsonResponse({'error': 'message is required'}, status=400)
        if not user_id:
            return JsonResponse({'error': 'user_id is required'}, status=400)
        
        kigate = KiGateService()
        result = kigate.execute_agent(
            agent_name=agent_name,
            provider=provider,
            model=model,
            message=message,
            user_id=user_id,
            parameters=parameters
        )
        
        return JsonResponse(result, status=200)
        
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate execute error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while executing agent'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_kigate_agent_details(request, agent_name):
    """
    API endpoint to get details of a specific KiGate agent.
    GET /api/kigate/agent/{agent_name}
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        kigate = KiGateService()
        result = kigate.get_agent_details(agent_name=agent_name)
        
        return JsonResponse(result)
        
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate agent details error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while getting agent details'
        }, status=500)


# ==================== OpenAI API Endpoints ====================

@csrf_exempt
@require_http_methods(["POST"])
def api_openai_query(request):
    """
    API endpoint to execute an AI query via OpenAI API (with KiGate fallback).
    POST /api/openai/query
    Body: {
        "prompt": "...",
        "model": "..." (optional),
        "user_id": "..." (optional),
        "agent_name": "..." (optional - for KiGate routing),
        "temperature": 0.7 (optional),
        "max_tokens": 1000 (optional)
    }
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        data = json.loads(request.body)
        
        prompt = data.get('prompt')
        model = data.get('model')
        user_id = data.get('user_id', str(user.id))
        agent_name = data.get('agent_name')
        temperature = data.get('temperature', 0.7)
        max_tokens = data.get('max_tokens')
        
        # Validate required fields
        if not prompt:
            return JsonResponse({'error': 'prompt is required'}, status=400)
        
        openai = OpenAIService()
        
        # Use agent routing if agent_name is provided
        if agent_name:
            result = openai.query_with_agent(
                prompt=prompt,
                agent_name=agent_name,
                user_id=user_id,
                model=model
            )
        else:
            result = openai.query(
                prompt=prompt,
                model=model,
                user_id=user_id,
                temperature=temperature,
                max_tokens=max_tokens
            )
        
        return JsonResponse(result, status=200)
        
    except OpenAIServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI query error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while executing query'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_openai_models(request):
    """
    API endpoint to list available OpenAI models.
    GET /api/openai/models
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        openai = OpenAIService()
        result = openai.get_models()
        
        return JsonResponse(result)
        
    except OpenAIServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI models list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing models'
        }, status=500)


# ==================== Task API Endpoints ====================

@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_tasks(request, item_id=None):
    """
    API endpoint for task CRUD operations.
    GET /api/tasks/{item_id} - List tasks for an item
    POST /api/tasks/{item_id} - Create a new task
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Task, Tag
    
    if request.method == 'GET':
        # List tasks for an item
        if not item_id:
            return JsonResponse({'error': 'item_id is required'}, status=400)
        
        try:
            item = Item.objects.get(id=item_id)
            # Check ownership
            if user.role != 'admin' and item.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
            
            # Get tasks for this item - only show owned tasks
            tasks = item.tasks.filter(created_by=user).select_related('assigned_to', 'created_by').prefetch_related('tags')
            
            # Sort tasks by status priority
            status_order = {'new': 1, 'working': 2, 'review': 3, 'ready': 4, 'done': 5}
            tasks = sorted(tasks, key=lambda t: status_order.get(t.status, 99))
            
            tasks_data = [{
                'id': str(task.id),
                'title': task.title,
                'description': task.description,
                'status': task.status,
                'status_display': task.get_status_display(),
                'github_issue_id': task.github_issue_id,
                'github_issue_url': task.github_issue_url,
                'assigned_to': task.assigned_to.username if task.assigned_to else None,
                'created_at': task.created_at.isoformat(),
                'updated_at': task.updated_at.isoformat(),
                'tags': [{'id': str(tag.id), 'name': tag.name, 'color': tag.color} for tag in task.tags.all()],
            } for task in tasks]
            
            return JsonResponse({
                'success': True,
                'tasks': tasks_data
            })
            
        except Item.DoesNotExist:
            return JsonResponse({'error': 'Item not found'}, status=404)
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f'Task list error: {str(e)}')
            return JsonResponse({'error': 'An error occurred while listing tasks'}, status=500)
    
    elif request.method == 'POST':
        # Create a new task
        if not item_id:
            return JsonResponse({'error': 'item_id is required'}, status=400)
        
        try:
            data = json.loads(request.body)
            item = Item.objects.get(id=item_id)
            
            # Check ownership
            if user.role != 'admin' and item.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
            
            title = data.get('title', '').strip()
            description = data.get('description', '').strip()
            status = data.get('status', 'new')
            tag_ids = data.get('tags', [])
            
            if not title:
                return JsonResponse({'error': 'Title is required'}, status=400)
            
            # Create task
            task = Task(
                title=title,
                description=description,
                status=status,
                item=item,
                created_by=user,
                assigned_to=user
            )
            task.save()
            
            # Add tags
            if tag_ids:
                task.tags.set(tag_ids)
            
            # Sync with Weaviate
            try:
                from main.models import Settings
                settings = Settings.objects.first()
                if settings:
                    sync_service = WeaviateTaskSyncService(settings)
                    sync_service.sync_create(task)
            except WeaviateTaskSyncServiceError as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync failed for task {task.id}: {e.message}')
            except Exception as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync error for task {task.id}: {str(e)}')
            
            return JsonResponse({
                'success': True,
                'task': {
                    'id': str(task.id),
                    'title': task.title,
                    'description': task.description,
                    'status': task.status,
                    'status_display': task.get_status_display(),
                }
            }, status=201)
            
        except Item.DoesNotExist:
            return JsonResponse({'error': 'Item not found'}, status=404)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f'Task create error: {str(e)}')
            return JsonResponse({'error': 'An error occurred while creating task'}, status=500)


@csrf_exempt
@require_http_methods(["GET", "PUT", "DELETE"])
def api_task_detail(request, task_id):
    """
    API endpoint for task detail operations.
    GET /api/tasks/{task_id} - Get task details
    PUT /api/tasks/{task_id} - Update a task
    DELETE /api/tasks/{task_id} - Delete a task
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Check ownership
        if task.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        if request.method == 'GET':
            return JsonResponse({
                'success': True,
                'task': {
                    'id': str(task.id),
                    'title': task.title,
                    'description': task.description,
                    'status': task.status,
                    'status_display': task.get_status_display(),
                    'github_issue_id': task.github_issue_id,
                    'github_issue_url': task.github_issue_url,
                    'assigned_to': task.assigned_to.username if task.assigned_to else None,
                    'created_at': task.created_at.isoformat(),
                    'updated_at': task.updated_at.isoformat(),
                    'tags': [{'id': str(tag.id), 'name': tag.name, 'color': tag.color} for tag in task.tags.all()],
                }
            })
        
        elif request.method == 'PUT':
            data = json.loads(request.body)
            
            title = data.get('title', '').strip()
            description = data.get('description', '').strip()
            status = data.get('status', task.status)
            tag_ids = data.get('tags', [])
            
            if not title:
                return JsonResponse({'error': 'Title is required'}, status=400)
            
            previous_status = task.status
            task.title = title
            task.description = description
            task.status = status

            # Mark as done if status changed to done
            if status == 'done' and previous_status != 'done':
                task.save()
                task.mark_as_done()
            else:
                task.save()
            
            # Update tags
            if tag_ids:
                task.tags.set(tag_ids)
            else:
                task.tags.clear()
            
            # Sync with Weaviate
            try:
                from main.models import Settings
                settings = Settings.objects.first()
                if settings:
                    sync_service = WeaviateTaskSyncService(settings)
                    sync_service.sync_update(task)
            except WeaviateTaskSyncServiceError as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync failed for task {task.id}: {e.message}')
            except Exception as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync error for task {task.id}: {str(e)}')
            
            return JsonResponse({
                'success': True,
                'task': {
                    'id': str(task.id),
                    'title': task.title,
                    'description': task.description,
                    'status': task.status,
                    'status_display': task.get_status_display(),
                }
            })
        
        elif request.method == 'DELETE':
            task_id = str(task.id)
            task.delete()
            
            # Sync with Weaviate
            try:
                from main.models import Settings
                settings = Settings.objects.first()
                if settings:
                    sync_service = WeaviateTaskSyncService(settings)
                    sync_service.sync_delete(task_id)
            except WeaviateTaskSyncServiceError as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync failed for task {task_id}: {e.message}')
            except Exception as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync error for task {task_id}: {str(e)}')
            
            return JsonResponse({'success': True, 'message': 'Task deleted successfully'})
    
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Task operation error: {str(e)}')
        return JsonResponse({'error': 'An error occurred'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_generate_title(request, task_id):
    """
    API endpoint to generate task title from description using AI.
    POST /api/tasks/{task_id}/generate-title
    Body: {"description": "..."}
    
    Uses KiGate API with "text-to-title-generator" agent.
    Can work with unsaved tasks (task_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        # Task ID might be "new" for unsaved tasks
        if task_id != 'new':
            task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to generate title
        kigate = KiGateService()
        
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not title_result.get('success'):
            return JsonResponse({'error': title_result.get('error', 'Failed to generate title')}, status=500)
        
        generated_title = title_result.get('result', title_result.get('response', '')).strip()
        generated_title = strip_quotes_from_title(generated_title)
        if generated_title:
            generated_title = generated_title[:255]  # Limit to field max length
        
        return JsonResponse({
            'success': True,
            'title': generated_title
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task title generation error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during title generation'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_extract_tags(request, task_id):
    """
    API endpoint to extract tags from task description using AI.
    POST /api/tasks/{task_id}/extract-tags
    Body: {"description": "..."}
    
    Uses KiGate API with "text-keyword-extractor-de" agent.
    Can work with unsaved tasks (task_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Tag, Settings
    
    try:
        # Task ID might be "new" for unsaved tasks
        if task_id != 'new':
            task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Use KiGate service to extract tags
        kigate = KiGateService()
        
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        if not keyword_result.get('success'):
            return JsonResponse({'error': keyword_result.get('error', 'Failed to extract tags')}, status=500)
        
        # Parse keywords and create/get tags
        tags_list = []
        keywords_response = keyword_result.get('result', keyword_result.get('response', ''))
        # Extract keywords from response (can be comma-separated or line-separated)
        keywords = []
        for line in keywords_response.split('\n'):
            for k in line.split(','):
                cleaned_keyword = clean_tag_name(k)
                if cleaned_keyword and cleaned_keyword not in keywords:
                    keywords.append(cleaned_keyword)
        
        # Get or create tags (avoid duplicates)
        for keyword in keywords[:max_tags]:
            # Check if tag already exists (case-insensitive to avoid duplicates)
            tag = Tag.objects.filter(name__iexact=keyword).first()
            if not tag:
                tag = Tag.objects.create(name=keyword)
            tags_list.append(tag.name)
        
        return JsonResponse({
            'success': True,
            'tags': tags_list
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task tag extraction error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during tag extraction'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_optimize_description(request, task_id):
    """
    API endpoint to optimize/normalize task description using AI.
    POST /api/tasks/{task_id}/optimize-description
    Body: {"description": "..."}
    
    Uses KiGate API with "text-optimization-agent" agent.
    Can work with unsaved tasks (task_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        # Task ID might be "new" for unsaved tasks
        if task_id != 'new':
            task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to optimize description
        kigate = KiGateService()
        
        text_result = kigate.execute_agent(
            agent_name='text-optimization-agent',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to optimize description')}, status=500)
        
        optimized_text = text_result.get('result', text_result.get('response', description))
        
        return JsonResponse({
            'success': True,
            'description': optimized_text
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task description optimization error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during description optimization'}, status=500)


@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_task_ai_enhance(request, task_id):
    """
    API endpoint to enhance task with AI.
    
    GET /api/tasks/{task_id}/ai-enhance
    Returns endpoint information and usage instructions.
    
    POST /api/tasks/{task_id}/ai-enhance
    Body: {"title": "...", "description": "..."}
    
    Process:
    1. Query Weaviate for similar tasks to provide context
    2. Normalize text using KiGate API with "github-issue-creation-agent" with context
    3. Generate title from normalized text using "text-to-title-generator"
    4. Extract 5 tags using "text-keyword-extractor-de" and replace existing tags
    """
    # Handle GET requests with endpoint information
    if request.method == 'GET':
        return JsonResponse({
            'error': 'Method not allowed',
            'message': 'This endpoint only accepts POST requests',
            'method': 'POST',
            'endpoint': f'/api/tasks/{task_id}/ai-enhance',
            'required_body': {
                'title': 'string (required)',
                'description': 'string (required)'
            },
            'description': 'Enhances task with AI by normalizing text, generating title, and extracting tags'
        }, status=405)
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Tag, Settings
    
    try:
        task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        title = data.get('title', '').strip()
        description = data.get('description', '').strip()
        
        if not title or not description:
            return JsonResponse({'error': 'Title and description are required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Step 1: Query Weaviate for similar tasks to provide context
        context_text = ""
        try:
            weaviate_service = WeaviateTaskSyncService(settings)
            search_query = f"{title}\n{description}"
            similar_results = weaviate_service.search_similar(search_query, n_results=3)
            
            if similar_results.get('success') and similar_results.get('results'):
                context_items = []
                for idx, result in enumerate(similar_results['results'][:3], 1):
                    metadata = result.get('metadata', {})
                    doc = result.get('document', '')
                    context_items.append(f"Similar Task {idx}:\nTitle: {metadata.get('title', 'N/A')}\nDescription: {doc[:200]}...")
                
                context_text = "\n\n".join(context_items)
                logger.info(f"Found {len(similar_results['results'])} similar tasks for context")
        except Exception as e:
            logger.warning(f"Could not retrieve Weaviate context: {str(e)}")
            # Continue without context if Weaviate fails
        
        # Use KiGate service to enhance content
        kigate = KiGateService()
        
        # Step 2: Normalize text with context using github-issue-creation-agent
        normalization_message = f"Title: {title}\n\nDescription:\n{description}"
        if context_text:
            normalization_message += f"\n\n--- Context from similar tasks ---\n{context_text}\n--- End of context ---"
        
        text_result = kigate.execute_agent(
            agent_name='github-issue-creation-agent',
            provider='openai',
            model='gpt-4',
            message=normalization_message,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to normalize text')}, status=500)
        
        normalized_text = text_result.get('result', text_result.get('response', description))
        
        # Step 3: Generate title from normalized text using text-to-title-generator
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=normalized_text,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        enhanced_title = title
        if title_result.get('success'):
            generated_title = title_result.get('result', title_result.get('response', '')).strip()
            generated_title = strip_quotes_from_title(generated_title)
            if generated_title:
                enhanced_title = generated_title[:255]  # Limit to field max length
        
        # Step 4: Extract keywords/tags using text-keyword-extractor-de
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=normalized_text,
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        # Parse keywords and create/get tags
        tags_list = []
        if keyword_result.get('success'):
            keywords_response = keyword_result.get('result', keyword_result.get('response', ''))
            # Extract keywords from response (can be comma-separated or line-separated)
            keywords = []
            for line in keywords_response.split('\n'):
                for k in line.split(','):
                    cleaned_keyword = clean_tag_name(k)
                    if cleaned_keyword and cleaned_keyword not in keywords:
                        keywords.append(cleaned_keyword)
            
            # Get or create tags (avoid duplicates)
            for keyword in keywords[:max_tags]:
                # Check if tag already exists (case-insensitive to avoid duplicates)
                tag = Tag.objects.filter(name__iexact=keyword).first()
                if not tag:
                    tag = Tag.objects.create(name=keyword)
                tags_list.append(tag.name)
        
        return JsonResponse({
            'success': True,
            'title': enhanced_title,
            'description': normalized_text,
            'tags': tags_list
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except WeaviateTaskSyncServiceError as e:
        logger.error(f'Weaviate error: {e.message}')
        return JsonResponse({'error': 'Weaviate service error', 'details': e.message}, status=500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task AI enhance error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during AI enhancement'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_generate_title(request, item_id):
    """
    API endpoint to generate item title from description using AI.
    POST /api/items/{item_id}/generate-title
    Body: {"description": "..."}
    
    Uses KiGate API with "text-to-title-generator" agent.
    Can work with unsaved items (item_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item
    
    try:
        # Item ID might be "new" for unsaved items
        if item_id != 'new':
            item = Item.objects.get(id=item_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to generate title
        kigate = KiGateService()
        
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not title_result.get('success'):
            return JsonResponse({'error': title_result.get('error', 'Failed to generate title')}, status=500)
        
        generated_title = title_result.get('result', title_result.get('response', '')).strip()
        generated_title = strip_quotes_from_title(generated_title)
        if generated_title:
            generated_title = generated_title[:255]  # Limit to field max length
        
        return JsonResponse({
            'success': True,
            'title': generated_title
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Item title generation error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during title generation'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_extract_tags(request, item_id):
    """
    API endpoint to extract tags from item description using AI.
    POST /api/items/{item_id}/extract-tags
    Body: {"description": "..."}
    
    Uses KiGate API with "text-keyword-extractor-de" agent.
    Can work with unsaved items (item_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Tag, Settings
    
    try:
        # Item ID might be "new" for unsaved items
        if item_id != 'new':
            item = Item.objects.get(id=item_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Use KiGate service to extract tags
        kigate = KiGateService()
        
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        if not keyword_result.get('success'):
            return JsonResponse({'error': keyword_result.get('error', 'Failed to extract tags')}, status=500)
        
        # Parse keywords and create/get tags
        tags_list = []
        keywords_response = keyword_result.get('result', keyword_result.get('response', ''))
        # Extract keywords from response (can be comma-separated or line-separated)
        keywords = []
        for line in keywords_response.split('\n'):
            for k in line.split(','):
                cleaned_keyword = clean_tag_name(k)
                if cleaned_keyword and cleaned_keyword not in keywords:
                    keywords.append(cleaned_keyword)
        
        # Get or create tags (avoid duplicates)
        for keyword in keywords[:max_tags]:
            # Check if tag already exists (case-insensitive to avoid duplicates)
            tag = Tag.objects.filter(name__iexact=keyword).first()
            if not tag:
                tag = Tag.objects.create(name=keyword)
            tags_list.append(tag.name)
        
        return JsonResponse({
            'success': True,
            'tags': tags_list
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Item tag extraction error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during tag extraction'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_optimize_description(request, item_id):
    """
    API endpoint to optimize/normalize item description using AI.
    POST /api/items/{item_id}/optimize-description
    Body: {"description": "..."}
    
    Uses KiGate API with "text-optimization-agent" agent.
    Can work with unsaved items (item_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item
    
    try:
        # Item ID might be "new" for unsaved items
        if item_id != 'new':
            item = Item.objects.get(id=item_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to optimize description
        kigate = KiGateService()
        
        text_result = kigate.execute_agent(
            agent_name='text-optimization-agent',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to optimize description')}, status=500)
        
        optimized_text = text_result.get('result', text_result.get('response', description))
        
        return JsonResponse({
            'success': True,
            'description': optimized_text
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Item description optimization error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during description optimization'}, status=500)


@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_item_ai_enhance(request, item_id):
    """
    API endpoint to enhance item with AI using KiGate agents.
    
    This function performs three main tasks:
    1. Text normalization (spelling, grammar, flow, comprehensibility) using 'text-optimization-agent'
    2. Title generation from normalized text using 'text-to-title-generator'
    3. Tag/keyword extraction from item context using 'text-keyword-extractor-de'
    
    The generated tags replace any existing tags on the item to avoid duplicates.
    Tags are properly attached to the Item entity via the ManyToMany relationship.
    
    GET /api/items/{item_id}/ai-enhance
    Returns endpoint information and usage instructions.
    
    POST /api/items/{item_id}/ai-enhance
    Body: {"title": "...", "description": "..."}
    
    Returns:
        JSON response with enhanced title, description, and tags list
    """
    # Handle GET requests with endpoint information
    if request.method == 'GET':
        return JsonResponse({
            'error': 'Method not allowed',
            'message': 'This endpoint only accepts POST requests',
            'method': 'POST',
            'endpoint': f'/api/items/{item_id}/ai-enhance',
            'required_body': {
                'title': 'string (required)',
                'description': 'string (required)'
            },
            'description': 'Enhances item with AI by normalizing text, generating title, and extracting tags'
        }, status=405)
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Tag, Settings
    
    try:
        item = Item.objects.get(id=item_id)
        
        # Check ownership
        if item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        title = data.get('title', '').strip()
        description = data.get('description', '').strip()
        
        if not title or not description:
            return JsonResponse({'error': 'Title and description are required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Use KiGate service to enhance content
        kigate = KiGateService()
        
        # Step 1: Optimize/normalize the text (spelling, grammar, flow, comprehensibility)
        text_result = kigate.execute_agent(
            agent_name='text-optimization-agent',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to enhance text')}, status=500)
        
        # Use 'result' field from KiGate API response, not 'response'
        enhanced_text = text_result.get('result', description)
        
        # Step 2: Generate a title from the normalized text
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=enhanced_text,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        # Use generated title if successful, otherwise keep original
        enhanced_title = title
        if title_result.get('success'):
            generated_title = title_result.get('result', '').strip()
            generated_title = strip_quotes_from_title(generated_title)
            if generated_title:
                enhanced_title = generated_title[:255]  # Limit to field max length
        
        # Step 3: Extract keywords/tags from the item context
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=f"Title: {enhanced_title}\n\nDescription:\n{enhanced_text}",
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        # Parse keywords and manage tags
        tags_list = []
        if keyword_result.get('success'):
            keywords_text = keyword_result.get('result', '')
            # Extract keywords from response (handle comma-separated or newline-separated)
            keywords = []
            for k in keywords_text.replace('\n', ',').split(','):
                cleaned_keyword = clean_tag_name(k)
                if cleaned_keyword and cleaned_keyword not in keywords:
                    keywords.append(cleaned_keyword)
            
            # Clear existing tags to replace them with new ones
            item.tags.clear()
            
            # Get or create tags and attach to item (prevent duplicates)
            for keyword in keywords[:max_tags]:
                # Check if tag already exists (case-insensitive to avoid duplicates)
                tag = Tag.objects.filter(name__iexact=keyword).first()
                if not tag:
                    tag = Tag.objects.create(name=keyword)
                # Add tag to item (ManyToManyField handles duplicates automatically)
                item.tags.add(tag)
                tags_list.append(tag.name)
            
            # Mark that AI tags have been generated
            item.ai_tags_generated = True
        
        # Mark item as AI enhanced
        item.ai_enhanced = True
        item.save()
        
        return JsonResponse({
            'success': True,
            'title': enhanced_title,
            'description': enhanced_text,
            'tags': tags_list
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Item AI enhance error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during AI enhancement'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_build_tasks(request, item_id):
    """
    API endpoint to build/decompose tasks from an item using AI.
    POST /api/items/{item_id}/build-tasks
    Body: {"title": "...", "description": "..."}
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Task, Tag, Settings
    
    try:
        item = Item.objects.get(id=item_id)
        
        # Check ownership
        if item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        title = data.get('title', item.title).strip()
        description = data.get('description', item.description).strip()
        
        if not title or not description:
            return JsonResponse({'error': 'Title and description are required'}, status=400)
        
        # Use KiGate service to decompose item into tasks
        kigate = KiGateService()
        
        # Use task decomposition agent to generate tasks
        decompose_result = kigate.execute_agent(
            agent_name='task-decomposition-agent',
            provider='openai',
            model='gpt-4',
            message=f"Title: {title}\n\nDescription:\n{description}\n\nPlease decompose this into actionable tasks.",
            user_id=str(user.id),
            parameters={'max_tasks': 10}
        )
        
        if not decompose_result.get('success'):
            return JsonResponse({'error': decompose_result.get('error', 'Failed to decompose tasks')}, status=500)
        
        # Parse the response to extract tasks
        # Expected format: The agent should return tasks in a structured format
        response_text = decompose_result.get('response', '')
        
        # Parse tasks from response (assuming line-by-line format or JSON)
        tasks_created = []
        try:
            # Try to parse as JSON first
            import json as json_lib
            tasks_data = json_lib.loads(response_text)
            if isinstance(tasks_data, list):
                for task_data in tasks_data[:10]:  # Limit to 10 tasks
                    if isinstance(task_data, dict):
                        task_title = task_data.get('title', '')
                        task_desc = task_data.get('description', '')
                    else:
                        task_title = str(task_data)
                        task_desc = ''
                    
                    if task_title:
                        task = Task.objects.create(
                            title=task_title[:255],
                            description=task_desc,
                            status='new',
                            item=item,
                            created_by=user,
                            assigned_to=user,
                            ai_generated=True
                        )
                        tasks_created.append({
                            'id': str(task.id),
                            'title': task.title,
                            'description': task.description
                        })
        except (json_lib.JSONDecodeError, ValueError):
            # Fallback: Parse as line-separated tasks
            lines = response_text.split('\n')
            for line in lines[:10]:  # Limit to 10 tasks
                line = line.strip()
                # Remove common prefixes like "1.", "-", "*", etc.
                line = line.lstrip('0123456789.-* ')
                if line and len(line) > 3:
                    task = Task.objects.create(
                        title=line[:255],
                        description='',
                        status='new',
                        item=item,
                        created_by=user,
                        assigned_to=user,
                        ai_generated=True
                    )
                    tasks_created.append({
                        'id': str(task.id),
                        'title': task.title,
                        'description': task.description
                    })
        
        return JsonResponse({
            'success': True,
            'tasks': tasks_created,
            'count': len(tasks_created)
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Build tasks error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while building tasks'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_check_similarity(request, item_id):
    """
    API endpoint to check similarity for an item using Weaviate.
    POST /api/items/{item_id}/check-similarity
    Body: {"title": "...", "description": "..."}
    
    Returns only items with a relevance/similarity score of at least 0.8.
    The relevance score is calculated as: relevance = 1 - (distance / 2)
    where distance is the Weaviate cosine distance (0-2 range).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Settings
    from core.services.weaviate_sync_service import WeaviateItemSyncService, WeaviateItemSyncServiceError
    
    try:
        item = Item.objects.get(id=item_id)
        
        # Check ownership
        if item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        title = data.get('title', item.title).strip()
        description = data.get('description', item.description).strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use Weaviate to find similar items
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({'error': 'Settings not configured'}, status=500)
        
        weaviate_service = WeaviateItemSyncService(settings)
        
        # Search for similar items (request more results to ensure we have enough after filtering)
        search_text = f"{title}\n\n{description}"
        result = weaviate_service.search_similar(search_text, n_results=20)
        
        if not result.get('success'):
            return JsonResponse({'error': 'Failed to search for similar items'}, status=500)
        
        # Minimum relevance threshold (0.8 = 80% similarity)
        MIN_RELEVANCE = 0.8
        
        # Filter results by relevance and exclude current item
        similar_items = []
        for similar_item in result.get('results', []):
            # Skip the current item
            if similar_item.get('id') == str(item_id):
                continue
            
            # Convert Weaviate distance to relevance/similarity score
            # Weaviate uses cosine distance where 0 = identical, 2 = opposite
            # Relevance formula: 1 - (distance / 2)
            distance = similar_item.get('distance', 2.0)
            relevance = 1.0 - (distance / 2.0)
            
            # Only include items with relevance >= 0.8
            if relevance >= MIN_RELEVANCE:
                # Add relevance score to the item data
                similar_item['relevance'] = round(relevance, 3)
                similar_items.append(similar_item)
        
        return JsonResponse({
            'success': True,
            'similar_items': similar_items[:5]  # Limit to 5 most relevant results
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except WeaviateItemSyncServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Weaviate error: {e.message}')
        return JsonResponse(e.to_dict(), status=500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Check similarity error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while checking similarity'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_create_github_issue(request, task_id):
    """
    API endpoint to create GitHub issue from task.
    POST /api/tasks/{task_id}/create-github-issue
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Check status
        if task.status != 'ready':
            return JsonResponse({'error': 'Task must be in Ready status to create GitHub issue'}, status=400)
        
        # Check if issue already exists
        if task.github_issue_id:
            return JsonResponse({'error': 'GitHub issue already exists for this task'}, status=400)
        
        # Get GitHub repository from item
        if not task.item or not task.item.github_repo:
            return JsonResponse({'error': 'No GitHub repository configured for this item'}, status=400)
        
        # Parse owner/repo from github_repo field
        repo_parts = task.item.github_repo.split('/')
        if len(repo_parts) != 2:
            return JsonResponse({'error': 'Invalid GitHub repository format. Expected: owner/repo'}, status=400)
        
        owner, repo = repo_parts
        
        # Prepare labels from tags
        labels = [tag.name for tag in task.tags.all()]
        
        # Get settings for GitHub Copilot username
        from .models import Settings
        settings = Settings.objects.first()
        assignees = []
        if settings and settings.github_copilot_username:
            assignees = [settings.github_copilot_username]
        
        # Create GitHub issue
        # NOTE: GitHub milestone support is available but requires:
        # 1. Milestone must exist in GitHub repository first
        # 2. GitHub milestone number (not name) must be used
        # To enable: Add milestone_number field to Milestone model or map by name
        github = GitHubService()
        result = github.create_issue(
            title=task.title,
            body=task.description,
            owner=owner,
            repo=repo,
            labels=labels,
            assignees=assignees
        )
        
        if result.get('success'):
            issue_number = result.get('issue_number')
            
            # Add comment with IdeaGraph reference
            try:
                # Get the host URL from the request
                host = request.get_host()
                scheme = 'https' if request.is_secure() else 'http'
                base_url = f"{scheme}://{host}"
                
                # Construct the link to the task in IdeaGraph
                task_url = f"{base_url}/tasks/{task.id}"
                
                # Create comment body
                comment_body = f"Created with IdeaGraph v1.0\n\nTask: {task_url}"
                
                # Add comment to the issue
                github.create_issue_comment(
                    issue_number=issue_number,
                    body=comment_body,
                    owner=owner,
                    repo=repo
                )
            except Exception as e:
                # Log error but don't fail the whole operation
                import logging
                logger = logging.getLogger(__name__)
                logger.warning(f'Failed to add comment to GitHub issue: {str(e)}')
            
            # Update task with GitHub issue info
            task.github_issue_id = issue_number
            task.github_issue_url = result.get('url')
            task.github_synced_at = timezone.now()
            task.save()
            
            return JsonResponse({
                'success': True,
                'issue_number': task.github_issue_id,
                'issue_url': task.github_issue_url,
                'message': 'GitHub issue created successfully'
            })
        else:
            return JsonResponse({'error': result.get('error', 'Failed to create GitHub issue')}, status=500)
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except GitHubServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Create GitHub issue error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while creating GitHub issue'}, status=500)


@csrf_exempt
@require_http_methods(["GET"])


@csrf_exempt
@require_http_methods(["GET"])
def api_task_overview(request):
    """
    API endpoint for global task overview with filtering and pagination.
    GET /api/tasks/overview?status=new&item=uuid&has_github=true&query=search&page=1&limit=20
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Item
    from django.db.models import Q, Count
    
    try:
        # Base query - show only user's tasks unless admin
        if user.role == 'admin':
            tasks = Task.objects.all()
        else:
            tasks = tasks = Task.objects.filter(created_by=user)
        
        # Apply filters
        status_filter = request.GET.get('status', '').strip()
        if status_filter:
            tasks = tasks.filter(status=status_filter)
        
        item_filter = request.GET.get('item', '').strip()
        if item_filter:
            tasks = tasks.filter(item_id=item_filter)
        
        has_github = request.GET.get('has_github', '').strip().lower()
        if has_github == 'true':
            tasks = tasks.filter(github_issue_id__isnull=False)
        elif has_github == 'false':
            tasks = tasks.filter(github_issue_id__isnull=True)
        
        query = request.GET.get('query', '').strip()
        if query:
            tasks = tasks.filter(
                Q(title__icontains=query) | 
                Q(description__icontains=query)
            )
        
        # Get status counts for badges (before pagination)
        status_counts = {}
        for status_key, status_label in Task.STATUS_CHOICES:
            if user.role == 'admin':
                count = Task.objects.filter(status=status_key).count()
            else:
                count = Task.objects.filter(status=status_key, created_by=user).count()
            status_counts[status_key] = {
                'label': status_label,
                'count': count
            }
        
        # Pagination
        page = int(request.GET.get('page', 1))
        limit = min(int(request.GET.get('limit', 20)), 100)  # Max 100 per page
        
        total_count = tasks.count()
        total_pages = (total_count + limit - 1) // limit if limit > 0 else 1
        
        start_index = (page - 1) * limit
        end_index = start_index + limit
        
        # Get tasks with related data
        tasks = tasks.select_related('item', 'assigned_to', 'created_by').prefetch_related('tags')
        tasks = tasks.order_by('-updated_at')[start_index:end_index]
        
        # Prepare response data
        tasks_data = []
        for task in tasks:
            tasks_data.append({
                'id': str(task.id),
                'title': task.title,
                'description': task.description,
                'status': task.status,
                'status_display': task.get_status_display(),
                'item': {
                    'id': str(task.item.id),
                    'title': task.item.title
                } if task.item else None,
                'github_issue_id': task.github_issue_id,
                'github_issue_url': task.github_issue_url,
                'github_synced_at': task.github_synced_at.isoformat() if task.github_synced_at else None,
                'assigned_to': {
                    'id': str(task.assigned_to.id),
                    'username': task.assigned_to.username
                } if task.assigned_to else None,
                'created_by': {
                    'id': str(task.created_by.id),
                    'username': task.created_by.username
                } if task.created_by else None,
                'created_at': task.created_at.isoformat(),
                'updated_at': task.updated_at.isoformat(),
                'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                'tags': [{'id': str(tag.id), 'name': tag.name, 'color': tag.color} for tag in task.tags.all()],
                'ai_enhanced': task.ai_enhanced,
                'ai_generated': task.ai_generated,
            })
        
        return JsonResponse({
            'success': True,
            'tasks': tasks_data,
            'status_counts': status_counts,
            'pagination': {
                'page': page,
                'limit': limit,
                'total_count': total_count,
                'total_pages': total_pages,
                'has_next': page < total_pages,
                'has_previous': page > 1
            }
        })
        
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Task overview error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while fetching task overview'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_send_item_email(request, item_id):
    """
    API endpoint to send item details via email.
    POST /api/items/{item_id}/send-email
    Body: {"email": "recipient@example.com"}
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item
    from .mail_utils import send_item_email
    
    try:
        # Get the item
        item = Item.objects.get(id=item_id)
        
        # Check ownership (only owner or admin can send)
        if user.role != 'admin' and item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        
        recipient_email = data.get('email', '').strip()
        
        if not recipient_email:
            return JsonResponse({'error': 'Email address is required'}, status=400)
        
        # Validate email format (basic validation)
        if '@' not in recipient_email or '.' not in recipient_email:
            return JsonResponse({'error': 'Invalid email address format'}, status=400)
        
        # Send the email
        success, message = send_item_email(item_id, recipient_email)
        
        if success:
            logger.info(f'Item {item.title} sent via email to {recipient_email} by user {user.username}')
            return JsonResponse({
                'success': True,
                'message': message
            })
        else:
            logger.error(f'Failed to send item {item.title} via email: {message}')
            return JsonResponse({
                'success': False,
                'error': message
            }, status=500)
            
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except Exception as e:
        logger.error(f'Send item email error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while sending email'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_bulk_delete(request):
    """
    API endpoint for bulk task deletion.
    POST /api/tasks/bulk-delete
    Body: {"task_ids": ["uuid1", "uuid2", ...]}
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Settings
    from django.core.exceptions import ValidationError
    
    try:
        data = json.loads(request.body)
        task_ids = data.get('task_ids', [])
        
        if not task_ids:
            return JsonResponse({'error': 'No task IDs provided'}, status=400)
        
        if not isinstance(task_ids, list):
            return JsonResponse({'error': 'task_ids must be a list'}, status=400)
        
        # Validate UUIDs
        valid_task_ids = []
        for task_id in task_ids:
            try:
                import uuid
                uuid.UUID(str(task_id))
                valid_task_ids.append(task_id)
            except (ValueError, AttributeError):
                # Skip invalid UUIDs
                pass
        
        if not valid_task_ids:
            return JsonResponse({'error': 'No valid task IDs provided'}, status=400)
        
        # Get all tasks that belong to the user
        tasks = Task.objects.filter(id__in=valid_task_ids, created_by=user)
        
        if not tasks.exists():
            return JsonResponse({'error': 'No tasks found or access denied'}, status=404)
        
        # Store task IDs for Weaviate sync before deletion
        deleted_task_ids = [str(task.id) for task in tasks]
        deleted_count = tasks.count()
        
        # Delete tasks
        tasks.delete()
        
        # Sync with Weaviate
        try:
            settings = Settings.objects.first()
            if settings:
                sync_service = WeaviateTaskSyncService(settings)
                for task_id in deleted_task_ids:
                    try:
                        sync_service.sync_delete(task_id)
                    except Exception as sync_error:
                        logger.warning(f'Weaviate sync failed for task {task_id}: {str(sync_error)}')
        except Exception as e:
            logger.warning(f'Weaviate sync error: {str(e)}')
        
        logger.info(f'User {user.username} deleted {deleted_count} task(s)')
        
        return JsonResponse({
            'success': True,
            'message': f'{deleted_count} task(s) deleted successfully',
            'deleted_count': deleted_count
        })
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Bulk delete error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while deleting tasks'}, status=500)


@csrf_exempt
@require_http_methods(['POST'])
def api_task_move(request, task_id):
    """
    API endpoint to move a task to a different item
    
    Expects JSON body:
    {
        "target_item_id": "uuid-of-target-item"
    }
    
    Returns:
    {
        "success": true,
        "message": "Task moved successfully",
        "moved": true,
        "files_moved": true,
        "files_count": 2
    }
    """
    from .models import Task, Item, Settings, User
    from core.services.task_move_service import TaskMoveService, TaskMoveServiceError
    
    try:
        # Get current user from session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        try:
            user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        
        # Validate required fields
        target_item_id = data.get('target_item_id')
        if not target_item_id:
            return JsonResponse({'error': 'target_item_id is required'}, status=400)
        
        # Verify task exists
        try:
            task = Task.objects.get(id=task_id)
        except Task.DoesNotExist:
            return JsonResponse({'error': 'Task not found'}, status=404)
        
        # Check permissions - user must be the creator or admin
        if user.role != 'admin' and task.created_by != user:
            return JsonResponse({'error': 'Permission denied'}, status=403)
        
        # Initialize move service
        try:
            settings = Settings.objects.first()
            move_service = TaskMoveService(settings)
        except Exception as e:
            logger.error(f'Failed to initialize TaskMoveService: {str(e)}')
            return JsonResponse({
                'error': 'Service initialization failed'
            }, status=500)
        
        # Perform the move
        try:
            result = move_service.move_task(
                task_id=str(task_id),
                target_item_id=str(target_item_id),
                user=user
            )
            
            logger.info(f'Task {task_id} moved by user {user.username}')
            return JsonResponse(result)
            
        except TaskMoveServiceError as e:
            logger.error(f'Task move failed: {e.message}')
            return JsonResponse({
                'error': e.message
            }, status=400)
    
    except Exception as e:
        logger.error(f'Task move error: {str(e)}')
        return JsonResponse({
            'error': 'An error occurred while moving the task'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_support_analysis_internal(request, task_id):
    """
    API endpoint to perform internal support analysis for a task using Weaviate knowledge base
    
    POST /api/tasks/{task_id}/support-analysis-internal
    Body: {"description": "..."}
    
    Uses SupportAdvisorService with internal mode (Weaviate RAG)
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use SupportAdvisorService for internal analysis
        advisor = SupportAdvisorService()
        
        result = advisor.analyze_internal(
            task_description=description,
            task_title=task.title,
            user_id=str(user.id),
            max_results=5
        )
        
        return JsonResponse(result)
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except SupportAdvisorServiceError as e:
        logger.error(f'Support analysis error: {e.message}')
        return JsonResponse(e.to_dict(), status=500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Internal support analysis error: {str(e)}')
        return JsonResponse({
            'error': 'An error occurred during internal support analysis'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_support_analysis_external(request, task_id):
    """
    API endpoint to perform external support analysis for a task using web search
    
    POST /api/tasks/{task_id}/support-analysis-external
    Body: {"description": "..."}
    
    Uses SupportAdvisorService with external mode (Web Search + AI)
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use SupportAdvisorService for external analysis
        advisor = SupportAdvisorService()
        
        result = advisor.analyze_external(
            task_description=description,
            task_title=task.title,
            user_id=str(user.id),
            max_results=5
        )
        
        return JsonResponse(result)
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except SupportAdvisorServiceError as e:
        logger.error(f'Support analysis error: {e.message}')
        return JsonResponse(e.to_dict(), status=500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'External support analysis error: {str(e)}')
        return JsonResponse({
            'error': 'An error occurred during external support analysis'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_support_analysis_save(request, task_id):
    """
    API endpoint to save support analysis results
    
    POST /api/tasks/{task_id}/support-analysis-save
    Body: {
        "analysis": "markdown content",
        "mode": "internal" or "external"
    }
    
    Saves the analysis result as:
    - Markdown file uploaded to SharePoint
    - KnowledgeObject in Weaviate
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Settings
    from datetime import datetime
    from core.services.weaviate_sync_service import WeaviateItemSyncService
    
    try:
        task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        analysis = data.get('analysis', '').strip()
        mode = data.get('mode', 'internal')
        
        if not analysis:
            return JsonResponse({'error': 'Analysis content is required'}, status=400)
        
        # Generate filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        mode_prefix = 'intern' if mode == 'internal' else 'extern'
        filename = f"Support_Analyse_{mode_prefix}_{timestamp}.md"
        
        # Convert analysis to bytes
        file_content = analysis.encode('utf-8')
        
        # Upload file to SharePoint using TaskFileService
        try:
            file_service = TaskFileService()
            upload_result = file_service.upload_file(
                task=task,
                file_content=file_content,
                filename=filename,
                content_type='text/markdown',
                user=user
            )
            
            if not upload_result['success']:
                return JsonResponse({
                    'success': False,
                    'error': 'Failed to upload file to SharePoint',
                    'details': upload_result.get('error', '')
                }, status=500)
            
            logger.info(f"Support analysis saved as file: {filename}")
            
        except TaskFileServiceError as e:
            logger.error(f'File upload error: {e.message}')
            return JsonResponse({
                'success': False,
                'error': 'Failed to save analysis file',
                'details': e.details
            }, status=500)
        
        # Save to Weaviate as KnowledgeObject
        try:
            settings = Settings.objects.first()
            weaviate_service = WeaviateItemSyncService(settings)
            
            # Get collection
            collection = weaviate_service._client.collections.get(weaviate_service.COLLECTION_NAME)
            
            # Create metadata for KnowledgeObject
            import uuid
            analysis_id = str(uuid.uuid4())
            
            properties = {
                'type': 'SupportAnalysis',
                'title': f"Support-Analyse: {task.title}",
                'description': analysis,
                'section': '',
                'owner': user.username,
                'status': 'completed',
                'createdAt': datetime.now().isoformat(),
                'tags': [mode, 'support-analysis'],
                'url': f'/tasks/{task.id}/',
                'parent_id': str(task.id),
                'context_inherited': True,
            }
            
            # Add to Weaviate
            collection.data.insert(
                properties=properties,
                uuid=analysis_id
            )
            
            logger.info(f"Support analysis saved to Weaviate: {analysis_id}")
            
        except Exception as e:
            logger.warning(f'Failed to save to Weaviate: {str(e)}')
            # Don't fail the request if Weaviate fails, file was already saved
        
        return JsonResponse({
            'success': True,
            'message': 'Analysis saved successfully',
            'filename': filename,
            'sharepoint_url': upload_result.get('sharepoint_url', ''),
            'file_id': upload_result.get('file_id', '')
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Save support analysis error: {str(e)}')
        return JsonResponse({
            'error': 'An error occurred while saving analysis'
        }, status=500)


@csrf_exempt
@require_http_methods(['GET'])
def api_tags_network_data(request):
    """
    API endpoint to fetch network graph data for tags, items, and tasks.
    Returns nodes and edges for visualization.
    Only shows items and tasks owned by the current user, and only tags linked to those items/tasks.
    """
    try:
        from .models import Tag, Item, Task, User
        
        nodes = []
        edges = []
        
        # Get current user from session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        try:
            current_user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Filter items by current user ownership
        items = Item.objects.filter(created_by=current_user).prefetch_related('tags')
        
        # Add item nodes and edges to tags
        for item in items:
            # Truncate title if too long
            label = item.title[:25] + '...' if len(item.title) > 25 else item.title
            
            # Determine color based on status
            status_colors = {
                'new': '#6366f1',          # Indigo
                'spec_review': '#8b5cf6',  # Violet
                'working': '#f59e0b',      # Amber
                'ready': '#22c55e',        # Green
                'done': '#10b981',         # Emerald
                'rejected': '#ef4444',     # Red
            }
            
            nodes.append({
                'id': f'item-{item.id}',
                'label': label,
                'title': f'{item.title}\nStatus: {item.get_status_display()}',
                'group': 'item',
                'color': status_colors.get(item.status, '#3b82f6'),
                'shape': 'box',
                'size': 40,
                'font': {'size': 12, 'color': '#ffffff'},
                'url': f'/items/{item.id}/'
            })
            
            # Create edges from item to its tags
            for tag in item.tags.all():
                edges.append({
                    'from': f'tag-{tag.id}',
                    'to': f'item-{item.id}',
                    'color': {'color': tag.color, 'opacity': 0.5},
                    'width': 2
                })
        
        # Filter tasks by current user ownership
        tasks = Task.objects.filter(created_by=current_user).prefetch_related('tags', 'item')
        
        # Collect all tag IDs that are actually used by items or tasks
        used_tag_ids = set()
        for item in items:
            used_tag_ids.update(item.tags.values_list('id', flat=True))
        for task in tasks:
            used_tag_ids.update(task.tags.values_list('id', flat=True))
        
        # Add tag nodes only for tags that are linked to items or tasks
        tags = Tag.objects.filter(id__in=used_tag_ids)
        for tag in tags:
            nodes.append({
                'id': f'tag-{tag.id}',
                'label': tag.name[:20] + '...' if len(tag.name) > 20 else tag.name,
                'title': tag.name,  # Full name on hover
                'group': 'tag',
                'color': tag.color,
                'shape': 'dot',
                'size': 15,
                'font': {'size': 14, 'color': '#ffffff'}
            })
        
        # Add task nodes and edges to items/tags
        for task in tasks:
            # Truncate title if too long
            label = task.title[:20] + '...' if len(task.title) > 20 else task.title
            
            # Determine color based on status
            task_status_colors = {
                'new': '#6366f1',      # Indigo
                'working': '#f59e0b',  # Amber
                'review': '#8b5cf6',   # Violet
                'ready': '#22c55e',    # Green
                'done': '#10b981',     # Emerald
            }
            
            nodes.append({
                'id': f'task-{task.id}',
                'label': label,
                'title': f'{task.title}\nStatus: {task.get_status_display()}',
                'group': 'task',
                'color': task_status_colors.get(task.status, '#3b82f6'),
                'shape': 'diamond',
                'size': 15,
                'font': {'size': 10, 'color': '#ffffff'},
                'url': f'/tasks/{task.id}/'
            })
            
            # Create edge from task to its item
            if task.item:
                edges.append({
                    'from': f'item-{task.item.id}',
                    'to': f'task-{task.id}',
                    'color': {'color': '#9ca3af', 'opacity': 0.4},
                    'width': 1.5,
                    'dashes': True
                })
            
            # Create edges from task to its tags
            for tag in task.tags.all():
                edges.append({
                    'from': f'tag-{tag.id}',
                    'to': f'task-{task.id}',
                    'color': {'color': tag.color, 'opacity': 0.3},
                    'width': 1,
                    'dashes': True
                })
        
        return JsonResponse({
            'success': True,
            'nodes': nodes,
            'edges': edges
        })
    
    except Exception as e:
        logger.error(f'Error fetching tags network data: {str(e)}')
        return JsonResponse({'error': 'Failed to load network data'}, status=500)


@require_http_methods(["GET"])
def api_semantic_network(request, object_type, object_id):
    """
    Generate semantic network for an object (Item, Task, etc.)
    
    Query parameters:
        - depth: Network depth (1-3, default: 3)
        - threshold_1: Similarity threshold for level 1 (default: 0.8)
        - threshold_2: Similarity threshold for level 2 (default: 0.7)
        - threshold_3: Similarity threshold for level 3 (default: 0.6)
        - summaries: Generate AI summaries ('true'/'false', default: 'true')
        - include_hierarchy: Include parent-child relationships ('true'/'false', default: 'false')
    
    Returns:
        JSON response with:
            - nodes: List of graph nodes
            - edges: List of graph edges
            - levels: Level-by-level breakdown with summaries
            - source_id: ID of the source object
            - hierarchy: Parent and child relationships (if include_hierarchy=true)
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        logger.warning(f'Unauthenticated request to semantic network API')
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.semantic_network_service import SemanticNetworkService, SemanticNetworkServiceError
        
        # Parse query parameters
        depth = int(request.GET.get('depth', 3))
        generate_summaries = request.GET.get('summaries', 'true').lower() == 'true'
        include_hierarchy = request.GET.get('include_hierarchy', 'false').lower() == 'true'
        
        logger.info(f'Semantic network request: object_type={object_type}, object_id={object_id}, depth={depth}, summaries={generate_summaries}, hierarchy={include_hierarchy}')
        
        # Custom thresholds if provided
        thresholds = {}
        for level in [1, 2, 3]:
            threshold_key = f'threshold_{level}'
            if threshold_key in request.GET:
                try:
                    thresholds[level] = float(request.GET[threshold_key])
                except ValueError:
                    pass
        
        # Generate semantic network
        service = SemanticNetworkService()
        try:
            result = service.generate_network(
                object_type=object_type,
                object_id=str(object_id),
                depth=depth,
                user_id=str(user.id),
                thresholds=thresholds if thresholds else None,
                generate_summaries=generate_summaries,
                include_hierarchy=include_hierarchy
            )
            
            logger.info(f'Semantic network generated successfully: {len(result.get("nodes", []))} nodes, {len(result.get("edges", []))} edges')
            return JsonResponse(result)
            
        finally:
            service.close()
    
    except SemanticNetworkServiceError as e:
        logger.error(f'Semantic network service error for {object_type}/{object_id}: {str(e)}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Unexpected error generating semantic network for {object_type}/{object_id}: {str(e)}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': 'Failed to generate semantic network',
            'details': str(e)
        }, status=500)


def api_milestone_semantic_network(request, milestone_id):
    """
    Generate semantic network for a milestone
    
    Query parameters:
        - depth: Network depth (1-3, default: 3)
        - threshold_1: Similarity threshold for level 1 (default: 0.8)
        - threshold_2: Similarity threshold for level 2 (default: 0.7)
        - threshold_3: Similarity threshold for level 3 (default: 0.6)
        - summaries: Generate AI summaries ('true'/'false', default: 'true')
    
    Returns:
        JSON response with semantic network data
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        logger.warning(f'Unauthenticated request to milestone semantic network API')
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from main.models import Milestone
        from core.services.semantic_network_service import SemanticNetworkService, SemanticNetworkServiceError
        
        # Verify milestone exists
        try:
            milestone = Milestone.objects.get(id=milestone_id)
        except Milestone.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Milestone not found'
            }, status=404)
        
        # Parse query parameters
        depth = int(request.GET.get('depth', 3))
        generate_summaries = request.GET.get('summaries', 'true').lower() == 'true'
        
        logger.info(f'Milestone semantic network request: milestone_id={milestone_id}, depth={depth}, summaries={generate_summaries}')
        
        # Custom thresholds if provided
        thresholds = {}
        for level in [1, 2, 3]:
            threshold_key = f'threshold_{level}'
            if threshold_key in request.GET:
                try:
                    thresholds[level] = float(request.GET[threshold_key])
                except ValueError:
                    pass
        
        # Generate semantic network
        service = SemanticNetworkService()
        try:
            result = service.generate_network(
                object_type='milestone',
                object_id=str(milestone_id),
                depth=depth,
                user_id=str(user.id),
                thresholds=thresholds if thresholds else None,
                generate_summaries=generate_summaries,
                include_hierarchy=False  # Milestones don't have hierarchical relationships
            )
            
            logger.info(f'Milestone semantic network generated successfully: {len(result.get("nodes", []))} nodes, {len(result.get("edges", []))} edges')
            return JsonResponse(result)
            
        finally:
            service.close()
    
    except SemanticNetworkServiceError as e:
        logger.error(f'Semantic network service error for milestone/{milestone_id}: {str(e)}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Unexpected error generating semantic network for milestone/{milestone_id}: {str(e)}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': 'Failed to generate semantic network'
        }, status=500)


# File Upload API Endpoints

@csrf_exempt
@require_http_methods(["POST"])
def api_item_file_upload(request, item_id):
    """
    Upload one or more files for an item
    
    Supports both JSON API responses and htmx responses.
    For htmx requests, returns the updated file list after upload.
    
    POST data:
        - file: Single file upload (legacy)
        - files: Multiple file uploads
    
    Returns:
        - HTML partial with updated file list for htmx requests
        - JSON response with upload result for regular API requests
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from main.models import Item
        from core.services.item_file_service import ItemFileService, ItemFileServiceError
        from django.shortcuts import render
        
        # Get item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Item not found'})
            return JsonResponse({
                'success': False,
                'error': 'Item not found'
            }, status=404)
        
        # Check permission
        if user.role != 'admin' and item.created_by != user:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Permission denied'})
            return JsonResponse({
                'success': False,
                'error': 'You do not have permission to upload files for this item'
            }, status=403)
        
        # Get uploaded files - support both 'file' (single) and 'files' (multiple)
        uploaded_files = []
        if 'files' in request.FILES:
            uploaded_files = request.FILES.getlist('files')
        elif 'file' in request.FILES:
            uploaded_files = [request.FILES['file']]
        
        if not uploaded_files:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'No files provided'})
            return JsonResponse({
                'success': False,
                'error': 'No files provided'
            }, status=400)
        
        # Upload all files
        service = ItemFileService()
        upload_results = []
        errors = []
        
        for uploaded_file in uploaded_files:
            try:
                # Read file content
                file_content = uploaded_file.read()
                filename = uploaded_file.name
                content_type = uploaded_file.content_type or 'application/octet-stream'
                
                # Upload file
                result = service.upload_file(
                    item=item,
                    file_content=file_content,
                    filename=filename,
                    content_type=content_type,
                    user=user
                )
                
                upload_results.append(result)
                logger.info(f'File uploaded for item {item_id}: {filename}')
            except ItemFileServiceError as e:
                logger.error(f'File upload error for {uploaded_file.name}: {str(e)}')
                errors.append(f'{uploaded_file.name}: {e.message}')
            except Exception as e:
                logger.error(f'Error uploading file {uploaded_file.name}: {str(e)}')
                errors.append(f'{uploaded_file.name}: Failed to upload')
        
        # For htmx requests, return updated file list
        if request.headers.get('HX-Request'):
            # Fetch updated file list with pagination
            page = request.GET.get('page', 1)
            list_result = service.list_files(str(item_id), page=page, per_page=20)
            
            context = {
                'files': list_result.get('files', []),
                'page': list_result.get('page', 1),
                'total_pages': list_result.get('total_pages', 1),
                'total_count': list_result.get('total_count', 0),
                'item_id': item_id,
            }
            
            # Add error message if any
            if errors:
                context['error'] = f'Some files failed to upload: {"; ".join(errors)}'
            
            return render(request, 'main/items/_files_list.html', context)
        
        # For regular API requests, return JSON
        return JsonResponse({
            'success': True,
            'uploaded': len(upload_results),
            'failed': len(errors),
            'results': upload_results,
            'errors': errors
        })
    
    except ItemFileServiceError as e:
        logger.error(f'File upload error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error uploading files: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Failed to upload files'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to upload files'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_item_file_list(request, item_id):
    """
    List all files for an item with pagination
    
    Supports both JSON API responses and htmx HTML partial responses.
    
    Query parameters:
        - page: Page number (default: 1)
        - per_page: Items per page (default: 20)
    
    Returns:
        - HTML partial template for htmx requests
        - JSON response with list of files for regular API requests
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        # For htmx requests, return error HTML
        if request.headers.get('HX-Request'):
            from django.shortcuts import render
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Authentication required'})
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from main.models import Item
        from core.services.item_file_service import ItemFileService, ItemFileServiceError
        from django.shortcuts import render
        
        # Get item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Item not found'})
            return JsonResponse({
                'success': False,
                'error': 'Item not found'
            }, status=404)
        
        # Check permission
        if user.role != 'admin' and item.created_by != user:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Permission denied'})
            return JsonResponse({
                'success': False,
                'error': 'You do not have permission to view files for this item'
            }, status=403)
        
        # Get pagination parameters
        page = request.GET.get('page', 1)
        try:
            page = int(page)
        except (ValueError, TypeError):
            page = 1
        
        per_page = request.GET.get('per_page', 20)
        try:
            per_page = int(per_page)
        except (ValueError, TypeError):
            per_page = 20
        
        # List files with pagination
        service = ItemFileService()
        result = service.list_files(str(item_id), page=page, per_page=per_page)
        
        # For htmx requests, return HTML partial
        if request.headers.get('HX-Request'):
            context = {
                'files': result.get('files', []),
                'page': result.get('page', 1),
                'total_pages': result.get('total_pages', 1),
                'total_count': result.get('total_count', 0),
                'item_id': item_id,
            }
            return render(request, 'main/items/_files_list.html', context)
        
        # For regular API requests, return JSON
        return JsonResponse(result)
    
    except ItemFileServiceError as e:
        logger.error(f'File list error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error listing files: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Failed to list files'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to list files'
        }, status=500)


@csrf_exempt
@require_http_methods(["DELETE"])
def api_item_file_delete(request, file_id):
    """
    Delete a file
    
    Supports both JSON API responses and htmx responses.
    For htmx requests, triggers a file list refresh after deletion.
    
    Returns:
        - HTML partial with updated file list for htmx requests
        - JSON response with deletion result for regular API requests
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.item_file_service import ItemFileService, ItemFileServiceError
        from main.models import ItemFile
        from django.shortcuts import render
        
        # Get item_id before deleting the file (for htmx refresh)
        try:
            item_file = ItemFile.objects.get(id=file_id)
            item_id = str(item_file.item.id)
        except ItemFile.DoesNotExist:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'File not found'})
            return JsonResponse({
                'success': False,
                'error': 'File not found'
            }, status=404)
        
        # Delete file
        service = ItemFileService()
        result = service.delete_file(file_id, user)
        
        logger.info(f'File deleted: {file_id}')
        
        # For htmx requests, return updated file list
        if request.headers.get('HX-Request'):
            # Fetch updated file list
            list_result = service.list_files(item_id)
            # Return HTML partial with updated file list
            return render(request, 'main/items/_files_list.html', {'files': list_result.get('files', [])})
        
        # For regular API requests, return JSON
        return JsonResponse(result)
    
    except ItemFileServiceError as e:
        logger.error(f'File delete error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error deleting file: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Failed to delete file'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to delete file'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_item_file_download(request, file_id):
    """
    Get download URL for a file
    
    Returns:
        JSON response with download URL
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.item_file_service import ItemFileService, ItemFileServiceError
        
        # Get download URL
        service = ItemFileService()
        result = service.get_download_url(file_id, user)
        
        return JsonResponse(result)
    
    except ItemFileServiceError as e:
        logger.error(f'File download error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error getting download URL: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to get download URL'
        }, status=500)


# ==================== Zammad Integration API ====================

@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_zammad_test_connection(request):
    """
    Test connection to Zammad API
    POST /api/zammad/test-connection
    
    Returns:
        JSON response with connection status
    """
    try:
        from core.services.zammad_sync_service import ZammadSyncService, ZammadSyncServiceError
        
        service = ZammadSyncService()
        result = service.test_connection()
        
        return JsonResponse(result)
    
    except ZammadSyncServiceError as e:
        logger.error(f'Zammad connection test error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error testing Zammad connection: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to test connection'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_zammad_sync(request):
    """
    Manually trigger Zammad ticket synchronization
    POST /api/zammad/sync
    Body (optional): {"groups": ["Group1", "Group2"]}
    
    Returns:
        JSON response with sync results
    """
    try:
        from core.services.zammad_sync_service import ZammadSyncService, ZammadSyncServiceError
        
        # Parse optional group filter
        groups = None
        if request.body:
            try:
                data = json.loads(request.body)
                groups = data.get('groups')
            except json.JSONDecodeError:
                pass
        
        service = ZammadSyncService()
        
        if groups:
            # Fetch and sync specific groups
            tickets = service.fetch_open_tickets(groups)
            
            results = {
                'success': True,
                'total_tickets': len(tickets),
                'created': 0,
                'updated': 0,
                'failed': 0,
                'errors': []
            }
            
            for ticket in tickets:
                result = service.sync_ticket_to_task(ticket)
                if result.get('success'):
                    if result.get('action') == 'created':
                        results['created'] += 1
                    elif result.get('action') == 'updated':
                        results['updated'] += 1
                else:
                    results['failed'] += 1
                    results['errors'].append({
                        'ticket_id': result.get('ticket_id'),
                        'error': result.get('error')
                    })
        else:
            # Sync all configured groups
            results = service.sync_all_tickets()
        
        return JsonResponse(results)
    
    except ZammadSyncServiceError as e:
        logger.error(f'Zammad sync error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error syncing Zammad tickets: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to sync tickets'
        }, status=500)


@require_http_methods(["GET"])
@require_admin
def api_zammad_status(request):
    """
    Get Zammad synchronization status
    GET /api/zammad/status
    
    Returns:
        JSON response with sync status and statistics
    """
    try:
        from main.models import Task, Settings
        
        # Get settings
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({
                'success': False,
                'error': 'Settings not found'
            }, status=404)
        
        # Get statistics about Zammad-synced tasks
        zammad_tasks = Task.objects.filter(type='ticket').exclude(external_id='')
        
        total_tasks = zammad_tasks.count()
        new_tasks = zammad_tasks.filter(status='new').count()
        working_tasks = zammad_tasks.filter(status='working').count()
        done_tasks = zammad_tasks.filter(status='done').count()
        
        # Get last synced task
        last_synced = zammad_tasks.order_by('-updated_at').first()
        last_sync_time = last_synced.updated_at.isoformat() if last_synced else None
        
        return JsonResponse({
            'success': True,
            'enabled': settings.zammad_enabled,
            'api_url': settings.zammad_api_url,
            'configured_groups': [g.strip() for g in settings.zammad_groups.split(',') if g.strip()],
            'sync_interval_minutes': settings.zammad_sync_interval,
            'statistics': {
                'total_tasks': total_tasks,
                'new': new_tasks,
                'working': working_tasks,
                'done': done_tasks,
                'last_sync': last_sync_time
            }
        })
    
    except Exception as e:
        logger.error(f'Error getting Zammad status: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to get status'
        }, status=500)


# ==================== Task File Upload API ====================

@csrf_exempt
@require_http_methods(["POST"])
def api_task_file_upload(request, task_id):
    """
    Upload a file to a task
    
    Uploads file to SharePoint under: IdeaGraph/{item_title}/{task_uuid}/
    or IdeaGraph/Tasks/{task_uuid}/ for standalone tasks
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.task_file_service import TaskFileService, TaskFileServiceError
        from main.models import Task
        from django.shortcuts import render
        
        # Get task
        try:
            task = Task.objects.get(id=task_id)
        except Task.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Task not found'
            }, status=404)
        
        # Get uploaded file
        if 'file' not in request.FILES:
            return JsonResponse({
                'success': False,
                'error': 'No file provided'
            }, status=400)
        
        uploaded_file = request.FILES['file']
        
        # Read file content
        file_content = uploaded_file.read()
        filename = uploaded_file.name
        content_type = uploaded_file.content_type or 'application/octet-stream'
        
        # Upload file
        service = TaskFileService()
        result = service.upload_file(
            task=task,
            file_content=file_content,
            filename=filename,
            content_type=content_type,
            user=user
        )
        
        logger.info(f'File uploaded: {filename} for task {task_id}')
        
        # For htmx requests, return updated file list
        if request.headers.get('HX-Request'):
            # Fetch updated file list
            list_result = service.list_files(task_id)
            # Return HTML partial with updated file list
            return render(request, 'main/tasks/_files_list.html', {'files': list_result.get('files', [])})
        
        # For regular API requests, return JSON
        return JsonResponse(result)
    
    except TaskFileServiceError as e:
        logger.error(f'File upload error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error uploading file: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': 'Failed to upload file'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to upload file'
        }, status=500)


@require_http_methods(["GET"])
def api_task_file_list(request, task_id):
    """
    List files for a task
    
    Returns:
        JSON response with list of files or HTML partial for htmx
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.task_file_service import TaskFileService, TaskFileServiceError
        from django.shortcuts import render
        
        # List files
        service = TaskFileService()
        result = service.list_files(task_id)
        
        # For htmx requests, return HTML partial
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': result.get('files', [])})
        
        # For regular API requests, return JSON
        return JsonResponse(result)
    
    except TaskFileServiceError as e:
        logger.error(f'File list error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error listing files: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': 'Failed to list files'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to list files'
        }, status=500)


@csrf_exempt
@require_http_methods(["DELETE", "POST"])
def api_task_file_delete(request, file_id):
    """
    Delete a file
    
    Returns:
        JSON response with success status or HTML partial for htmx
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.task_file_service import TaskFileService, TaskFileServiceError
        from main.models import TaskFile
        from django.shortcuts import render
        
        # Get task_id before deleting the file (for htmx refresh)
        try:
            task_file = TaskFile.objects.get(id=file_id)
            task_id = str(task_file.task.id)
        except TaskFile.DoesNotExist:
            if request.headers.get('HX-Request'):
                return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': 'File not found'})
            return JsonResponse({
                'success': False,
                'error': 'File not found'
            }, status=404)
        
        # Delete file
        service = TaskFileService()
        result = service.delete_file(file_id, user)
        
        logger.info(f'File deleted: {file_id}')
        
        # For htmx requests, return updated file list
        if request.headers.get('HX-Request'):
            # Fetch updated file list
            list_result = service.list_files(task_id)
            # Return HTML partial with updated file list
            return render(request, 'main/tasks/_files_list.html', {'files': list_result.get('files', [])})
        
        # For regular API requests, return JSON
        return JsonResponse(result)
    
    except TaskFileServiceError as e:
        logger.error(f'File delete error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error deleting file: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': 'Failed to delete file'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to delete file'
        }, status=500)


@require_http_methods(["GET"])
def api_task_file_download(request, file_id):
    """
    Get download URL for a file
    
    Returns:
        JSON response with download URL
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.task_file_service import TaskFileService, TaskFileServiceError
        
        # Get download URL
        service = TaskFileService()
        result = service.get_download_url(file_id, user)
        
        return JsonResponse(result)
    
    except TaskFileServiceError as e:
        logger.error(f'File download error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error getting download URL: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to get download URL'
        }, status=500)


# ===== Milestone Knowledge Hub API Endpoints =====

@csrf_exempt
@require_http_methods(['POST'])
def api_milestone_context_add(request, milestone_id):
    """
    Add a context object to a milestone
    
    POST /api/milestones/<milestone_id>/context/add
    
    Supports two modes:
    1. JSON body (for note/email/transcript):
    {
        "type": "email|transcript|note",
        "title": "Context title",
        "content": "Text content",
        "source_id": "Optional source ID",
        "url": "Optional URL",
        "auto_analyze": true
    }
    
    2. Multipart form data (for file uploads):
    - file: uploaded file
    - auto_analyze: true/false (optional, default true)
    """
    from main.models import Milestone, MilestoneContextObject
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    from core.services.file_extraction_service import FileExtractionService
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Check if this is a file upload or JSON request
        if request.FILES.get('file'):
            # Handle file upload
            uploaded_file = request.FILES['file']
            auto_analyze = request.POST.get('auto_analyze', 'true').lower() == 'true'
            
            # Extract text from file
            file_service = FileExtractionService()
            if not file_service.can_extract_text(uploaded_file.name):
                return JsonResponse({
                    'success': False,
                    'error': f'Unsupported file type: {uploaded_file.name}'
                }, status=400)
            
            # Read file content
            file_content = uploaded_file.read()
            
            # Extract text
            extraction_result = file_service.extract_text(file_content, uploaded_file.name)
            
            if not extraction_result.get('success'):
                logger.error(f'Failed to extract text from file {uploaded_file.name}: {extraction_result.get("error", "")}')
                return JsonResponse({
                    'success': False,
                    'error': 'Failed to extract text from file'
                }, status=400)
            
            # Upload to SharePoint if configured
            sharepoint_file_id = ''
            sharepoint_url = ''
            try:
                from core.services.graph_service import GraphService, GraphServiceError
                graph = GraphService()
                
                # Create milestone-specific folder path
                # Format: Milestones/<ItemID>/<MilestoneID>
                folder_path = f"Milestones/{milestone.item.id}/{milestone.id}"
                
                # Upload file to SharePoint
                upload_result = graph.upload_sharepoint_file(
                    folder_path=folder_path,
                    file_name=uploaded_file.name,
                    content=file_content
                )
                
                if upload_result.get('success'):
                    sharepoint_file_id = upload_result.get('file_id', '')
                    # Construct SharePoint URL
                    if 'metadata' in upload_result and 'webUrl' in upload_result['metadata']:
                        sharepoint_url = upload_result['metadata']['webUrl']
                    
                    logger.info(f'File uploaded to SharePoint: {uploaded_file.name} (ID: {sharepoint_file_id})')
            except GraphServiceError as e:
                logger.warning(f'SharePoint upload failed, continuing without SharePoint storage: {str(e)}')
                # Continue without SharePoint - not a critical error
            except Exception as e:
                logger.warning(f'Unexpected error during SharePoint upload: {str(e)}')
                # Continue without SharePoint - not a critical error
            
            # Use extracted text as content
            context_type = 'file'
            title = uploaded_file.name
            content = extraction_result.get('text', '')
            source_id = sharepoint_file_id
            url = sharepoint_url
        else:
            # Handle JSON request
            data = json.loads(request.body)
            
            context_type = data.get('type', '')
            title = data.get('title', '').strip()
            content = data.get('content', '').strip()
            source_id = data.get('source_id', '').strip()
            url = data.get('url', '').strip()
            auto_analyze = data.get('auto_analyze', True)
        
        if not context_type or not title:
            return JsonResponse({
                'success': False,
                'error': 'Type and title are required'
            }, status=400)
        
        # Add context object using service
        service = MilestoneKnowledgeService()
        result = service.add_context_object(
            milestone=milestone,
            context_type=context_type,
            title=title,
            content=content,
            source_id=source_id,
            url=url,
            user=user,
            auto_analyze=auto_analyze
        )
        
        return JsonResponse(result)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Milestone knowledge service error: {str(e)}')
        return JsonResponse(e.to_dict(), status=400)
    
    except json.JSONDecodeError:
        return JsonResponse({
            'success': False,
            'error': 'Invalid JSON'
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error adding context object: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to add context object',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(['DELETE'])
def api_milestone_context_remove(request, context_id):
    """
    Remove a context object from a milestone
    
    DELETE /api/milestones/context/<context_id>/remove
    """
    from main.models import MilestoneContextObject
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        context_obj.delete()
        
        return JsonResponse({
            'success': True,
            'message': 'Context object removed successfully'
        })
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except Exception as e:
        logger.error(f'Error removing context object: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to remove context object'
        }, status=500)


@csrf_exempt
@require_http_methods(['POST'])
def api_milestone_context_summarize(request, milestone_id):
    """
    Generate AI summary for all context objects in a milestone
    
    POST /api/milestones/<milestone_id>/context/summarize
    """
    from main.models import Milestone
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Generate summary using service
        service = MilestoneKnowledgeService()
        result = service.generate_milestone_summary(milestone)
        
        return JsonResponse(result)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Milestone knowledge service error: {str(e)}')
        return JsonResponse(e.to_dict(), status=400)
    
    except Exception as e:
        logger.error(f'Error generating summary: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to generate summary',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_milestone_context_analyze(request, context_id):
    """
    Analyze a specific context object (summary + task derivation) or retrieve existing analysis
    
    GET /api/milestones/context/<context_id>/analyze - Get existing analysis
    POST /api/milestones/context/<context_id>/analyze - Run new analysis
    """
    from main.models import MilestoneContextObject
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # GET request: Return existing analysis data
        if request.method == 'GET':
            return JsonResponse({
                'success': True,
                'context': {
                    'id': str(context_obj.id),
                    'title': context_obj.title,
                    'type': context_obj.type,
                    'summary': context_obj.summary,
                    'derived_tasks': context_obj.derived_tasks,
                    'analyzed': context_obj.analyzed
                }
            })
        
        # POST request: Run analysis
        service = MilestoneKnowledgeService()
        result = service.analyze_context_object(context_obj)
        
        return JsonResponse(result)
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Milestone knowledge service error: {str(e)}')
        return JsonResponse(e.to_dict(), status=400)
    
    except Exception as e:
        logger.error(f'Error analyzing context object: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to analyze context object',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(['GET'])
def api_milestone_context_list(request, milestone_id):
    """
    Get list of context objects for a milestone
    
    GET /api/milestones/<milestone_id>/context
    """
    from main.models import Milestone
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Get all context objects
        context_objects = milestone.context_objects.all()
        
        result = {
            'success': True,
            'milestone_id': str(milestone.id),
            'milestone_name': milestone.name,
            'context_objects': []
        }
        
        for ctx in context_objects:
            result['context_objects'].append({
                'id': str(ctx.id),
                'type': ctx.type,
                'type_display': ctx.get_type_display(),
                'title': ctx.title,
                'url': ctx.url,
                'summary': ctx.summary,
                'analyzed': ctx.analyzed,
                'derived_tasks_count': len(ctx.derived_tasks) if ctx.derived_tasks else 0,
                'created_at': ctx.created_at.isoformat(),
                'uploaded_by': ctx.uploaded_by.username if ctx.uploaded_by else None
            })
        
        return JsonResponse(result)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except Exception as e:
        logger.error(f'Error listing context objects: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to list context objects'
        }, status=500)


@csrf_exempt
@require_http_methods(['POST'])
def api_milestone_context_create_tasks(request, context_id):
    """
    Create tasks from derived tasks in a context object
    
    POST /api/milestones/context/<context_id>/create-tasks
    """
    from main.models import MilestoneContextObject
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Create tasks using service
        service = MilestoneKnowledgeService()
        result = service.create_tasks_from_context(context_obj, milestone, user)
        
        return JsonResponse(result)
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Milestone knowledge service error: {str(e)}')
        return JsonResponse(e.to_dict(), status=400)
    
    except Exception as e:
        logger.error(f'Error creating tasks from context: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to create tasks',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(['GET'])
def api_milestone_context_download(request, context_id):
    """
    Download a file from SharePoint for a context object
    
    GET /api/milestones/context/<context_id>/download
    """
    from main.models import MilestoneContextObject
    from core.services.graph_service import GraphService, GraphServiceError
    from django.http import HttpResponse
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Check if file has SharePoint ID
        if not context_obj.source_id or context_obj.type != 'file':
            return JsonResponse({
                'success': False,
                'error': 'File not available for download'
            }, status=400)
        
        # Download from SharePoint
        try:
            graph = GraphService()
            download_result = graph.get_sharepoint_file(context_obj.source_id)
            
            if download_result.get('success'):
                file_content = download_result.get('content')
                file_name = download_result.get('file_name', context_obj.title)
                
                # Determine content type based on file extension
                import mimetypes
                content_type, _ = mimetypes.guess_type(file_name)
                if not content_type:
                    content_type = 'application/octet-stream'
                
                # Create HTTP response with file
                response = HttpResponse(file_content, content_type=content_type)
                response['Content-Disposition'] = f'attachment; filename="{file_name}"'
                return response
            else:
                return JsonResponse({
                    'success': False,
                    'error': 'Failed to download file from SharePoint'
                }, status=500)
                
        except GraphServiceError as e:
            logger.error(f'SharePoint download error: {str(e)}')
            return JsonResponse({
                'success': False,
                'error': 'Failed to download file'
            }, status=500)
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except Exception as e:
        logger.error(f'Error downloading file: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to download file',
            'details': 'An error occurred'
        }, status=500)


@require_http_methods(["POST"])
def api_milestone_optimize_summary(request, milestone_id):
    """
    Optimize milestone summary using AI (summary-enhancer-agent)
    
    POST /api/milestones/<milestone_id>/optimize-summary
    
    Returns optimized summary without saving (preview mode)
    """
    from main.models import Milestone
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Check if summary exists
        if not milestone.summary or not milestone.summary.strip():
            return JsonResponse({
                'success': False,
                'error': 'No summary available to optimize. Generate a summary first.'
            }, status=400)
        
        # Optimize summary
        service = MilestoneKnowledgeService()
        result = service.optimize_summary(milestone, user=user)
        
        return JsonResponse(result, status=200)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Milestone summary optimization error: {str(e)}')
        return JsonResponse(e.to_dict(), status=500)
    
    except Exception as e:
        logger.error(f'Error optimizing milestone summary: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to optimize summary',
            'details': str(e)
        }, status=500)


@csrf_exempt
def api_milestone_context_enhance_summary(request, context_id):
    """
    Enhance a context object's summary using summary-enhancer-agent
    
    POST /api/milestones/context/<context_id>/enhance-summary
    """
    from main.models import MilestoneContextObject
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Enhance summary
        service = MilestoneKnowledgeService()
        result = service.enhance_summary(context_obj)
        
        return JsonResponse(result)
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Summary enhancement error: {str(e)}')
        return JsonResponse(e.to_dict(), status=500)
    
    except Exception as e:
        logger.error(f'Error enhancing summary: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to enhance summary',
            'details': 'An error occurred'
        }, status=500)


@require_http_methods(["POST"])
def api_milestone_save_optimized_summary(request, milestone_id):
    """
    Save an optimized summary to the milestone
    
    POST /api/milestones/<milestone_id>/save-optimized-summary
    
    Request body:
    {
        "optimized_summary": "The optimized text to save",
        "agent_name": "summary-enhancer-agent",
        "model_name": "gpt-4"
    }
    """
    from main.models import Milestone
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    import json
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Invalid JSON in request body'
            }, status=400)
        
        optimized_summary = data.get('optimized_summary', '').strip()
        agent_name = data.get('agent_name', 'summary-enhancer-agent')
        model_name = data.get('model_name', 'gpt-4')
        
        if not optimized_summary:
            return JsonResponse({
                'success': False,
                'error': 'optimized_summary is required'
            }, status=400)
        
        # Save optimized summary
        service = MilestoneKnowledgeService()
        result = service.save_optimized_summary(
            milestone=milestone,
            optimized_summary=optimized_summary,
            user=user,
            agent_name=agent_name,
            model_name=model_name
        )
        
        return JsonResponse(result, status=200)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Error saving optimized summary: {str(e)}')
        return JsonResponse(e.to_dict(), status=500)
    
    except Exception as e:
        logger.error(f'Error saving optimized summary: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to save optimized summary',
            'details': str(e)
        }, status=500)


@csrf_exempt
def api_milestone_context_accept_results(request, context_id):
    """
    Accept and apply analysis results after user review/editing
    
    POST /api/milestones/context/<context_id>/accept-results
    Body: {
        "summary": "edited summary text",
        "derived_tasks": [{"title": "...", "description": "..."}]
    }
    """
    from main.models import MilestoneContextObject
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Invalid JSON in request body'
            }, status=400)
        
        summary = data.get('summary')
        derived_tasks = data.get('derived_tasks')
        
        # Accept results
        service = MilestoneKnowledgeService()
        result = service.accept_analysis_results(context_obj, summary, derived_tasks)
        
        return JsonResponse(result)
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Accept results error: {str(e)}')
        return JsonResponse(e.to_dict(), status=500)
    
    except Exception as e:
        logger.error(f'Error accepting results: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to accept results',
            'details': 'An error occurred'
        }, status=500)


@require_http_methods(["GET"])
def api_milestone_summary_history(request, milestone_id):
    """
    Get version history of milestone summaries
    
    GET /api/milestones/<milestone_id>/summary-history
    """
    from main.models import Milestone
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Get summary history
        service = MilestoneKnowledgeService()
        result = service.get_summary_history(milestone)
        
        return JsonResponse(result, status=200)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Error retrieving summary history: {str(e)}')
        return JsonResponse(e.to_dict(), status=500)
    
    except Exception as e:
        logger.error(f'Error retrieving summary history: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to retrieve summary history',
            'details': str(e)
        }, status=500)


@require_http_methods(["GET"])
def check_weaviate_status(request, object_type, object_id):
    """
    Check if an Item, Task, or File exists in Weaviate database.
    
    Args:
        object_type: 'item', 'task', 'item_file', or 'task_file'
        object_id: UUID of the object
    
    Returns:
        JSON with 'exists' boolean and optional 'data' if object exists
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'success': False, 'error': 'Unauthorized'}, status=401)
    
    try:
        from .models import Item, Task, ItemFile, TaskFile, Settings
        from core.services.weaviate_sync_service import WeaviateItemSyncService
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({
                'success': False,
                'error': 'Settings not configured'
            }, status=500)
        
        # Initialize Weaviate service
        weaviate_service = WeaviateItemSyncService(settings)
        
        # Get the collection
        collection = weaviate_service._client.collections.get('KnowledgeObject')
        
        # Check if object exists in Weaviate
        try:
            existing_obj = collection.query.fetch_object_by_id(str(object_id))
            exists = existing_obj is not None
            
            if exists:
                # Object exists, return its properties
                return JsonResponse({
                    'success': True,
                    'exists': True,
                    'data': {
                        'id': str(existing_obj.uuid),
                        'properties': existing_obj.properties
                    }
                })
            else:
                # Object doesn't exist
                return JsonResponse({
                    'success': True,
                    'exists': False
                })
        except Exception as e:
            logger.debug(f"Error checking object {object_id}: {str(e)}")
            return JsonResponse({
                'success': True,
                'exists': False
            })
        finally:
            weaviate_service.close()
            
    except Exception as e:
        logger.error(f'Error checking Weaviate status: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@require_http_methods(["POST"])
def add_to_weaviate(request, object_type, object_id):
    """
    Add an Item, Task, or File to Weaviate database.
    
    Args:
        object_type: 'item', 'task', 'item_file', or 'task_file'
        object_id: UUID of the object
    
    Returns:
        JSON with success status and message
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'success': False, 'error': 'Unauthorized'}, status=401)
    
    try:
        from .models import Item, Task, ItemFile, TaskFile, Settings
        from core.services.weaviate_sync_service import WeaviateItemSyncService, WeaviateItemSyncServiceError
        from core.services.weaviate_task_sync_service import WeaviateTaskSyncService, WeaviateTaskSyncServiceError
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({
                'success': False,
                'error': 'Settings not configured'
            }, status=500)
        
        # Handle different object types
        if object_type == 'item':
            try:
                item = Item.objects.get(id=object_id)
                weaviate_service = WeaviateItemSyncService(settings)
                result = weaviate_service.sync_create(item)
                weaviate_service.close()
                
                return JsonResponse({
                    'success': True,
                    'message': f'Item "{item.title}" added to Weaviate successfully'
                })
            except Item.DoesNotExist:
                return JsonResponse({
                    'success': False,
                    'error': 'Item not found'
                }, status=404)
            except WeaviateItemSyncServiceError as e:
                logger.error(f'Weaviate sync error: {str(e)}')
                return JsonResponse({
                    'success': False,
                    'error': str(e)
                }, status=500)
                
        elif object_type == 'task':
            try:
                task = Task.objects.get(id=object_id)
                weaviate_service = WeaviateTaskSyncService(settings)
                result = weaviate_service.sync_create(task)
                weaviate_service.close()
                
                return JsonResponse({
                    'success': True,
                    'message': f'Task "{task.title}" added to Weaviate successfully'
                })
            except Task.DoesNotExist:
                return JsonResponse({
                    'success': False,
                    'error': 'Task not found'
                }, status=404)
            except WeaviateTaskSyncServiceError as e:
                logger.error(f'Weaviate sync error: {str(e)}')
                return JsonResponse({
                    'success': False,
                    'error': str(e)
                }, status=500)
                
        elif object_type in ['item_file', 'task_file']:
            # For files, we need to sync them through the parent object's sync service
            try:
                if object_type == 'item_file':
                    file_obj = ItemFile.objects.get(id=object_id)
                    # Mark as synced and trigger parent item sync
                    file_obj.weaviate_synced = True
                    file_obj.save()
                    return JsonResponse({
                        'success': True,
                        'message': f'File "{file_obj.filename}" marked for Weaviate sync'
                    })
                else:
                    file_obj = TaskFile.objects.get(id=object_id)
                    # Mark as synced
                    file_obj.weaviate_synced = True
                    file_obj.save()
                    return JsonResponse({
                        'success': True,
                        'message': f'File "{file_obj.filename}" marked for Weaviate sync'
                    })
            except (ItemFile.DoesNotExist, TaskFile.DoesNotExist):
                return JsonResponse({
                    'success': False,
                    'error': 'File not found'
                }, status=404)
        else:
            return JsonResponse({
                'success': False,
                'error': f'Unsupported object type: {object_type}'
            }, status=400)
            
    except Exception as e:
        logger.error(f'Error adding to Weaviate: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@require_http_methods(["GET"])
def get_weaviate_dump(request, object_type, object_id):
    """
    Get a dump of an object from Weaviate database.
    
    Args:
        object_type: 'item', 'task', 'item_file', or 'task_file'
        object_id: UUID of the object
    
    Returns:
        JSON with object dump from Weaviate
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'success': False, 'error': 'Unauthorized'}, status=401)
    
    try:
        from .models import Settings
        from core.services.weaviate_sync_service import WeaviateItemSyncService
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({
                'success': False,
                'error': 'Settings not configured'
            }, status=500)
        
        # Initialize Weaviate service
        weaviate_service = WeaviateItemSyncService(settings)
        
        # Get the collection
        collection = weaviate_service._client.collections.get('KnowledgeObject')
        
        # Fetch object from Weaviate
        try:
            existing_obj = collection.query.fetch_object_by_id(str(object_id))
            
            if existing_obj is None:
                return JsonResponse({
                    'success': False,
                    'error': 'Object not found in Weaviate'
                }, status=404)
            
            # Format the dump
            dump_data = {
                'id': str(existing_obj.uuid),
                'properties': existing_obj.properties,
                'metadata': {
                    'created_at': existing_obj.properties.get('createdAt', 'N/A'),
                    'type': existing_obj.properties.get('type', 'Unknown')
                }
            }
            
            return JsonResponse({
                'success': True,
                'dump': dump_data
            })
            
        except Exception as e:
            logger.error(f"Error fetching object {object_id}: {str(e)}")
            return JsonResponse({
                'success': False,
                'error': f'Error fetching object: {str(e)}'
            }, status=500)
        finally:
            weaviate_service.close()
            
    except Exception as e:
        logger.error(f'Error getting Weaviate dump: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@require_http_methods(["GET"])
def api_get_items_for_move(request):
    """
    API endpoint to get all items for task move dropdown
    
    Returns:
    {
        "success": true,
        "items": [
            {
                "id": "uuid",
                "title": "Item Title"
            },
            ...
        ]
    }
    """
    from .models import Item, User
    
    try:
        # Get current user from session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        try:
            user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Get all items ordered by title
        items = Item.objects.all().order_by('title').values('id', 'title')
        
        return JsonResponse({
            'success': True,
            'items': list(items)
        })
        
    except Exception as e:
        logger.error(f'Error getting items for move: {str(e)}')
        return JsonResponse({
            'error': 'An error occurred while fetching items'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def create_teams_channel(request, item_id):
    """
    API endpoint to create a Teams channel for an item
    
    This endpoint creates a channel in the configured Teams workspace,
    posts a welcome message, and stores the channel ID in the item.
    
    Args:
        request: HTTP request
        item_id: UUID of the item
        
    Returns:
        JSON response with success status and channel details
    """
    logger.info(f'Creating Teams channel for item {item_id}')
    
    try:
        # Get current user from session
        user_id = request.session.get('user_id')
        if not user_id:
            logger.warning('Unauthorized attempt to create Teams channel')
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        try:
            user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            logger.warning(f'User {user_id} not found')
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Get the item
        from .models import Item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            logger.warning(f'Item {item_id} not found')
            return JsonResponse({'error': 'Item not found'}, status=404)
        
        # Check if channel already exists
        if item.channel_id:
            logger.warning(f'Item {item_id} already has a Teams channel: {item.channel_id}')
            return JsonResponse({
                'error': 'Channel already exists for this item',
                'channel_id': item.channel_id
            }, status=400)
        
        # Initialize Teams service
        try:
            teams_service = TeamsService()
        except TeamsServiceError as e:
            logger.error(f'Failed to initialize Teams service: {str(e)}')
            return JsonResponse({
                'error': 'Teams integration not configured properly. Please contact your administrator.'
            }, status=503)
        
        # Create the channel
        try:
            result = teams_service.create_channel_for_item(
                item_title=item.title,
                item_description=item.description
            )
            
            if result.get('success'):
                # Store channel ID in item
                item.channel_id = result['channel_id']
                item.save(update_fields=['channel_id'])
                
                logger.info(f'Successfully created Teams channel for item {item_id}: {result["channel_id"]}')
                
                return JsonResponse({
                    'success': True,
                    'message': f'Teams channel "{item.title}" created successfully',
                    'channel_id': result['channel_id'],
                    'web_url': result.get('web_url', ''),
                    'display_name': result.get('display_name', item.title)
                })
            else:
                logger.error(f'Failed to create Teams channel for item {item_id}')
                return JsonResponse({
                    'error': 'Failed to create Teams channel. Please try again later.'
                }, status=500)
                
        except TeamsServiceError as e:
            logger.error(f'Teams service error while creating channel: {str(e)}')
            return JsonResponse({
                'error': 'Failed to create Teams channel. Please try again later.'
            }, status=500)
        
    except Exception as e:
        logger.error(f'Unexpected error creating Teams channel for item {item_id}: {str(e)}')
        return JsonResponse({
            'error': 'An unexpected error occurred. Please try again later.'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def poll_teams_messages(request):
    """
    API endpoint to manually trigger Teams message polling
    
    POST /api/teams/poll
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    # Check if user is admin
    if user.role != 'admin':
        return JsonResponse({'error': 'Admin access required'}, status=403)
    
    try:
        from .models import Settings
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({'error': 'Settings not configured'}, status=500)
        
        if not settings.teams_enabled:
            return JsonResponse({'error': 'Teams integration is not enabled'}, status=400)
        
        # Import here to avoid circular dependency
        from core.services.teams_integration_service import TeamsIntegrationService
        
        # Initialize service and poll
        service = TeamsIntegrationService(settings=settings)
        result = service.poll_and_process()
        
        logger.info(f'Manual Teams poll triggered by user {user.username}')
        
        return JsonResponse({
            'success': True,
            'result': {
                'items_checked': result.get('items_checked', 0),
                'messages_found': result.get('messages_found', 0),
                'messages_processed': result.get('messages_processed', 0),
                'tasks_created': result.get('tasks_created', 0),
                'responses_posted': result.get('responses_posted', 0),
                'errors': len(result.get('errors', []))
            }
        })
        
    except Exception as e:
        logger.error(f'Error during manual Teams poll: {str(e)}')
        return JsonResponse({
            'error': 'Failed to poll Teams messages',
            'details': str(e)
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def teams_integration_status(request):
    """
    API endpoint to get Teams integration status
    
    GET /api/teams/status
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        from .models import Settings, Item, Task
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({'error': 'Settings not configured'}, status=500)
        
        # Get items with channels
        items_with_channels = Item.objects.filter(
            channel_id__isnull=False
        ).exclude(channel_id='').count()
        
        # Get tasks created from Teams messages
        tasks_from_teams = Task.objects.filter(
            message_id__isnull=False
        ).exclude(message_id='').count()
        
        return JsonResponse({
            'success': True,
            'status': {
                'enabled': settings.teams_enabled,
                'team_id': settings.teams_team_id if settings.teams_enabled else None,
                'poll_interval': settings.graph_poll_interval,
                'items_with_channels': items_with_channels,
                'tasks_from_teams': tasks_from_teams
            }
        })
        
    except Exception as e:
        logger.error(f'Error getting Teams integration status: {str(e)}')
        return JsonResponse({
            'error': 'Failed to get status',
            'details': str(e)
        }, status=500)


