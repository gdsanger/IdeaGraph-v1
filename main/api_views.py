"""
API views for user management and authentication.
"""
import json
import base64
import logging
from urllib.parse import urlparse
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.core.paginator import Paginator
from django.utils import timezone
from .models import User
from .auth_utils import generate_jwt_token, decode_jwt_token, validate_password
from core.services.graph_service import GraphService, GraphServiceError
from core.services.github_service import GitHubService, GitHubServiceError
from core.services.kigate_service import KiGateService, KiGateServiceError
from core.services.openai_service import OpenAIService, OpenAIServiceError
from core.services.weaviate_task_sync_service import WeaviateTaskSyncService, WeaviateTaskSyncServiceError

logger = logging.getLogger(__name__)


def clean_tag_name(tag_text):
    """
    Clean tag text by removing special characters, bullets, numbering, and quotes.
    
    This function ensures that tags generated by AI (e.g., from text-keyword-extractor-de)
    are properly cleaned before being stored in the database.
    
    Args:
        tag_text: Raw tag text from AI response
        
    Returns:
        Cleaned tag name or None if empty after cleaning
    """
    if not tag_text:
        return None
    
    # Remove common prefixes (numbers, bullets, brackets, quotes)
    # Format: "1. tag", "- tag", "* tag", "[tag]", '"tag"', etc.
    cleaned = tag_text.strip()
    
    # Remove leading characters: numbers, dots, dashes, asterisks, brackets, quotes, parentheses, bullets
    # This handles formats like: "1.", "2)", "-", "*", "[", '"', "(", "•", etc.
    while cleaned and cleaned[0] in '0123456789.-)(*["\' •':
        cleaned = cleaned[1:]
    
    # Remove trailing brackets, quotes, parentheses, asterisks, and whitespace
    while cleaned and cleaned[-1] in '])"\' *':
        cleaned = cleaned[:-1]
    
    # Final cleanup: strip any remaining whitespace
    cleaned = cleaned.strip()
    
    # Return None if the tag is empty after cleaning
    return cleaned if cleaned else None


def get_user_from_token(request):
    """Extract and validate user from JWT token in Authorization header"""
    auth_header = request.headers.get('Authorization', '')
    if not auth_header.startswith('Bearer '):
        return None
    
    token = auth_header[7:]
    payload = decode_jwt_token(token)
    if not payload:
        return None
    
    try:
        user = User.objects.get(id=payload['user_id'], is_active=True)
        return user
    except User.DoesNotExist:
        return None


def get_user_from_request(request):
    """
    Extract and validate user from either JWT token or session.
    This supports both API authentication (JWT) and web view authentication (session).
    """
    # First, try JWT authentication
    user = get_user_from_token(request)
    if user:
        return user
    
    # Fall back to session authentication
    user_id = request.session.get('user_id')
    if not user_id:
        return None
    
    try:
        user = User.objects.get(id=user_id, is_active=True)
        return user
    except User.DoesNotExist:
        return None


def require_admin(view_func):
    """Decorator to require admin role for API endpoints"""
    def wrapper(request, *args, **kwargs):
        user = get_user_from_token(request)
        if not user or user.role != 'admin':
            return JsonResponse({'error': 'Admin access required'}, status=403)
        request.user_obj = user
        return view_func(request, *args, **kwargs)
    return wrapper


@csrf_exempt
@require_http_methods(["POST"])
def api_login(request):
    """
    API endpoint for user authentication.
    POST /api/auth/login
    Body: {"username": "...", "password": "..."}
    """
    try:
        data = json.loads(request.body)
        username = data.get('username', '').strip()
        password = data.get('password', '')
        
        if not username or not password:
            return JsonResponse({'error': 'Username and password are required'}, status=400)
        
        # Find user
        try:
            user = User.objects.get(username=username)
        except User.DoesNotExist:
            return JsonResponse({'error': 'Invalid credentials'}, status=401)
        
        # Check if user is active
        if not user.is_active:
            return JsonResponse({'error': 'Account is inactive'}, status=401)
        
        # Verify password
        if not user.check_password(password):
            return JsonResponse({'error': 'Invalid credentials'}, status=401)
        
        # Update last login
        user.update_last_login()
        
        # Generate JWT token
        token = generate_jwt_token(user)
        
        return JsonResponse({
            'token': token,
            'user': {
                'id': str(user.id),
                'username': user.username,
                'email': user.email,
                'role': user.role,
                'is_active': user.is_active,
            }
        })
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Login error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during login'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_logout(request):
    """
    API endpoint for user logout.
    POST /api/auth/logout
    Note: Since JWT is stateless, this is mainly for client-side token removal
    """
    return JsonResponse({'message': 'Logged out successfully'})


@csrf_exempt
@require_http_methods(["GET"])
def api_user_list(request):
    """
    API endpoint to list all users (admin only).
    GET /api/users?page=1&per_page=10
    """
    user = get_user_from_token(request)
    if not user or user.role != 'admin':
        return JsonResponse({'error': 'Admin access required'}, status=403)
    
    try:
        page = int(request.GET.get('page', 1))
        per_page = int(request.GET.get('per_page', 10))
        per_page = min(per_page, 100)  # Max 100 per page
        
        users = User.objects.all().order_by('-created_at')
        paginator = Paginator(users, per_page)
        page_obj = paginator.get_page(page)
        
        users_data = [{
            'id': str(u.id),
            'username': u.username,
            'email': u.email,
            'role': u.role,
            'is_active': u.is_active,
            'created_at': u.created_at.isoformat(),
            'last_login': u.last_login.isoformat() if u.last_login else None,
            'ai_classification': u.ai_classification,
        } for u in page_obj]
        
        return JsonResponse({
            'users': users_data,
            'page': page,
            'per_page': per_page,
            'total': paginator.count,
            'total_pages': paginator.num_pages,
        })
        
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User list error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while retrieving users'}, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_user_detail(request, user_id):
    """
    API endpoint to get a specific user.
    GET /api/users/{user_id}
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    # Admin can view any user, regular users can only view themselves
    if user.role != 'admin' and str(user.id) != user_id:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        target_user = User.objects.get(id=user_id)
        return JsonResponse({
            'id': str(target_user.id),
            'username': target_user.username,
            'email': target_user.email,
            'role': target_user.role,
            'is_active': target_user.is_active,
            'created_at': target_user.created_at.isoformat(),
            'last_login': target_user.last_login.isoformat() if target_user.last_login else None,
            'ai_classification': target_user.ai_classification,
        })
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User detail error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while retrieving user details'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_user_create(request):
    """
    API endpoint to create a new user (admin only).
    POST /api/users
    Body: {"username": "...", "email": "...", "password": "...", "role": "...", "is_active": true}
    """
    try:
        data = json.loads(request.body)
        
        username = data.get('username', '').strip()
        email = data.get('email', '').strip()
        password = data.get('password', '')
        role = data.get('role', 'user')
        is_active = data.get('is_active', True)
        ai_classification = data.get('ai_classification', '')
        
        # Validation
        if not username:
            return JsonResponse({'error': 'Username is required'}, status=400)
        if not email:
            return JsonResponse({'error': 'Email is required'}, status=400)
        if not password:
            return JsonResponse({'error': 'Password is required'}, status=400)
        
        # Check if username or email already exists
        if User.objects.filter(username=username).exists():
            return JsonResponse({'error': 'Username already exists'}, status=400)
        if User.objects.filter(email=email).exists():
            return JsonResponse({'error': 'Email already exists'}, status=400)
        
        # Validate password
        is_valid, error_msg = validate_password(password)
        if not is_valid:
            return JsonResponse({'error': error_msg}, status=400)
        
        # Validate role
        valid_roles = ['admin', 'developer', 'user', 'viewer']
        if role not in valid_roles:
            return JsonResponse({'error': f'Invalid role. Must be one of: {", ".join(valid_roles)}'}, status=400)
        
        # Create user
        user = User(
            username=username,
            email=email,
            role=role,
            is_active=is_active,
            ai_classification=ai_classification
        )
        user.set_password(password)
        user.save()
        
        return JsonResponse({
            'id': str(user.id),
            'username': user.username,
            'email': user.email,
            'role': user.role,
            'is_active': user.is_active,
            'created_at': user.created_at.isoformat(),
            'ai_classification': user.ai_classification,
        }, status=201)
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User create error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while creating user'}, status=500)


@csrf_exempt
@require_http_methods(["PUT"])
def api_user_update(request, user_id):
    """
    API endpoint to update a user.
    PUT /api/users/{user_id}
    Body: {"email": "...", "role": "...", "is_active": true, "password": "..." (optional)}
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    # Admin can update any user, regular users can only update themselves (limited fields)
    if user.role != 'admin' and str(user.id) != user_id:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        target_user = User.objects.get(id=user_id)
        data = json.loads(request.body)
        
        # Regular users can only update their own email and password
        if user.role != 'admin':
            if 'email' in data:
                email = data['email'].strip()
                if email and email != target_user.email:
                    if User.objects.filter(email=email).exclude(id=user_id).exists():
                        return JsonResponse({'error': 'Email already exists'}, status=400)
                    target_user.email = email
            
            if 'password' in data and data['password']:
                password = data['password']
                is_valid, error_msg = validate_password(password)
                if not is_valid:
                    return JsonResponse({'error': error_msg}, status=400)
                target_user.set_password(password)
        else:
            # Admin can update all fields
            if 'email' in data:
                email = data['email'].strip()
                if email and email != target_user.email:
                    if User.objects.filter(email=email).exclude(id=user_id).exists():
                        return JsonResponse({'error': 'Email already exists'}, status=400)
                    target_user.email = email
            
            if 'role' in data:
                role = data['role']
                valid_roles = ['admin', 'developer', 'user', 'viewer']
                if role not in valid_roles:
                    return JsonResponse({'error': f'Invalid role. Must be one of: {", ".join(valid_roles)}'}, status=400)
                target_user.role = role
            
            if 'is_active' in data:
                target_user.is_active = bool(data['is_active'])
            
            if 'ai_classification' in data:
                target_user.ai_classification = data['ai_classification']
            
            if 'password' in data and data['password']:
                password = data['password']
                is_valid, error_msg = validate_password(password)
                if not is_valid:
                    return JsonResponse({'error': error_msg}, status=400)
                target_user.set_password(password)
        
        target_user.save()
        
        return JsonResponse({
            'id': str(target_user.id),
            'username': target_user.username,
            'email': target_user.email,
            'role': target_user.role,
            'is_active': target_user.is_active,
            'created_at': target_user.created_at.isoformat(),
            'last_login': target_user.last_login.isoformat() if target_user.last_login else None,
            'ai_classification': target_user.ai_classification,
        })
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User update error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while updating user'}, status=500)


@csrf_exempt
@require_http_methods(["DELETE"])
@require_admin
def api_user_delete(request, user_id):
    """
    API endpoint to delete a user (admin only).
    DELETE /api/users/{user_id}
    """
    try:
        target_user = User.objects.get(id=user_id)
        
        # Prevent self-deletion
        if str(request.user_obj.id) == user_id:
            return JsonResponse({'error': 'Cannot delete your own account'}, status=400)
        
        username = target_user.username
        target_user.delete()
        
        return JsonResponse({'message': f'User "{username}" deleted successfully'})
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User delete error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while deleting user'}, status=500)


# Graph API Endpoints

@csrf_exempt
@require_http_methods(["GET"])
@require_admin
def api_graph_sharepoint_files(request):
    """
    API endpoint to list SharePoint files (admin only).
    GET /api/graph/sharepoint/files?folder_path=Documents
    """
    try:
        folder_path = request.GET.get('folder_path', '')
        
        graph = GraphService()
        result = graph.get_sharepoint_file_list(folder_path)
        
        return JsonResponse(result)
        
    except GraphServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'Graph API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'SharePoint files list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing files',
            'details': str(e)
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_graph_sharepoint_upload(request):
    """
    API endpoint to upload a file to SharePoint (admin only).
    POST /api/graph/sharepoint/upload
    Body: {"folder_path": "Documents", "file_name": "test.txt", "content": "base64_encoded_content"}
    """
    try:
        data = json.loads(request.body)
        
        folder_path = data.get('folder_path', '')
        file_name = data.get('file_name')
        content_b64 = data.get('content')
        
        if not file_name:
            return JsonResponse({'error': 'file_name is required'}, status=400)
        
        if not content_b64:
            return JsonResponse({'error': 'content is required'}, status=400)
        
        # Decode base64 content
        try:
            content = base64.b64decode(content_b64)
        except Exception as e:
            return JsonResponse({'error': 'Invalid base64 content', 'details': str(e)}, status=400)
        
        graph = GraphService()
        result = graph.upload_sharepoint_file(folder_path, file_name, content)
        
        return JsonResponse(result, status=201)
        
    except GraphServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'Graph API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'SharePoint upload error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while uploading file',
            'details': str(e)
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_graph_mail_send(request):
    """
    API endpoint to send a test email via Graph API (admin only).
    POST /api/graph/mail/send
    Body: {"to": ["user@domain.com"], "subject": "Test", "body": "Test message"}
    """
    try:
        data = json.loads(request.body)
        
        to = data.get('to')
        subject = data.get('subject')
        body = data.get('body')
        
        if not to or not isinstance(to, list):
            return JsonResponse({'error': 'to must be a list of email addresses'}, status=400)
        
        if not subject:
            return JsonResponse({'error': 'subject is required'}, status=400)
        
        if not body:
            return JsonResponse({'error': 'body is required'}, status=400)
        
        graph = GraphService()
        result = graph.send_mail(to, subject, body)
        
        return JsonResponse(result)
        
    except GraphServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'Graph API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Mail send error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while sending email',
            'details': str(e)
        }, status=500)


# GitHub API Endpoints

def require_developer(view_func):
    """Decorator to require admin or developer role for API endpoints"""
    def wrapper(request, *args, **kwargs):
        user = get_user_from_token(request)
        if not user or user.role not in ['admin', 'developer']:
            return JsonResponse({'error': 'Admin or developer access required'}, status=403)
        request.user_obj = user
        return view_func(request, *args, **kwargs)
    return wrapper


@csrf_exempt
@require_http_methods(["GET"])
@require_developer
def api_github_repos(request):
    """
    API endpoint to list GitHub repositories (admin/developer only).
    GET /api/github/repos?owner=username&per_page=30&page=1
    """
    try:
        owner = request.GET.get('owner')
        per_page = int(request.GET.get('per_page', 30))
        page = int(request.GET.get('page', 1))
        
        github = GitHubService()
        result = github.get_repositories(owner=owner, per_page=per_page, page=page)
        
        return JsonResponse(result)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub repos list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing repositories'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_developer
def api_github_create_issue(request):
    """
    API endpoint to create a GitHub issue (admin/developer only).
    POST /api/github/create-issue
    Body: {"owner": "...", "repo": "...", "title": "...", "body": "...", "labels": ["..."], "assignees": ["..."]}
    """
    try:
        data = json.loads(request.body)
        
        title = data.get('title')
        body = data.get('body')
        owner = data.get('owner')
        repo = data.get('repo')
        labels = data.get('labels', [])
        assignees = data.get('assignees', [])
        
        if not title:
            return JsonResponse({'error': 'title is required'}, status=400)
        
        if not body:
            return JsonResponse({'error': 'body is required'}, status=400)
        
        github = GitHubService()
        result = github.create_issue(
            title=title,
            body=body,
            owner=owner,
            repo=repo,
            labels=labels,
            assignees=assignees
        )
        
        return JsonResponse(result, status=201)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub create issue error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while creating issue'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
@require_developer
def api_github_get_issue(request, owner, repo, issue_number):
    """
    API endpoint to get a specific GitHub issue (admin/developer only).
    GET /api/github/issue/{owner}/{repo}/{issue_number}
    """
    try:
        github = GitHubService()
        result = github.get_issue(
            issue_number=int(issue_number),
            owner=owner,
            repo=repo
        )
        
        return JsonResponse(result)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except ValueError:
        return JsonResponse({'error': 'Invalid issue number'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub get issue error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while retrieving issue'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
@require_developer
def api_github_list_issues(request, owner, repo):
    """
    API endpoint to list GitHub issues in a repository (admin/developer only).
    GET /api/github/issues/{owner}/{repo}?state=open&labels=bug,feature&per_page=30&page=1
    """
    try:
        state = request.GET.get('state', 'open')
        labels_str = request.GET.get('labels')
        labels = labels_str.split(',') if labels_str else None
        per_page = int(request.GET.get('per_page', 30))
        page = int(request.GET.get('page', 1))
        
        github = GitHubService()
        result = github.list_issues(
            owner=owner,
            repo=repo,
            state=state,
            labels=labels,
            per_page=per_page,
            page=page
        )
        
        return JsonResponse(result)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub list issues error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing issues'
        }, status=500)


# ==================== KiGate API Endpoints ====================

@csrf_exempt
@require_http_methods(["GET"])
def api_kigate_agents(request):
    """
    API endpoint to list all available KiGate agents.
    GET /api/kigate/agents
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        kigate = KiGateService()
        result = kigate.get_agents()
        
        return JsonResponse(result)
        
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate agents list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing agents'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_kigate_execute(request):
    """
    API endpoint to execute a KiGate agent.
    POST /api/kigate/execute
    Body: {
        "agent_name": "...",
        "provider": "...",
        "model": "...",
        "message": "...",
        "user_id": "...",
        "parameters": {...}  // optional
    }
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        data = json.loads(request.body)
        
        agent_name = data.get('agent_name')
        provider = data.get('provider')
        model = data.get('model')
        message = data.get('message')
        user_id = data.get('user_id')
        parameters = data.get('parameters')
        
        # Validate required fields
        if not agent_name:
            return JsonResponse({'error': 'agent_name is required'}, status=400)
        if not provider:
            return JsonResponse({'error': 'provider is required'}, status=400)
        if not model:
            return JsonResponse({'error': 'model is required'}, status=400)
        if not message:
            return JsonResponse({'error': 'message is required'}, status=400)
        if not user_id:
            return JsonResponse({'error': 'user_id is required'}, status=400)
        
        kigate = KiGateService()
        result = kigate.execute_agent(
            agent_name=agent_name,
            provider=provider,
            model=model,
            message=message,
            user_id=user_id,
            parameters=parameters
        )
        
        return JsonResponse(result, status=200)
        
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate execute error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while executing agent'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_kigate_agent_details(request, agent_name):
    """
    API endpoint to get details of a specific KiGate agent.
    GET /api/kigate/agent/{agent_name}
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        kigate = KiGateService()
        result = kigate.get_agent_details(agent_name=agent_name)
        
        return JsonResponse(result)
        
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate agent details error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while getting agent details'
        }, status=500)


# ==================== OpenAI API Endpoints ====================

@csrf_exempt
@require_http_methods(["POST"])
def api_openai_query(request):
    """
    API endpoint to execute an AI query via OpenAI API (with KiGate fallback).
    POST /api/openai/query
    Body: {
        "prompt": "...",
        "model": "..." (optional),
        "user_id": "..." (optional),
        "agent_name": "..." (optional - for KiGate routing),
        "temperature": 0.7 (optional),
        "max_tokens": 1000 (optional)
    }
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        data = json.loads(request.body)
        
        prompt = data.get('prompt')
        model = data.get('model')
        user_id = data.get('user_id', str(user.id))
        agent_name = data.get('agent_name')
        temperature = data.get('temperature', 0.7)
        max_tokens = data.get('max_tokens')
        
        # Validate required fields
        if not prompt:
            return JsonResponse({'error': 'prompt is required'}, status=400)
        
        openai = OpenAIService()
        
        # Use agent routing if agent_name is provided
        if agent_name:
            result = openai.query_with_agent(
                prompt=prompt,
                agent_name=agent_name,
                user_id=user_id,
                model=model
            )
        else:
            result = openai.query(
                prompt=prompt,
                model=model,
                user_id=user_id,
                temperature=temperature,
                max_tokens=max_tokens
            )
        
        return JsonResponse(result, status=200)
        
    except OpenAIServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI query error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while executing query'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_openai_models(request):
    """
    API endpoint to list available OpenAI models.
    GET /api/openai/models
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        openai = OpenAIService()
        result = openai.get_models()
        
        return JsonResponse(result)
        
    except OpenAIServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI models list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing models'
        }, status=500)


# ==================== Task API Endpoints ====================

@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_tasks(request, item_id=None):
    """
    API endpoint for task CRUD operations.
    GET /api/tasks/{item_id} - List tasks for an item
    POST /api/tasks/{item_id} - Create a new task
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Task, Tag
    
    if request.method == 'GET':
        # List tasks for an item
        if not item_id:
            return JsonResponse({'error': 'item_id is required'}, status=400)
        
        try:
            item = Item.objects.get(id=item_id)
            # Check ownership
            if user.role != 'admin' and item.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
            
            # Get tasks for this item - only show owned tasks
            tasks = item.tasks.filter(created_by=user).select_related('assigned_to', 'created_by').prefetch_related('tags')
            
            # Sort tasks by status priority
            status_order = {'new': 1, 'working': 2, 'review': 3, 'ready': 4, 'done': 5}
            tasks = sorted(tasks, key=lambda t: status_order.get(t.status, 99))
            
            tasks_data = [{
                'id': str(task.id),
                'title': task.title,
                'description': task.description,
                'status': task.status,
                'status_display': task.get_status_display(),
                'github_issue_id': task.github_issue_id,
                'github_issue_url': task.github_issue_url,
                'assigned_to': task.assigned_to.username if task.assigned_to else None,
                'created_at': task.created_at.isoformat(),
                'updated_at': task.updated_at.isoformat(),
                'tags': [{'id': str(tag.id), 'name': tag.name, 'color': tag.color} for tag in task.tags.all()],
            } for task in tasks]
            
            return JsonResponse({
                'success': True,
                'tasks': tasks_data
            })
            
        except Item.DoesNotExist:
            return JsonResponse({'error': 'Item not found'}, status=404)
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f'Task list error: {str(e)}')
            return JsonResponse({'error': 'An error occurred while listing tasks'}, status=500)
    
    elif request.method == 'POST':
        # Create a new task
        if not item_id:
            return JsonResponse({'error': 'item_id is required'}, status=400)
        
        try:
            data = json.loads(request.body)
            item = Item.objects.get(id=item_id)
            
            # Check ownership
            if user.role != 'admin' and item.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
            
            title = data.get('title', '').strip()
            description = data.get('description', '').strip()
            status = data.get('status', 'new')
            tag_ids = data.get('tags', [])
            
            if not title:
                return JsonResponse({'error': 'Title is required'}, status=400)
            
            # Create task
            task = Task(
                title=title,
                description=description,
                status=status,
                item=item,
                created_by=user,
                assigned_to=user
            )
            task.save()
            
            # Add tags
            if tag_ids:
                task.tags.set(tag_ids)
            
            # Sync with Weaviate
            try:
                from main.models import Settings
                settings = Settings.objects.first()
                if settings:
                    sync_service = WeaviateTaskSyncService(settings)
                    sync_service.sync_create(task)
            except WeaviateTaskSyncServiceError as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync failed for task {task.id}: {e.message}')
            except Exception as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync error for task {task.id}: {str(e)}')
            
            return JsonResponse({
                'success': True,
                'task': {
                    'id': str(task.id),
                    'title': task.title,
                    'description': task.description,
                    'status': task.status,
                    'status_display': task.get_status_display(),
                }
            }, status=201)
            
        except Item.DoesNotExist:
            return JsonResponse({'error': 'Item not found'}, status=404)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f'Task create error: {str(e)}')
            return JsonResponse({'error': 'An error occurred while creating task'}, status=500)


@csrf_exempt
@require_http_methods(["GET", "PUT", "DELETE"])
def api_task_detail(request, task_id):
    """
    API endpoint for task detail operations.
    GET /api/tasks/{task_id} - Get task details
    PUT /api/tasks/{task_id} - Update a task
    DELETE /api/tasks/{task_id} - Delete a task
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Check ownership
        if task.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        if request.method == 'GET':
            return JsonResponse({
                'success': True,
                'task': {
                    'id': str(task.id),
                    'title': task.title,
                    'description': task.description,
                    'status': task.status,
                    'status_display': task.get_status_display(),
                    'github_issue_id': task.github_issue_id,
                    'github_issue_url': task.github_issue_url,
                    'assigned_to': task.assigned_to.username if task.assigned_to else None,
                    'created_at': task.created_at.isoformat(),
                    'updated_at': task.updated_at.isoformat(),
                    'tags': [{'id': str(tag.id), 'name': tag.name, 'color': tag.color} for tag in task.tags.all()],
                }
            })
        
        elif request.method == 'PUT':
            data = json.loads(request.body)
            
            title = data.get('title', '').strip()
            description = data.get('description', '').strip()
            status = data.get('status', task.status)
            tag_ids = data.get('tags', [])
            
            if not title:
                return JsonResponse({'error': 'Title is required'}, status=400)
            
            previous_status = task.status
            task.title = title
            task.description = description
            task.status = status

            # Mark as done if status changed to done
            if status == 'done' and previous_status != 'done':
                task.save()
                task.mark_as_done()
            else:
                task.save()
            
            # Update tags
            if tag_ids:
                task.tags.set(tag_ids)
            else:
                task.tags.clear()
            
            # Sync with Weaviate
            try:
                from main.models import Settings
                settings = Settings.objects.first()
                if settings:
                    sync_service = WeaviateTaskSyncService(settings)
                    sync_service.sync_update(task)
            except WeaviateTaskSyncServiceError as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync failed for task {task.id}: {e.message}')
            except Exception as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync error for task {task.id}: {str(e)}')
            
            return JsonResponse({
                'success': True,
                'task': {
                    'id': str(task.id),
                    'title': task.title,
                    'description': task.description,
                    'status': task.status,
                    'status_display': task.get_status_display(),
                }
            })
        
        elif request.method == 'DELETE':
            task_id = str(task.id)
            task.delete()
            
            # Sync with Weaviate
            try:
                from main.models import Settings
                settings = Settings.objects.first()
                if settings:
                    sync_service = WeaviateTaskSyncService(settings)
                    sync_service.sync_delete(task_id)
            except WeaviateTaskSyncServiceError as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync failed for task {task_id}: {e.message}')
            except Exception as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync error for task {task_id}: {str(e)}')
            
            return JsonResponse({'success': True, 'message': 'Task deleted successfully'})
    
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Task operation error: {str(e)}')
        return JsonResponse({'error': 'An error occurred'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_generate_title(request, task_id):
    """
    API endpoint to generate task title from description using AI.
    POST /api/tasks/{task_id}/generate-title
    Body: {"description": "..."}
    
    Uses KiGate API with "text-to-title-generator" agent.
    Can work with unsaved tasks (task_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        # Task ID might be "new" for unsaved tasks
        if task_id != 'new':
            task = Task.objects.get(id=task_id)
            # Check ownership
            if task.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to generate title
        kigate = KiGateService()
        
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not title_result.get('success'):
            return JsonResponse({'error': title_result.get('error', 'Failed to generate title')}, status=500)
        
        generated_title = title_result.get('result', title_result.get('response', '')).strip()
        if generated_title:
            generated_title = generated_title[:255]  # Limit to field max length
        
        return JsonResponse({
            'success': True,
            'title': generated_title
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task title generation error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during title generation'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_extract_tags(request, task_id):
    """
    API endpoint to extract tags from task description using AI.
    POST /api/tasks/{task_id}/extract-tags
    Body: {"description": "..."}
    
    Uses KiGate API with "text-keyword-extractor-de" agent.
    Can work with unsaved tasks (task_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Tag, Settings
    
    try:
        # Task ID might be "new" for unsaved tasks
        if task_id != 'new':
            task = Task.objects.get(id=task_id)
            # Check ownership
            if task.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Use KiGate service to extract tags
        kigate = KiGateService()
        
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        if not keyword_result.get('success'):
            return JsonResponse({'error': keyword_result.get('error', 'Failed to extract tags')}, status=500)
        
        # Parse keywords and create/get tags
        tags_list = []
        keywords_response = keyword_result.get('result', keyword_result.get('response', ''))
        # Extract keywords from response (can be comma-separated or line-separated)
        keywords = []
        for line in keywords_response.split('\n'):
            for k in line.split(','):
                cleaned_keyword = clean_tag_name(k)
                if cleaned_keyword and cleaned_keyword not in keywords:
                    keywords.append(cleaned_keyword)
        
        # Get or create tags (avoid duplicates)
        for keyword in keywords[:max_tags]:
            # Check if tag already exists (case-insensitive to avoid duplicates)
            tag = Tag.objects.filter(name__iexact=keyword).first()
            if not tag:
                tag = Tag.objects.create(name=keyword)
            tags_list.append(tag.name)
        
        return JsonResponse({
            'success': True,
            'tags': tags_list
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task tag extraction error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during tag extraction'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_optimize_description(request, task_id):
    """
    API endpoint to optimize/normalize task description using AI.
    POST /api/tasks/{task_id}/optimize-description
    Body: {"description": "..."}
    
    Uses KiGate API with "text-optimization-agent" agent.
    Can work with unsaved tasks (task_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        # Task ID might be "new" for unsaved tasks
        if task_id != 'new':
            task = Task.objects.get(id=task_id)
            # Check ownership
            if task.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to optimize description
        kigate = KiGateService()
        
        text_result = kigate.execute_agent(
            agent_name='text-optimization-agent',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to optimize description')}, status=500)
        
        optimized_text = text_result.get('result', text_result.get('response', description))
        
        return JsonResponse({
            'success': True,
            'description': optimized_text
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task description optimization error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during description optimization'}, status=500)


@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_task_ai_enhance(request, task_id):
    """
    API endpoint to enhance task with AI.
    
    GET /api/tasks/{task_id}/ai-enhance
    Returns endpoint information and usage instructions.
    
    POST /api/tasks/{task_id}/ai-enhance
    Body: {"title": "...", "description": "..."}
    
    Process:
    1. Query Weaviate for similar tasks to provide context
    2. Normalize text using KiGate API with "github-issue-creation-agent" with context
    3. Generate title from normalized text using "text-to-title-generator"
    4. Extract 5 tags using "text-keyword-extractor-de" and replace existing tags
    """
    # Handle GET requests with endpoint information
    if request.method == 'GET':
        return JsonResponse({
            'error': 'Method not allowed',
            'message': 'This endpoint only accepts POST requests',
            'method': 'POST',
            'endpoint': f'/api/tasks/{task_id}/ai-enhance',
            'required_body': {
                'title': 'string (required)',
                'description': 'string (required)'
            },
            'description': 'Enhances task with AI by normalizing text, generating title, and extracting tags'
        }, status=405)
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Tag, Settings
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Check ownership
        if task.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        title = data.get('title', '').strip()
        description = data.get('description', '').strip()
        
        if not title or not description:
            return JsonResponse({'error': 'Title and description are required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Step 1: Query Weaviate for similar tasks to provide context
        context_text = ""
        try:
            weaviate_service = WeaviateTaskSyncService(settings)
            search_query = f"{title}\n{description}"
            similar_results = weaviate_service.search_similar(search_query, n_results=3)
            
            if similar_results.get('success') and similar_results.get('results'):
                context_items = []
                for idx, result in enumerate(similar_results['results'][:3], 1):
                    metadata = result.get('metadata', {})
                    doc = result.get('document', '')
                    context_items.append(f"Similar Task {idx}:\nTitle: {metadata.get('title', 'N/A')}\nDescription: {doc[:200]}...")
                
                context_text = "\n\n".join(context_items)
                logger.info(f"Found {len(similar_results['results'])} similar tasks for context")
        except Exception as e:
            logger.warning(f"Could not retrieve Weaviate context: {str(e)}")
            # Continue without context if Weaviate fails
        
        # Use KiGate service to enhance content
        kigate = KiGateService()
        
        # Step 2: Normalize text with context using github-issue-creation-agent
        normalization_message = f"Title: {title}\n\nDescription:\n{description}"
        if context_text:
            normalization_message += f"\n\n--- Context from similar tasks ---\n{context_text}\n--- End of context ---"
        
        text_result = kigate.execute_agent(
            agent_name='github-issue-creation-agent',
            provider='openai',
            model='gpt-4',
            message=normalization_message,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to normalize text')}, status=500)
        
        normalized_text = text_result.get('result', text_result.get('response', description))
        
        # Step 3: Generate title from normalized text using text-to-title-generator
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=normalized_text,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        enhanced_title = title
        if title_result.get('success'):
            generated_title = title_result.get('result', title_result.get('response', '')).strip()
            if generated_title:
                enhanced_title = generated_title[:255]  # Limit to field max length
        
        # Step 4: Extract keywords/tags using text-keyword-extractor-de
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=normalized_text,
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        # Parse keywords and create/get tags
        tags_list = []
        if keyword_result.get('success'):
            keywords_response = keyword_result.get('result', keyword_result.get('response', ''))
            # Extract keywords from response (can be comma-separated or line-separated)
            keywords = []
            for line in keywords_response.split('\n'):
                for k in line.split(','):
                    cleaned_keyword = clean_tag_name(k)
                    if cleaned_keyword and cleaned_keyword not in keywords:
                        keywords.append(cleaned_keyword)
            
            # Get or create tags (avoid duplicates)
            for keyword in keywords[:max_tags]:
                # Check if tag already exists (case-insensitive to avoid duplicates)
                tag = Tag.objects.filter(name__iexact=keyword).first()
                if not tag:
                    tag = Tag.objects.create(name=keyword)
                tags_list.append(tag.name)
        
        return JsonResponse({
            'success': True,
            'title': enhanced_title,
            'description': normalized_text,
            'tags': tags_list
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except WeaviateTaskSyncServiceError as e:
        logger.error(f'Weaviate error: {e.message}')
        return JsonResponse({'error': 'Weaviate service error', 'details': e.message}, status=500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task AI enhance error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during AI enhancement'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_generate_title(request, item_id):
    """
    API endpoint to generate item title from description using AI.
    POST /api/items/{item_id}/generate-title
    Body: {"description": "..."}
    
    Uses KiGate API with "text-to-title-generator" agent.
    Can work with unsaved items (item_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item
    
    try:
        # Item ID might be "new" for unsaved items
        if item_id != 'new':
            item = Item.objects.get(id=item_id)
            # Check ownership
            if item.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to generate title
        kigate = KiGateService()
        
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not title_result.get('success'):
            return JsonResponse({'error': title_result.get('error', 'Failed to generate title')}, status=500)
        
        generated_title = title_result.get('result', title_result.get('response', '')).strip()
        if generated_title:
            generated_title = generated_title[:255]  # Limit to field max length
        
        return JsonResponse({
            'success': True,
            'title': generated_title
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Item title generation error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during title generation'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_extract_tags(request, item_id):
    """
    API endpoint to extract tags from item description using AI.
    POST /api/items/{item_id}/extract-tags
    Body: {"description": "..."}
    
    Uses KiGate API with "text-keyword-extractor-de" agent.
    Can work with unsaved items (item_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Tag, Settings
    
    try:
        # Item ID might be "new" for unsaved items
        if item_id != 'new':
            item = Item.objects.get(id=item_id)
            # Check ownership
            if item.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Use KiGate service to extract tags
        kigate = KiGateService()
        
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        if not keyword_result.get('success'):
            return JsonResponse({'error': keyword_result.get('error', 'Failed to extract tags')}, status=500)
        
        # Parse keywords and create/get tags
        tags_list = []
        keywords_response = keyword_result.get('result', keyword_result.get('response', ''))
        # Extract keywords from response (can be comma-separated or line-separated)
        keywords = []
        for line in keywords_response.split('\n'):
            for k in line.split(','):
                cleaned_keyword = clean_tag_name(k)
                if cleaned_keyword and cleaned_keyword not in keywords:
                    keywords.append(cleaned_keyword)
        
        # Get or create tags (avoid duplicates)
        for keyword in keywords[:max_tags]:
            # Check if tag already exists (case-insensitive to avoid duplicates)
            tag = Tag.objects.filter(name__iexact=keyword).first()
            if not tag:
                tag = Tag.objects.create(name=keyword)
            tags_list.append(tag.name)
        
        return JsonResponse({
            'success': True,
            'tags': tags_list
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Item tag extraction error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during tag extraction'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_optimize_description(request, item_id):
    """
    API endpoint to optimize/normalize item description using AI.
    POST /api/items/{item_id}/optimize-description
    Body: {"description": "..."}
    
    Uses KiGate API with "text-optimization-agent" agent.
    Can work with unsaved items (item_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item
    
    try:
        # Item ID might be "new" for unsaved items
        if item_id != 'new':
            item = Item.objects.get(id=item_id)
            # Check ownership
            if item.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to optimize description
        kigate = KiGateService()
        
        text_result = kigate.execute_agent(
            agent_name='text-optimization-agent',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to optimize description')}, status=500)
        
        optimized_text = text_result.get('result', text_result.get('response', description))
        
        return JsonResponse({
            'success': True,
            'description': optimized_text
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Item description optimization error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during description optimization'}, status=500)


@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_item_ai_enhance(request, item_id):
    """
    API endpoint to enhance item with AI using KiGate agents.
    
    This function performs three main tasks:
    1. Text normalization (spelling, grammar, flow, comprehensibility) using 'text-optimization-agent'
    2. Title generation from normalized text using 'text-to-title-generator'
    3. Tag/keyword extraction from item context using 'text-keyword-extractor-de'
    
    The generated tags replace any existing tags on the item to avoid duplicates.
    Tags are properly attached to the Item entity via the ManyToMany relationship.
    
    GET /api/items/{item_id}/ai-enhance
    Returns endpoint information and usage instructions.
    
    POST /api/items/{item_id}/ai-enhance
    Body: {"title": "...", "description": "..."}
    
    Returns:
        JSON response with enhanced title, description, and tags list
    """
    # Handle GET requests with endpoint information
    if request.method == 'GET':
        return JsonResponse({
            'error': 'Method not allowed',
            'message': 'This endpoint only accepts POST requests',
            'method': 'POST',
            'endpoint': f'/api/items/{item_id}/ai-enhance',
            'required_body': {
                'title': 'string (required)',
                'description': 'string (required)'
            },
            'description': 'Enhances item with AI by normalizing text, generating title, and extracting tags'
        }, status=405)
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Tag, Settings
    
    try:
        item = Item.objects.get(id=item_id)
        
        # Check ownership
        if item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        title = data.get('title', '').strip()
        description = data.get('description', '').strip()
        
        if not title or not description:
            return JsonResponse({'error': 'Title and description are required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Use KiGate service to enhance content
        kigate = KiGateService()
        
        # Step 1: Optimize/normalize the text (spelling, grammar, flow, comprehensibility)
        text_result = kigate.execute_agent(
            agent_name='text-optimization-agent',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to enhance text')}, status=500)
        
        # Use 'result' field from KiGate API response, not 'response'
        enhanced_text = text_result.get('result', description)
        
        # Step 2: Generate a title from the normalized text
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=enhanced_text,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        # Use generated title if successful, otherwise keep original
        enhanced_title = title
        if title_result.get('success'):
            generated_title = title_result.get('result', '').strip()
            if generated_title:
                enhanced_title = generated_title[:255]  # Limit to field max length
        
        # Step 3: Extract keywords/tags from the item context
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=f"Title: {enhanced_title}\n\nDescription:\n{enhanced_text}",
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        # Parse keywords and manage tags
        tags_list = []
        if keyword_result.get('success'):
            keywords_text = keyword_result.get('result', '')
            # Extract keywords from response (handle comma-separated or newline-separated)
            keywords = []
            for k in keywords_text.replace('\n', ',').split(','):
                cleaned_keyword = clean_tag_name(k)
                if cleaned_keyword and cleaned_keyword not in keywords:
                    keywords.append(cleaned_keyword)
            
            # Clear existing tags to replace them with new ones
            item.tags.clear()
            
            # Get or create tags and attach to item (prevent duplicates)
            for keyword in keywords[:max_tags]:
                # Check if tag already exists (case-insensitive to avoid duplicates)
                tag = Tag.objects.filter(name__iexact=keyword).first()
                if not tag:
                    tag = Tag.objects.create(name=keyword)
                # Add tag to item (ManyToManyField handles duplicates automatically)
                item.tags.add(tag)
                tags_list.append(tag.name)
            
            # Mark that AI tags have been generated
            item.ai_tags_generated = True
        
        # Mark item as AI enhanced
        item.ai_enhanced = True
        item.save()
        
        return JsonResponse({
            'success': True,
            'title': enhanced_title,
            'description': enhanced_text,
            'tags': tags_list
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Item AI enhance error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during AI enhancement'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_build_tasks(request, item_id):
    """
    API endpoint to build/decompose tasks from an item using AI.
    POST /api/items/{item_id}/build-tasks
    Body: {"title": "...", "description": "..."}
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Task, Tag, Settings
    
    try:
        item = Item.objects.get(id=item_id)
        
        # Check ownership
        if item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        title = data.get('title', item.title).strip()
        description = data.get('description', item.description).strip()
        
        if not title or not description:
            return JsonResponse({'error': 'Title and description are required'}, status=400)
        
        # Use KiGate service to decompose item into tasks
        kigate = KiGateService()
        
        # Use task decomposition agent to generate tasks
        decompose_result = kigate.execute_agent(
            agent_name='task-decomposition-agent',
            provider='openai',
            model='gpt-4',
            message=f"Title: {title}\n\nDescription:\n{description}\n\nPlease decompose this into actionable tasks.",
            user_id=str(user.id),
            parameters={'max_tasks': 10}
        )
        
        if not decompose_result.get('success'):
            return JsonResponse({'error': decompose_result.get('error', 'Failed to decompose tasks')}, status=500)
        
        # Parse the response to extract tasks
        # Expected format: The agent should return tasks in a structured format
        response_text = decompose_result.get('response', '')
        
        # Parse tasks from response (assuming line-by-line format or JSON)
        tasks_created = []
        try:
            # Try to parse as JSON first
            import json as json_lib
            tasks_data = json_lib.loads(response_text)
            if isinstance(tasks_data, list):
                for task_data in tasks_data[:10]:  # Limit to 10 tasks
                    if isinstance(task_data, dict):
                        task_title = task_data.get('title', '')
                        task_desc = task_data.get('description', '')
                    else:
                        task_title = str(task_data)
                        task_desc = ''
                    
                    if task_title:
                        task = Task.objects.create(
                            title=task_title[:255],
                            description=task_desc,
                            status='new',
                            item=item,
                            created_by=user,
                            assigned_to=user,
                            ai_generated=True
                        )
                        tasks_created.append({
                            'id': str(task.id),
                            'title': task.title,
                            'description': task.description
                        })
        except (json_lib.JSONDecodeError, ValueError):
            # Fallback: Parse as line-separated tasks
            lines = response_text.split('\n')
            for line in lines[:10]:  # Limit to 10 tasks
                line = line.strip()
                # Remove common prefixes like "1.", "-", "*", etc.
                line = line.lstrip('0123456789.-* ')
                if line and len(line) > 3:
                    task = Task.objects.create(
                        title=line[:255],
                        description='',
                        status='new',
                        item=item,
                        created_by=user,
                        assigned_to=user,
                        ai_generated=True
                    )
                    tasks_created.append({
                        'id': str(task.id),
                        'title': task.title,
                        'description': task.description
                    })
        
        return JsonResponse({
            'success': True,
            'tasks': tasks_created,
            'count': len(tasks_created)
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Build tasks error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while building tasks'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_check_similarity(request, item_id):
    """
    API endpoint to check similarity for an item using Weaviate.
    POST /api/items/{item_id}/check-similarity
    Body: {"title": "...", "description": "..."}
    
    Returns only items with a relevance/similarity score of at least 0.8.
    The relevance score is calculated as: relevance = 1 - (distance / 2)
    where distance is the Weaviate cosine distance (0-2 range).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Settings
    from core.services.weaviate_sync_service import WeaviateItemSyncService, WeaviateItemSyncServiceError
    
    try:
        item = Item.objects.get(id=item_id)
        
        # Check ownership
        if item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        title = data.get('title', item.title).strip()
        description = data.get('description', item.description).strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use Weaviate to find similar items
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({'error': 'Settings not configured'}, status=500)
        
        weaviate_service = WeaviateItemSyncService(settings)
        
        # Search for similar items (request more results to ensure we have enough after filtering)
        search_text = f"{title}\n\n{description}"
        result = weaviate_service.search_similar(search_text, n_results=20)
        
        if not result.get('success'):
            return JsonResponse({'error': 'Failed to search for similar items'}, status=500)
        
        # Minimum relevance threshold (0.8 = 80% similarity)
        MIN_RELEVANCE = 0.8
        
        # Filter results by relevance and exclude current item
        similar_items = []
        for similar_item in result.get('results', []):
            # Skip the current item
            if similar_item.get('id') == str(item_id):
                continue
            
            # Convert Weaviate distance to relevance/similarity score
            # Weaviate uses cosine distance where 0 = identical, 2 = opposite
            # Relevance formula: 1 - (distance / 2)
            distance = similar_item.get('distance', 2.0)
            relevance = 1.0 - (distance / 2.0)
            
            # Only include items with relevance >= 0.8
            if relevance >= MIN_RELEVANCE:
                # Add relevance score to the item data
                similar_item['relevance'] = round(relevance, 3)
                similar_items.append(similar_item)
        
        return JsonResponse({
            'success': True,
            'similar_items': similar_items[:5]  # Limit to 5 most relevant results
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except WeaviateItemSyncServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Weaviate error: {e.message}')
        return JsonResponse(e.to_dict(), status=500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Check similarity error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while checking similarity'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_create_github_issue(request, task_id):
    """
    API endpoint to create GitHub issue from task.
    POST /api/tasks/{task_id}/create-github-issue
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Check ownership
        if task.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        # Check status
        if task.status != 'ready':
            return JsonResponse({'error': 'Task must be in Ready status to create GitHub issue'}, status=400)
        
        # Check if issue already exists
        if task.github_issue_id:
            return JsonResponse({'error': 'GitHub issue already exists for this task'}, status=400)
        
        # Get GitHub repository from item
        if not task.item or not task.item.github_repo:
            return JsonResponse({'error': 'No GitHub repository configured for this item'}, status=400)
        
        # Parse owner/repo from github_repo field
        repo_parts = task.item.github_repo.split('/')
        if len(repo_parts) != 2:
            return JsonResponse({'error': 'Invalid GitHub repository format. Expected: owner/repo'}, status=400)
        
        owner, repo = repo_parts
        
        # Prepare labels from tags
        labels = [tag.name for tag in task.tags.all()]
        
        # Create GitHub issue
        github = GitHubService()
        result = github.create_issue(
            title=task.title,
            body=task.description,
            owner=owner,
            repo=repo,
            labels=labels,
            assignees=[]
        )
        
        if result.get('success'):
            # Update task with GitHub issue info
            task.github_issue_id = result.get('issue_number')
            task.github_issue_url = result.get('url')
            task.github_synced_at = timezone.now()
            task.save()
            
            return JsonResponse({
                'success': True,
                'issue_number': task.github_issue_id,
                'issue_url': task.github_issue_url,
                'message': 'GitHub issue created successfully'
            })
        else:
            return JsonResponse({'error': result.get('error', 'Failed to create GitHub issue')}, status=500)
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except GitHubServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Create GitHub issue error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while creating GitHub issue'}, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_task_similar(request, task_id):
    """
    API endpoint to get similar tasks and GitHub issues.
    GET /api/tasks/{task_id}/similar
    
    Searches Weaviate for:
    1. Similar tasks from the Tasks collection
    2. Similar GitHub issues from the GitHubIssues collection
    
    Only returns items with similarity >= 0.8 (distance <= 0.2)
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    from core.services.github_issue_sync_service import GitHubIssueSyncService, GitHubIssueSyncServiceError
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Check ownership
        if task.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        similar_items = []
        
        # Use task description as query text
        query_text = task.description
        if not query_text or not query_text.strip():
            # If description is empty, return empty results
            return JsonResponse({
                'success': True,
                'similar_tasks': []
            })
        
        # Search for similar tasks in Weaviate
        try:
            task_sync_service = WeaviateTaskSyncService()
            task_results = task_sync_service.search_similar(query_text, n_results=10)
            
            if task_results.get('success') and task_results.get('results'):
                for result in task_results['results']:
                    # Convert distance to similarity (distance: 0=identical, 2=opposite)
                    # similarity = 1 - (distance / 2)
                    distance = result.get('distance', 2.0)
                    similarity = 1.0 - (distance / 2.0)
                    
                    # Filter by minimum similarity of 0.8
                    if similarity >= 0.8:
                        # Skip the current task itself
                        result_id = result.get('id')
                        if result_id and str(result_id) == str(task_id):
                            continue
                        
                        metadata = result.get('metadata', {})
                        similar_items.append({
                            'id': result_id,
                            'title': metadata.get('title', 'Untitled Task'),
                            'similarity': similarity,
                            'status': metadata.get('status', 'new'),
                            'status_display': dict(Task.STATUS_CHOICES).get(metadata.get('status', 'new'), 'New'),
                            'type': 'task',
                            'url': f'/tasks/{result_id}/'
                        })
        except WeaviateTaskSyncServiceError as e:
            logger.warning(f'Failed to search similar tasks: {str(e)}')
        except Exception as e:
            logger.warning(f'Unexpected error searching similar tasks: {str(e)}')
        
        # Search for similar GitHub issues in Weaviate
        try:
            github_sync_service = GitHubIssueSyncService()
            github_results = github_sync_service.search_similar(query_text, n_results=10)
            
            if github_results.get('success') and github_results.get('results'):
                for result in github_results['results']:
                    # Convert distance to similarity
                    distance = result.get('distance', 2.0)
                    similarity = 1.0 - (distance / 2.0)
                    
                    # Filter by minimum similarity of 0.8
                    if similarity >= 0.8:
                        metadata = result.get('metadata', {})
                        # GitHub issues have different metadata structure
                        issue_number = metadata.get('github_issue_id', 0)
                        issue_url = metadata.get('github_issue_url', '')
                        issue_state = metadata.get('github_issue_state', 'open')
                        issue_title = metadata.get('github_issue_title', 'Unbekanntes Problem')
                        
                        # Extract owner/repo from URL for formatted title
                        # URL format: https://github.com/owner/repo/issues/123
                        formatted_title = issue_title
                        owner = None
                        repo = None
                        
                        if issue_url:
                            try:
                                parsed_url = urlparse(issue_url)
                                # Validate that this is a GitHub URL
                                if parsed_url.hostname == 'github.com':
                                    url_parts = parsed_url.path.split('/')
                                    # Path format: /owner/repo/issues/123
                                    if len(url_parts) >= 5:
                                        owner = url_parts[1]
                                        repo = url_parts[2]
                                        formatted_title = f"{owner}/{repo}#{issue_number} {issue_title}"
                            except Exception as e:
                                logger.warning(f'Failed to parse GitHub URL: {str(e)}')
                        
                        # Fetch current status from GitHub API and update Weaviate
                        current_state = issue_state
                        try:
                            from core.services.github_service import GitHubService
                            github_service = GitHubService()
                            
                            # Only fetch from GitHub API if we have valid owner/repo
                            if owner and repo:
                                # Get current issue state from GitHub API
                                issue_result = github_service.get_issue(
                                    issue_number=issue_number,
                                    repo=repo,
                                    owner=owner
                                )
                                
                                if issue_result.get('success'):
                                    issue_data = issue_result.get('issue', {})
                                    current_state = issue_data.get('state', issue_state)
                                    
                                    # Update metadata in Weaviate if state changed
                                    if current_state != issue_state:
                                        metadata['github_issue_state'] = current_state
                                        chroma_id = result.get('id')
                                        
                                        # Update Weaviate with new state
                                        github_sync_service._collection.update(
                                            ids=[chroma_id],
                                            metadatas=[metadata]
                                        )
                                        logger.info(f'Updated GitHub issue #{issue_number} state in Weaviate: {issue_state} -> {current_state}')
                        except Exception as e:
                            logger.warning(f'Failed to fetch/update GitHub issue state: {str(e)}')
                        
                        similar_items.append({
                            'id': result.get('id'),
                            'title': formatted_title,
                            'similarity': similarity,
                            'status': 'done' if current_state == 'closed' else 'working',
                            'status_display': 'Closed' if current_state == 'closed' else 'Open',
                            'type': 'github_issue',
                            'issue_number': issue_number,
                            'url': issue_url
                        })
        except GitHubIssueSyncServiceError as e:
            logger.warning(f'Failed to search similar GitHub issues: {str(e)}')
        except Exception as e:
            logger.warning(f'Unexpected error searching similar GitHub issues: {str(e)}')
        
        # Sort by similarity (highest first)
        similar_items.sort(key=lambda x: x['similarity'], reverse=True)
        
        return JsonResponse({
            'success': True,
            'similar_tasks': similar_items
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except Exception as e:
        logger.error(f'Task similarity error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while finding similar tasks'}, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_task_overview(request):
    """
    API endpoint for global task overview with filtering and pagination.
    GET /api/tasks/overview?status=new&item=uuid&has_github=true&query=search&page=1&limit=20
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Item
    from django.db.models import Q, Count
    
    try:
        # Base query - show only user's tasks unless admin
        if user.role == 'admin':
            tasks = Task.objects.all()
        else:
            tasks = tasks = Task.objects.filter(created_by=user)
        
        # Apply filters
        status_filter = request.GET.get('status', '').strip()
        if status_filter:
            tasks = tasks.filter(status=status_filter)
        
        item_filter = request.GET.get('item', '').strip()
        if item_filter:
            tasks = tasks.filter(item_id=item_filter)
        
        has_github = request.GET.get('has_github', '').strip().lower()
        if has_github == 'true':
            tasks = tasks.filter(github_issue_id__isnull=False)
        elif has_github == 'false':
            tasks = tasks.filter(github_issue_id__isnull=True)
        
        query = request.GET.get('query', '').strip()
        if query:
            tasks = tasks.filter(
                Q(title__icontains=query) | 
                Q(description__icontains=query)
            )
        
        # Get status counts for badges (before pagination)
        status_counts = {}
        for status_key, status_label in Task.STATUS_CHOICES:
            if user.role == 'admin':
                count = Task.objects.filter(status=status_key).count()
            else:
                count = Task.objects.filter(status=status_key, created_by=user).count()
            status_counts[status_key] = {
                'label': status_label,
                'count': count
            }
        
        # Pagination
        page = int(request.GET.get('page', 1))
        limit = min(int(request.GET.get('limit', 20)), 100)  # Max 100 per page
        
        total_count = tasks.count()
        total_pages = (total_count + limit - 1) // limit if limit > 0 else 1
        
        start_index = (page - 1) * limit
        end_index = start_index + limit
        
        # Get tasks with related data
        tasks = tasks.select_related('item', 'assigned_to', 'created_by').prefetch_related('tags')
        tasks = tasks.order_by('-updated_at')[start_index:end_index]
        
        # Prepare response data
        tasks_data = []
        for task in tasks:
            tasks_data.append({
                'id': str(task.id),
                'title': task.title,
                'description': task.description,
                'status': task.status,
                'status_display': task.get_status_display(),
                'item': {
                    'id': str(task.item.id),
                    'title': task.item.title
                } if task.item else None,
                'github_issue_id': task.github_issue_id,
                'github_issue_url': task.github_issue_url,
                'github_synced_at': task.github_synced_at.isoformat() if task.github_synced_at else None,
                'assigned_to': {
                    'id': str(task.assigned_to.id),
                    'username': task.assigned_to.username
                } if task.assigned_to else None,
                'created_by': {
                    'id': str(task.created_by.id),
                    'username': task.created_by.username
                } if task.created_by else None,
                'created_at': task.created_at.isoformat(),
                'updated_at': task.updated_at.isoformat(),
                'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                'tags': [{'id': str(tag.id), 'name': tag.name, 'color': tag.color} for tag in task.tags.all()],
                'ai_enhanced': task.ai_enhanced,
                'ai_generated': task.ai_generated,
            })
        
        return JsonResponse({
            'success': True,
            'tasks': tasks_data,
            'status_counts': status_counts,
            'pagination': {
                'page': page,
                'limit': limit,
                'total_count': total_count,
                'total_pages': total_pages,
                'has_next': page < total_pages,
                'has_previous': page > 1
            }
        })
        
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Task overview error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while fetching task overview'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_send_item_email(request, item_id):
    """
    API endpoint to send item details via email.
    POST /api/items/{item_id}/send-email
    Body: {"email": "recipient@example.com"}
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item
    from .mail_utils import send_item_email
    
    try:
        # Get the item
        item = Item.objects.get(id=item_id)
        
        # Check ownership (only owner or admin can send)
        if user.role != 'admin' and item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        
        recipient_email = data.get('email', '').strip()
        
        if not recipient_email:
            return JsonResponse({'error': 'Email address is required'}, status=400)
        
        # Validate email format (basic validation)
        if '@' not in recipient_email or '.' not in recipient_email:
            return JsonResponse({'error': 'Invalid email address format'}, status=400)
        
        # Send the email
        success, message = send_item_email(item_id, recipient_email)
        
        if success:
            logger.info(f'Item {item.title} sent via email to {recipient_email} by user {user.username}')
            return JsonResponse({
                'success': True,
                'message': message
            })
        else:
            logger.error(f'Failed to send item {item.title} via email: {message}')
            return JsonResponse({
                'success': False,
                'error': message
            }, status=500)
            
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except Exception as e:
        logger.error(f'Send item email error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while sending email'}, status=500)


@require_http_methods(["POST"])
def api_task_bulk_delete(request):
    """
    API endpoint for bulk task deletion.
    POST /api/tasks/bulk-delete
    Body: {"task_ids": ["uuid1", "uuid2", ...]}
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Settings
    from django.core.exceptions import ValidationError
    
    try:
        data = json.loads(request.body)
        task_ids = data.get('task_ids', [])
        
        if not task_ids:
            return JsonResponse({'error': 'No task IDs provided'}, status=400)
        
        if not isinstance(task_ids, list):
            return JsonResponse({'error': 'task_ids must be a list'}, status=400)
        
        # Validate UUIDs
        valid_task_ids = []
        for task_id in task_ids:
            try:
                import uuid
                uuid.UUID(str(task_id))
                valid_task_ids.append(task_id)
            except (ValueError, AttributeError):
                # Skip invalid UUIDs
                pass
        
        if not valid_task_ids:
            return JsonResponse({'error': 'No valid task IDs provided'}, status=400)
        
        # Get all tasks that belong to the user
        tasks = Task.objects.filter(id__in=valid_task_ids, created_by=user)
        
        if not tasks.exists():
            return JsonResponse({'error': 'No tasks found or access denied'}, status=404)
        
        # Store task IDs for Weaviate sync before deletion
        deleted_task_ids = [str(task.id) for task in tasks]
        deleted_count = tasks.count()
        
        # Delete tasks
        tasks.delete()
        
        # Sync with Weaviate
        try:
            settings = Settings.objects.first()
            if settings:
                sync_service = WeaviateTaskSyncService(settings)
                for task_id in deleted_task_ids:
                    try:
                        sync_service.sync_delete(task_id)
                    except Exception as sync_error:
                        logger.warning(f'Weaviate sync failed for task {task_id}: {str(sync_error)}')
        except Exception as e:
            logger.warning(f'Weaviate sync error: {str(e)}')
        
        logger.info(f'User {user.username} deleted {deleted_count} task(s)')
        
        return JsonResponse({
            'success': True,
            'message': f'{deleted_count} task(s) deleted successfully',
            'deleted_count': deleted_count
        })
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Bulk delete error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while deleting tasks'}, status=500)


@csrf_exempt
@require_http_methods(['GET'])
def api_tags_network_data(request):
    """
    API endpoint to fetch network graph data for tags, items, and tasks.
    Returns nodes and edges for visualization.
    Only shows items and tasks owned by the current user, and only tags linked to those items/tasks.
    """
    try:
        from .models import Tag, Item, Task, User
        
        nodes = []
        edges = []
        
        # Get current user from session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        try:
            current_user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Filter items by current user ownership
        items = Item.objects.filter(created_by=current_user).prefetch_related('tags')
        
        # Add item nodes and edges to tags
        for item in items:
            # Truncate title if too long
            label = item.title[:25] + '...' if len(item.title) > 25 else item.title
            
            # Determine color based on status
            status_colors = {
                'new': '#6366f1',          # Indigo
                'spec_review': '#8b5cf6',  # Violet
                'working': '#f59e0b',      # Amber
                'ready': '#22c55e',        # Green
                'done': '#10b981',         # Emerald
                'rejected': '#ef4444',     # Red
            }
            
            nodes.append({
                'id': f'item-{item.id}',
                'label': label,
                'title': f'{item.title}\nStatus: {item.get_status_display()}',
                'group': 'item',
                'color': status_colors.get(item.status, '#3b82f6'),
                'shape': 'box',
                'size': 40,
                'font': {'size': 12, 'color': '#ffffff'},
                'url': f'/items/{item.id}/'
            })
            
            # Create edges from item to its tags
            for tag in item.tags.all():
                edges.append({
                    'from': f'tag-{tag.id}',
                    'to': f'item-{item.id}',
                    'color': {'color': tag.color, 'opacity': 0.5},
                    'width': 2
                })
        
        # Filter tasks by current user ownership
        tasks = Task.objects.filter(created_by=current_user).prefetch_related('tags', 'item')
        
        # Collect all tag IDs that are actually used by items or tasks
        used_tag_ids = set()
        for item in items:
            used_tag_ids.update(item.tags.values_list('id', flat=True))
        for task in tasks:
            used_tag_ids.update(task.tags.values_list('id', flat=True))
        
        # Add tag nodes only for tags that are linked to items or tasks
        tags = Tag.objects.filter(id__in=used_tag_ids)
        for tag in tags:
            nodes.append({
                'id': f'tag-{tag.id}',
                'label': tag.name[:20] + '...' if len(tag.name) > 20 else tag.name,
                'title': tag.name,  # Full name on hover
                'group': 'tag',
                'color': tag.color,
                'shape': 'dot',
                'size': 15,
                'font': {'size': 14, 'color': '#ffffff'}
            })
        
        # Add task nodes and edges to items/tags
        for task in tasks:
            # Truncate title if too long
            label = task.title[:20] + '...' if len(task.title) > 20 else task.title
            
            # Determine color based on status
            task_status_colors = {
                'new': '#6366f1',      # Indigo
                'working': '#f59e0b',  # Amber
                'review': '#8b5cf6',   # Violet
                'ready': '#22c55e',    # Green
                'done': '#10b981',     # Emerald
            }
            
            nodes.append({
                'id': f'task-{task.id}',
                'label': label,
                'title': f'{task.title}\nStatus: {task.get_status_display()}',
                'group': 'task',
                'color': task_status_colors.get(task.status, '#3b82f6'),
                'shape': 'diamond',
                'size': 15,
                'font': {'size': 10, 'color': '#ffffff'},
                'url': f'/tasks/{task.id}/'
            })
            
            # Create edge from task to its item
            if task.item:
                edges.append({
                    'from': f'item-{task.item.id}',
                    'to': f'task-{task.id}',
                    'color': {'color': '#9ca3af', 'opacity': 0.4},
                    'width': 1.5,
                    'dashes': True
                })
            
            # Create edges from task to its tags
            for tag in task.tags.all():
                edges.append({
                    'from': f'tag-{tag.id}',
                    'to': f'task-{task.id}',
                    'color': {'color': tag.color, 'opacity': 0.3},
                    'width': 1,
                    'dashes': True
                })
        
        return JsonResponse({
            'success': True,
            'nodes': nodes,
            'edges': edges
        })
    
    except Exception as e:
        logger.error(f'Error fetching tags network data: {str(e)}')
        return JsonResponse({'error': 'Failed to load network data'}, status=500)


