"""
API views for user management and authentication.
"""
import json
import base64
import logging
import traceback
from urllib.parse import urlparse
from django.http import JsonResponse
from django.shortcuts import get_object_or_404
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.core.paginator import Paginator
from django.utils import timezone
from .models import User
from .auth_utils import generate_jwt_token, decode_jwt_token, validate_password
from core.services.graph_service import GraphService, GraphServiceError
from core.services.github_service import GitHubService, GitHubServiceError
from core.services.kigate_service import KiGateService, KiGateServiceError
from core.services.openai_service import OpenAIService, OpenAIServiceError
from core.services.weaviate_task_sync_service import WeaviateTaskSyncService, WeaviateTaskSyncServiceError
from core.services.support_advisor_service import SupportAdvisorService, SupportAdvisorServiceError
from core.services.task_file_service import TaskFileService, TaskFileServiceError
from core.services.teams_service import TeamsService, TeamsServiceError

logger = logging.getLogger(__name__)


def clean_tag_name(tag_text):
    """
    Clean tag text by removing special characters, bullets, numbering, and quotes.
    
    This function ensures that tags generated by AI (e.g., from text-keyword-extractor-de)
    are properly cleaned before being stored in the database.
    
    Args:
        tag_text: Raw tag text from AI response
        
    Returns:
        Cleaned tag name or None if empty after cleaning
    """
    if not tag_text:
        return None
    
    # Remove common prefixes (numbers, bullets, brackets, quotes)
    # Format: "1. tag", "- tag", "* tag", "[tag]", '"tag"', etc.
    cleaned = tag_text.strip()
    
    # Remove leading characters: numbers, dots, dashes, asterisks, brackets, quotes, parentheses, bullets
    # This handles formats like: "1.", "2)", "-", "*", "[", '"', "(", "•", etc.
    while cleaned and cleaned[0] in '0123456789.-)(*["\' •':
        cleaned = cleaned[1:]
    
    # Remove trailing brackets, quotes, parentheses, asterisks, and whitespace
    while cleaned and cleaned[-1] in '])"\' *':
        cleaned = cleaned[:-1]
    
    # Final cleanup: strip any remaining whitespace
    cleaned = cleaned.strip()
    
    # Return None if the tag is empty after cleaning
    return cleaned if cleaned else None


def strip_quotes_from_title(title_text):
    """
    Remove quotation marks from the beginning and end of AI-generated titles.
    
    The text-to-title-generator agent often returns titles wrapped in quotation marks.
    This function removes both single and double quotation marks from the start and end
    of the title string.
    
    Args:
        title_text: Raw title text from AI response
        
    Returns:
        Title without surrounding quotation marks
    """
    if not title_text:
        return title_text
    
    cleaned = title_text.strip()
    
    # Remove leading and trailing quotation marks (both single and double)
    if cleaned and cleaned[0] in '"\'':
        cleaned = cleaned[1:]
    if cleaned and cleaned[-1] in '"\'':
        cleaned = cleaned[:-1]
    
    # Final cleanup: strip any whitespace that was inside the quotes
    return cleaned.strip()


def get_user_from_token(request):
    """Extract and validate user from JWT token in Authorization header"""
    auth_header = request.headers.get('Authorization', '')
    if not auth_header.startswith('Bearer '):
        return None
    
    token = auth_header[7:]
    payload = decode_jwt_token(token)
    if not payload:
        return None
    
    try:
        user = User.objects.get(id=payload['user_id'], is_active=True)
        return user
    except User.DoesNotExist:
        return None


def get_user_from_request(request):
    """
    Extract and validate user from either JWT token or session.
    This supports both API authentication (JWT) and web view authentication (session).
    """
    # First, try JWT authentication
    user = get_user_from_token(request)
    if user:
        return user
    
    # Fall back to session authentication
    user_id = request.session.get('user_id')
    if not user_id:
        return None
    
    try:
        user = User.objects.get(id=user_id, is_active=True)
        return user
    except User.DoesNotExist:
        return None


def require_admin(view_func):
    """Decorator to require admin role for API endpoints"""
    def wrapper(request, *args, **kwargs):
        user = get_user_from_request(request)  # Check both token and session
        if not user or user.role != 'admin':
            return JsonResponse({'error': 'Admin access required'}, status=403)
        request.user_obj = user
        return view_func(request, *args, **kwargs)
    return wrapper


@csrf_exempt
@require_http_methods(["POST"])
def api_login(request):
    """
    API endpoint for user authentication.
    POST /api/auth/login
    Body: {"username": "...", "password": "..."}
    """
    try:
        data = json.loads(request.body)
        username = data.get('username', '').strip()
        password = data.get('password', '')
        
        if not username or not password:
            return JsonResponse({'error': 'Username and password are required'}, status=400)
        
        # Find user
        try:
            user = User.objects.get(username=username)
        except User.DoesNotExist:
            return JsonResponse({'error': 'Invalid credentials'}, status=401)
        
        # Check if user is active
        if not user.is_active:
            return JsonResponse({'error': 'Account is inactive'}, status=401)
        
        # Verify password
        if not user.check_password(password):
            return JsonResponse({'error': 'Invalid credentials'}, status=401)
        
        # Update last login
        user.update_last_login()
        
        # Generate JWT token
        token = generate_jwt_token(user)
        
        return JsonResponse({
            'token': token,
            'user': {
                'id': str(user.id),
                'username': user.username,
                'email': user.email,
                'role': user.role,
                'is_active': user.is_active,
            }
        })
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Login error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during login'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_logout(request):
    """
    API endpoint for user logout.
    POST /api/auth/logout
    Note: Since JWT is stateless, this is mainly for client-side token removal
    """
    return JsonResponse({'message': 'Logged out successfully'})


@csrf_exempt
@require_http_methods(["GET"])
def api_user_list(request):
    """
    API endpoint to list all active users.
    GET /api/users?page=1&per_page=10
    
    Authentication: Supports both JWT token and session-based authentication.
    Access: All authenticated users can access this endpoint (needed for requester dropdown).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        page = int(request.GET.get('page', 1))
        per_page = int(request.GET.get('per_page', 10))
        per_page = min(per_page, 100)  # Max 100 per page
        
        # Only return active users, ordered by username for better UX in dropdowns
        users = User.objects.filter(is_active=True).order_by('username')
        paginator = Paginator(users, per_page)
        page_obj = paginator.get_page(page)
        
        users_data = [{
            'id': str(u.id),
            'username': u.username,
            'email': u.email,
            'role': u.role,
            'is_active': u.is_active,
            'created_at': u.created_at.isoformat(),
            'last_login': u.last_login.isoformat() if u.last_login else None,
            'ai_classification': u.ai_classification,
        } for u in page_obj]
        
        return JsonResponse({
            'users': users_data,
            'page': page,
            'per_page': per_page,
            'total': paginator.count,
            'total_pages': paginator.num_pages,
        })
        
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User list error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while retrieving users'}, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_user_detail(request, user_id):
    """
    API endpoint to get a specific user.
    GET /api/users/{user_id}
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    # Admin can view any user, regular users can only view themselves
    if user.role != 'admin' and str(user.id) != user_id:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        target_user = User.objects.get(id=user_id)
        return JsonResponse({
            'id': str(target_user.id),
            'username': target_user.username,
            'email': target_user.email,
            'role': target_user.role,
            'is_active': target_user.is_active,
            'created_at': target_user.created_at.isoformat(),
            'last_login': target_user.last_login.isoformat() if target_user.last_login else None,
            'ai_classification': target_user.ai_classification,
        })
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User detail error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while retrieving user details'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_user_create(request):
    """
    API endpoint to create a new user (admin only).
    POST /api/users
    Body: {"username": "...", "email": "...", "password": "...", "role": "...", "is_active": true}
    """
    try:
        data = json.loads(request.body)
        
        username = data.get('username', '').strip()
        email = data.get('email', '').strip()
        password = data.get('password', '')
        role = data.get('role', 'user')
        is_active = data.get('is_active', True)
        ai_classification = data.get('ai_classification', '')
        
        # Validation
        if not username:
            return JsonResponse({'error': 'Username is required'}, status=400)
        if not email:
            return JsonResponse({'error': 'Email is required'}, status=400)
        if not password:
            return JsonResponse({'error': 'Password is required'}, status=400)
        
        # Check if username or email already exists
        if User.objects.filter(username=username).exists():
            return JsonResponse({'error': 'Username already exists'}, status=400)
        if User.objects.filter(email=email).exists():
            return JsonResponse({'error': 'Email already exists'}, status=400)
        
        # Validate password
        is_valid, error_msg = validate_password(password)
        if not is_valid:
            return JsonResponse({'error': error_msg}, status=400)
        
        # Validate role
        valid_roles = ['admin', 'developer', 'user', 'viewer']
        if role not in valid_roles:
            return JsonResponse({'error': f'Invalid role. Must be one of: {", ".join(valid_roles)}'}, status=400)
        
        # Create user
        user = User(
            username=username,
            email=email,
            role=role,
            is_active=is_active,
            ai_classification=ai_classification
        )
        user.set_password(password)
        user.save()
        
        return JsonResponse({
            'id': str(user.id),
            'username': user.username,
            'email': user.email,
            'role': user.role,
            'is_active': user.is_active,
            'created_at': user.created_at.isoformat(),
            'ai_classification': user.ai_classification,
        }, status=201)
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User create error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while creating user'}, status=500)


@csrf_exempt
@require_http_methods(["PUT"])
def api_user_update(request, user_id):
    """
    API endpoint to update a user.
    PUT /api/users/{user_id}
    Body: {"email": "...", "role": "...", "is_active": true, "password": "..." (optional)}
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    # Admin can update any user, regular users can only update themselves (limited fields)
    if user.role != 'admin' and str(user.id) != user_id:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        target_user = User.objects.get(id=user_id)
        data = json.loads(request.body)
        
        # Regular users can only update their own email and password
        if user.role != 'admin':
            if 'email' in data:
                email = data['email'].strip()
                if email and email != target_user.email:
                    if User.objects.filter(email=email).exclude(id=user_id).exists():
                        return JsonResponse({'error': 'Email already exists'}, status=400)
                    target_user.email = email
            
            if 'password' in data and data['password']:
                password = data['password']
                is_valid, error_msg = validate_password(password)
                if not is_valid:
                    return JsonResponse({'error': error_msg}, status=400)
                target_user.set_password(password)
        else:
            # Admin can update all fields
            if 'email' in data:
                email = data['email'].strip()
                if email and email != target_user.email:
                    if User.objects.filter(email=email).exclude(id=user_id).exists():
                        return JsonResponse({'error': 'Email already exists'}, status=400)
                    target_user.email = email
            
            if 'role' in data:
                role = data['role']
                valid_roles = ['admin', 'developer', 'user', 'viewer']
                if role not in valid_roles:
                    return JsonResponse({'error': f'Invalid role. Must be one of: {", ".join(valid_roles)}'}, status=400)
                target_user.role = role
            
            if 'is_active' in data:
                target_user.is_active = bool(data['is_active'])
            
            if 'ai_classification' in data:
                target_user.ai_classification = data['ai_classification']
            
            if 'password' in data and data['password']:
                password = data['password']
                is_valid, error_msg = validate_password(password)
                if not is_valid:
                    return JsonResponse({'error': error_msg}, status=400)
                target_user.set_password(password)
        
        target_user.save()
        
        return JsonResponse({
            'id': str(target_user.id),
            'username': target_user.username,
            'email': target_user.email,
            'role': target_user.role,
            'is_active': target_user.is_active,
            'created_at': target_user.created_at.isoformat(),
            'last_login': target_user.last_login.isoformat() if target_user.last_login else None,
            'ai_classification': target_user.ai_classification,
        })
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User update error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while updating user'}, status=500)


@csrf_exempt
@require_http_methods(["DELETE"])
@require_admin
def api_user_delete(request, user_id):
    """
    API endpoint to delete a user (admin only).
    DELETE /api/users/{user_id}
    """
    try:
        target_user = User.objects.get(id=user_id)
        
        # Prevent self-deletion
        if str(request.user_obj.id) == user_id:
            return JsonResponse({'error': 'Cannot delete your own account'}, status=400)
        
        username = target_user.username
        target_user.delete()
        
        return JsonResponse({'message': f'User "{username}" deleted successfully'})
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'User delete error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while deleting user'}, status=500)


# Graph API Endpoints

@csrf_exempt
@require_http_methods(["GET"])
@require_admin
def api_graph_sharepoint_files(request):
    """
    API endpoint to list SharePoint files (admin only).
    GET /api/graph/sharepoint/files?folder_path=Documents
    """
    try:
        folder_path = request.GET.get('folder_path', '')
        
        graph = GraphService()
        result = graph.get_sharepoint_file_list(folder_path)
        
        return JsonResponse(result)
        
    except GraphServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'Graph API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'SharePoint files list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing files',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_graph_sharepoint_upload(request):
    """
    API endpoint to upload a file to SharePoint (admin only).
    POST /api/graph/sharepoint/upload
    Body: {"folder_path": "Documents", "file_name": "test.txt", "content": "base64_encoded_content"}
    """
    try:
        data = json.loads(request.body)
        
        folder_path = data.get('folder_path', '')
        file_name = data.get('file_name')
        content_b64 = data.get('content')
        
        if not file_name:
            return JsonResponse({'error': 'file_name is required'}, status=400)
        
        if not content_b64:
            return JsonResponse({'error': 'content is required'}, status=400)
        
        # Decode base64 content
        try:
            content = base64.b64decode(content_b64)
        except Exception as e:
            return JsonResponse({'error': 'Invalid base64 content', 'details': 'An error occurred'}, status=400)
        
        graph = GraphService()
        result = graph.upload_sharepoint_file(folder_path, file_name, content)
        
        return JsonResponse(result, status=201)
        
    except GraphServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'Graph API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'SharePoint upload error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while uploading file',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_graph_mail_send(request):
    """
    API endpoint to send a test email via Graph API (admin only).
    POST /api/graph/mail/send
    Body: {"to": ["user@domain.com"], "subject": "Test", "body": "Test message"}
    """
    try:
        data = json.loads(request.body)
        
        to = data.get('to')
        subject = data.get('subject')
        body = data.get('body')
        
        if not to or not isinstance(to, list):
            return JsonResponse({'error': 'to must be a list of email addresses'}, status=400)
        
        if not subject:
            return JsonResponse({'error': 'subject is required'}, status=400)
        
        if not body:
            return JsonResponse({'error': 'body is required'}, status=400)
        
        graph = GraphService()
        result = graph.send_mail(to, subject, body)
        
        return JsonResponse(result)
        
    except GraphServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'Graph API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Mail send error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while sending email',
            'details': 'An error occurred'
        }, status=500)


# GitHub API Endpoints

def require_developer(view_func):
    """Decorator to require admin or developer role for API endpoints"""
    def wrapper(request, *args, **kwargs):
        user = get_user_from_token(request)
        if not user or user.role not in ['admin', 'developer']:
            return JsonResponse({'error': 'Admin or developer access required'}, status=403)
        request.user_obj = user
        return view_func(request, *args, **kwargs)
    return wrapper


@csrf_exempt
@require_http_methods(["GET"])
@require_developer
def api_github_repos(request):
    """
    API endpoint to list GitHub repositories (admin/developer only).
    GET /api/github/repos?owner=username&per_page=30&page=1
    """
    try:
        owner = request.GET.get('owner')
        per_page = int(request.GET.get('per_page', 30))
        page = int(request.GET.get('page', 1))
        
        github = GitHubService()
        result = github.get_repositories(owner=owner, per_page=per_page, page=page)
        
        return JsonResponse(result)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub repos list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing repositories'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_developer
def api_github_create_issue(request):
    """
    API endpoint to create a GitHub issue (admin/developer only).
    POST /api/github/create-issue
    Body: {"owner": "...", "repo": "...", "title": "...", "body": "...", "labels": ["..."], "assignees": ["..."]}
    """
    try:
        data = json.loads(request.body)
        
        title = data.get('title')
        body = data.get('body')
        owner = data.get('owner')
        repo = data.get('repo')
        labels = data.get('labels', [])
        assignees = data.get('assignees', [])
        
        if not title:
            return JsonResponse({'error': 'title is required'}, status=400)
        
        if not body:
            return JsonResponse({'error': 'body is required'}, status=400)
        
        github = GitHubService()
        result = github.create_issue(
            title=title,
            body=body,
            owner=owner,
            repo=repo,
            labels=labels,
            assignees=assignees
        )
        
        return JsonResponse(result, status=201)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub create issue error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while creating issue'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
@require_developer
def api_github_get_issue(request, owner, repo, issue_number):
    """
    API endpoint to get a specific GitHub issue (admin/developer only).
    GET /api/github/issue/{owner}/{repo}/{issue_number}
    """
    try:
        github = GitHubService()
        result = github.get_issue(
            issue_number=int(issue_number),
            owner=owner,
            repo=repo
        )
        
        return JsonResponse(result)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except ValueError:
        return JsonResponse({'error': 'Invalid issue number'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub get issue error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while retrieving issue'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
@require_developer
def api_github_list_issues(request, owner, repo):
    """
    API endpoint to list GitHub issues in a repository (admin/developer only).
    GET /api/github/issues/{owner}/{repo}?state=open&labels=bug,feature&per_page=30&page=1
    """
    try:
        state = request.GET.get('state', 'open')
        labels_str = request.GET.get('labels')
        labels = labels_str.split(',') if labels_str else None
        per_page = int(request.GET.get('per_page', 30))
        page = int(request.GET.get('page', 1))
        
        github = GitHubService()
        result = github.list_issues(
            owner=owner,
            repo=repo,
            state=state,
            labels=labels,
            per_page=per_page,
            page=page
        )
        
        return JsonResponse(result)
        
    except GitHubServiceError as e:
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub list issues error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing issues'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_github_sync_issues_to_tasks(request, item_id):
    """
    API endpoint to sync GitHub issues to IdeaGraph tasks for a specific item.
    POST /api/github/sync-issues-to-tasks/<item_id>
    
    Request body (JSON):
    {
        "owner": "optional-owner",  // defaults to settings or item's repo
        "repo": "optional-repo",    // defaults to item's github_repo
        "state": "all"              // 'open', 'closed', or 'all' (default: 'all')
    }
    
    Response:
    {
        "success": true,
        "issues_checked": 15,
        "tasks_created": 10,
        "duplicates_by_id": 3,
        "duplicates_by_title": 2,
        "errors": []
    }
    """
    from core.services.github_task_sync_service import GitHubTaskSyncService, GitHubTaskSyncServiceError
    from .models import Item, User
    
    try:
        # Get user from session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({
                'success': False,
                'error': 'Authentication required'
            }, status=401)
        
        user = User.objects.filter(id=user_id).first()
        if not user:
            return JsonResponse({
                'success': False,
                'error': 'User not found'
            }, status=401)
        
        # Get the item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Item not found'
            }, status=404)
        
        # Check permissions (admin or item owner)
        if user.role != 'admin' and item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Parse request body
        try:
            data = json.loads(request.body) if request.body else {}
        except json.JSONDecodeError:
            data = {}
        
        owner = data.get('owner')
        repo = data.get('repo')
        state = data.get('state', 'all')
        
        # Initialize sync service
        sync_service = GitHubTaskSyncService()
        
        # Perform synchronization
        result = sync_service.sync_github_issues_to_tasks(
            item=item,
            owner=owner,
            repo=repo,
            state=state,
            created_by=user
        )
        
        # Sanitize error messages to prevent information leakage
        if 'errors' in result and result['errors']:
            # Keep count but don't expose detailed error messages
            result['error_count'] = len(result['errors'])
            result['errors'] = []  # Clear detailed errors for security
        
        return JsonResponse(result)
        
    except GitHubTaskSyncServiceError as e:
        logger.error(f'GitHub task sync error: {e.message}')
        # Don't expose internal details to external users
        return JsonResponse({
            'success': False,
            'error': e.message
        }, status=500)
    except Exception as e:
        logger.exception(f'Unexpected error in GitHub task sync: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An unexpected error occurred during synchronization'
        }, status=500)


# ==================== KiGate API Endpoints ====================

@csrf_exempt
@require_http_methods(["GET"])
def api_kigate_agents(request):
    """
    API endpoint to list all available KiGate agents.
    GET /api/kigate/agents
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        kigate = KiGateService()
        result = kigate.get_agents()
        
        return JsonResponse(result)
        
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate agents list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing agents'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_kigate_execute(request):
    """
    API endpoint to execute a KiGate agent.
    POST /api/kigate/execute
    Body: {
        "agent_name": "...",
        "provider": "...",
        "model": "...",
        "message": "...",
        "user_id": "...",
        "parameters": {...}  // optional
    }
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        data = json.loads(request.body)
        
        agent_name = data.get('agent_name')
        provider = data.get('provider')
        model = data.get('model')
        message = data.get('message')
        user_id = data.get('user_id')
        parameters = data.get('parameters')
        
        # Validate required fields
        if not agent_name:
            return JsonResponse({'error': 'agent_name is required'}, status=400)
        if not provider:
            return JsonResponse({'error': 'provider is required'}, status=400)
        if not model:
            return JsonResponse({'error': 'model is required'}, status=400)
        if not message:
            return JsonResponse({'error': 'message is required'}, status=400)
        if not user_id:
            return JsonResponse({'error': 'user_id is required'}, status=400)
        
        kigate = KiGateService()
        result = kigate.execute_agent(
            agent_name=agent_name,
            provider=provider,
            model=model,
            message=message,
            user_id=user_id,
            parameters=parameters
        )
        
        return JsonResponse(result, status=200)
        
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate execute error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while executing agent'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_kigate_agent_details(request, agent_name):
    """
    API endpoint to get details of a specific KiGate agent.
    GET /api/kigate/agent/{agent_name}
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        kigate = KiGateService()
        result = kigate.get_agent_details(agent_name=agent_name)
        
        return JsonResponse(result)
        
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate agent details error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while getting agent details'
        }, status=500)


# ==================== OpenAI API Endpoints ====================

@csrf_exempt
@require_http_methods(["POST"])
def api_openai_query(request):
    """
    API endpoint to execute an AI query via OpenAI API (with KiGate fallback).
    POST /api/openai/query
    Body: {
        "prompt": "...",
        "model": "..." (optional),
        "user_id": "..." (optional),
        "agent_name": "..." (optional - for KiGate routing),
        "temperature": 0.7 (optional),
        "max_tokens": 1000 (optional)
    }
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        data = json.loads(request.body)
        
        prompt = data.get('prompt')
        model = data.get('model')
        user_id = data.get('user_id', str(user.id))
        agent_name = data.get('agent_name')
        temperature = data.get('temperature', 0.7)
        max_tokens = data.get('max_tokens')
        
        # Validate required fields
        if not prompt:
            return JsonResponse({'error': 'prompt is required'}, status=400)
        
        openai = OpenAIService()
        
        # Use agent routing if agent_name is provided
        if agent_name:
            result = openai.query_with_agent(
                prompt=prompt,
                agent_name=agent_name,
                user_id=user_id,
                model=model
            )
        else:
            result = openai.query(
                prompt=prompt,
                model=model,
                user_id=user_id,
                temperature=temperature,
                max_tokens=max_tokens
            )
        
        return JsonResponse(result, status=200)
        
    except OpenAIServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI query error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while executing query'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_openai_models(request):
    """
    API endpoint to list available OpenAI models.
    GET /api/openai/models
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        openai = OpenAIService()
        result = openai.get_models()
        
        return JsonResponse(result)
        
    except OpenAIServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'OpenAI models list error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'An error occurred while listing models'
        }, status=500)


# ==================== Task API Endpoints ====================

@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_tasks(request, item_id=None):
    """
    API endpoint for task CRUD operations.
    GET /api/tasks/{item_id} - List tasks for an item
    POST /api/tasks/{item_id} - Create a new task
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Task, Tag
    
    if request.method == 'GET':
        # List tasks for an item
        if not item_id:
            return JsonResponse({'error': 'item_id is required'}, status=400)
        
        try:
            item = Item.objects.get(id=item_id)
            # Check ownership
            if user.role != 'admin' and item.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
            
            # Get tasks for this item - only show owned tasks
            tasks = item.tasks.filter(created_by=user).select_related('assigned_to', 'created_by').prefetch_related('tags')
            
            # Sort tasks by status priority
            status_order = {'new': 1, 'working': 2, 'review': 3, 'ready': 4, 'done': 5}
            tasks = sorted(tasks, key=lambda t: status_order.get(t.status, 99))
            
            tasks_data = [{
                'id': str(task.id),
                'title': task.title,
                'description': task.description,
                'status': task.status,
                'status_display': task.get_status_display(),
                'github_issue_id': task.github_issue_id,
                'github_issue_url': task.github_issue_url,
                'assigned_to': task.assigned_to.username if task.assigned_to else None,
                'created_at': task.created_at.isoformat(),
                'updated_at': task.updated_at.isoformat(),
                'tags': [{'id': str(tag.id), 'name': tag.name, 'color': tag.color} for tag in task.tags.all()],
            } for task in tasks]
            
            return JsonResponse({
                'success': True,
                'tasks': tasks_data
            })
            
        except Item.DoesNotExist:
            return JsonResponse({'error': 'Item not found'}, status=404)
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f'Task list error: {str(e)}')
            return JsonResponse({'error': 'An error occurred while listing tasks'}, status=500)
    
    elif request.method == 'POST':
        # Create a new task
        if not item_id:
            return JsonResponse({'error': 'item_id is required'}, status=400)
        
        try:
            data = json.loads(request.body)
            item = Item.objects.get(id=item_id)
            
            # Check ownership
            if user.role != 'admin' and item.created_by != user:
                return JsonResponse({'error': 'Access denied'}, status=403)
            
            title = data.get('title', '').strip()
            description = data.get('description', '').strip()
            status = data.get('status', 'new')
            tag_ids = data.get('tags', [])
            
            if not title:
                return JsonResponse({'error': 'Title is required'}, status=400)
            
            # Create task
            task = Task(
                title=title,
                description=description,
                status=status,
                item=item,
                created_by=user,
                assigned_to=user
            )
            task.save()
            
            # Add tags
            if tag_ids:
                task.tags.set(tag_ids)
            
            # Sync with Weaviate
            try:
                from main.models import Settings
                settings = Settings.objects.first()
                if settings:
                    sync_service = WeaviateTaskSyncService(settings)
                    sync_service.sync_create(task)
            except WeaviateTaskSyncServiceError as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync failed for task {task.id}: {e.message}')
            except Exception as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync error for task {task.id}: {str(e)}')
            
            return JsonResponse({
                'success': True,
                'task': {
                    'id': str(task.id),
                    'title': task.title,
                    'description': task.description,
                    'status': task.status,
                    'status_display': task.get_status_display(),
                }
            }, status=201)
            
        except Item.DoesNotExist:
            return JsonResponse({'error': 'Item not found'}, status=404)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f'Task create error: {str(e)}')
            return JsonResponse({'error': 'An error occurred while creating task'}, status=500)


@csrf_exempt
@require_http_methods(["GET", "PUT", "DELETE"])
def api_task_detail(request, task_id):
    """
    API endpoint for task detail operations.
    GET /api/tasks/{task_id} - Get task details
    PUT /api/tasks/{task_id} - Update a task
    DELETE /api/tasks/{task_id} - Delete a task
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Check ownership
        if task.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        if request.method == 'GET':
            return JsonResponse({
                'success': True,
                'task': {
                    'id': str(task.id),
                    'title': task.title,
                    'description': task.description,
                    'status': task.status,
                    'status_display': task.get_status_display(),
                    'github_issue_id': task.github_issue_id,
                    'github_issue_url': task.github_issue_url,
                    'assigned_to': task.assigned_to.username if task.assigned_to else None,
                    'created_at': task.created_at.isoformat(),
                    'updated_at': task.updated_at.isoformat(),
                    'tags': [{'id': str(tag.id), 'name': tag.name, 'color': tag.color} for tag in task.tags.all()],
                }
            })
        
        elif request.method == 'PUT':
            data = json.loads(request.body)
            
            title = data.get('title', '').strip()
            description = data.get('description', '').strip()
            status = data.get('status', task.status)
            tag_ids = data.get('tags', [])
            
            if not title:
                return JsonResponse({'error': 'Title is required'}, status=400)
            
            previous_status = task.status
            task.title = title
            task.description = description
            task.status = status

            # Mark as done if status changed to done
            if status == 'done' and previous_status != 'done':
                task.save()
                task.mark_as_done()
            else:
                task.save()
            
            # Update tags
            if tag_ids:
                task.tags.set(tag_ids)
            else:
                task.tags.clear()
            
            # Sync with Weaviate
            try:
                from main.models import Settings
                settings = Settings.objects.first()
                if settings:
                    sync_service = WeaviateTaskSyncService(settings)
                    sync_service.sync_update(task)
            except WeaviateTaskSyncServiceError as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync failed for task {task.id}: {e.message}')
            except Exception as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync error for task {task.id}: {str(e)}')
            
            return JsonResponse({
                'success': True,
                'task': {
                    'id': str(task.id),
                    'title': task.title,
                    'description': task.description,
                    'status': task.status,
                    'status_display': task.get_status_display(),
                }
            })
        
        elif request.method == 'DELETE':
            task_id = str(task.id)
            task.delete()
            
            # Sync with Weaviate
            try:
                from main.models import Settings
                settings = Settings.objects.first()
                if settings:
                    sync_service = WeaviateTaskSyncService(settings)
                    sync_service.sync_delete(task_id)
            except WeaviateTaskSyncServiceError as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync failed for task {task_id}: {e.message}')
            except Exception as e:
                import logging
                sync_logger = logging.getLogger(__name__)
                sync_logger.warning(f'Weaviate sync error for task {task_id}: {str(e)}')
            
            return JsonResponse({'success': True, 'message': 'Task deleted successfully'})
    
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Task operation error: {str(e)}')
        return JsonResponse({'error': 'An error occurred'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_generate_title(request, task_id):
    """
    API endpoint to generate task title from description using AI.
    POST /api/tasks/{task_id}/generate-title
    Body: {"description": "..."}
    
    Uses KiGate API with "text-to-title-generator" agent.
    Can work with unsaved tasks (task_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        # Task ID might be "new" for unsaved tasks
        if task_id != 'new':
            task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to generate title
        kigate = KiGateService()
        
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not title_result.get('success'):
            return JsonResponse({'error': title_result.get('error', 'Failed to generate title')}, status=500)
        
        generated_title = title_result.get('result', title_result.get('response', '')).strip()
        generated_title = strip_quotes_from_title(generated_title)
        if generated_title:
            generated_title = generated_title[:255]  # Limit to field max length
        
        return JsonResponse({
            'success': True,
            'title': generated_title
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task title generation error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during title generation'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_extract_tags(request, task_id):
    """
    API endpoint to extract tags from task description using AI.
    POST /api/tasks/{task_id}/extract-tags
    Body: {"description": "..."}
    
    Uses KiGate API with "text-keyword-extractor-de" agent.
    Can work with unsaved tasks (task_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Tag, Settings
    
    try:
        # Task ID might be "new" for unsaved tasks
        if task_id != 'new':
            task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Use KiGate service to extract tags
        kigate = KiGateService()
        
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        if not keyword_result.get('success'):
            return JsonResponse({'error': keyword_result.get('error', 'Failed to extract tags')}, status=500)
        
        # Parse keywords and create/get tags
        tags_list = []
        keywords_response = keyword_result.get('result', keyword_result.get('response', ''))
        # Extract keywords from response (can be comma-separated or line-separated)
        keywords = []
        for line in keywords_response.split('\n'):
            for k in line.split(','):
                cleaned_keyword = clean_tag_name(k)
                if cleaned_keyword and cleaned_keyword not in keywords:
                    keywords.append(cleaned_keyword)
        
        # Get or create tags (avoid duplicates)
        for keyword in keywords[:max_tags]:
            # Check if tag already exists (case-insensitive to avoid duplicates)
            tag = Tag.objects.filter(name__iexact=keyword).first()
            if not tag:
                tag = Tag.objects.create(name=keyword)
            tags_list.append(tag.name)
        
        return JsonResponse({
            'success': True,
            'tags': tags_list
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task tag extraction error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during tag extraction'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_optimize_description(request, task_id):
    """
    API endpoint to optimize/normalize task description using AI.
    POST /api/tasks/{task_id}/optimize-description
    Body: {"description": "..."}
    
    Uses KiGate API with "text-optimization-agent" agent.
    Can work with unsaved tasks (task_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        # Task ID might be "new" for unsaved tasks
        if task_id != 'new':
            task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to optimize description
        kigate = KiGateService()
        
        text_result = kigate.execute_agent(
            agent_name='text-optimization-agent',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to optimize description')}, status=500)
        
        optimized_text = text_result.get('result', text_result.get('response', description))
        
        return JsonResponse({
            'success': True,
            'description': optimized_text
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task description optimization error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during description optimization'}, status=500)


@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_task_ai_enhance(request, task_id):
    """
    API endpoint to enhance task with AI.
    
    GET /api/tasks/{task_id}/ai-enhance
    Returns endpoint information and usage instructions.
    
    POST /api/tasks/{task_id}/ai-enhance
    Body: {"title": "...", "description": "..."}
    
    Process:
    1. Query Weaviate for similar tasks to provide context
    2. Normalize text using KiGate API with "github-issue-creation-agent" with context
    3. Generate title from normalized text using "text-to-title-generator"
    4. Extract 5 tags using "text-keyword-extractor-de" and replace existing tags
    """
    # Handle GET requests with endpoint information
    if request.method == 'GET':
        return JsonResponse({
            'error': 'Method not allowed',
            'message': 'This endpoint only accepts POST requests',
            'method': 'POST',
            'endpoint': f'/api/tasks/{task_id}/ai-enhance',
            'required_body': {
                'title': 'string (required)',
                'description': 'string (required)'
            },
            'description': 'Enhances task with AI by normalizing text, generating title, and extracting tags'
        }, status=405)
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Tag, Settings
    
    try:
        task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        title = data.get('title', '').strip()
        description = data.get('description', '').strip()
        
        if not title or not description:
            return JsonResponse({'error': 'Title and description are required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Step 1: Query Weaviate for similar tasks to provide context
        context_text = ""
        try:
            weaviate_service = WeaviateTaskSyncService(settings)
            search_query = f"{title}\n{description}"
            similar_results = weaviate_service.search_similar(search_query, n_results=3)
            
            if similar_results.get('success') and similar_results.get('results'):
                context_items = []
                for idx, result in enumerate(similar_results['results'][:3], 1):
                    metadata = result.get('metadata', {})
                    doc = result.get('document', '')
                    context_items.append(f"Similar Task {idx}:\nTitle: {metadata.get('title', 'N/A')}\nDescription: {doc[:200]}...")
                
                context_text = "\n\n".join(context_items)
                logger.info(f"Found {len(similar_results['results'])} similar tasks for context")
        except Exception as e:
            logger.warning(f"Could not retrieve Weaviate context: {str(e)}")
            # Continue without context if Weaviate fails
        
        # Use KiGate service to enhance content
        kigate = KiGateService()
        
        # Step 2: Normalize text with context using github-issue-creation-agent
        normalization_message = f"Title: {title}\n\nDescription:\n{description}"
        if context_text:
            normalization_message += f"\n\n--- Context from similar tasks ---\n{context_text}\n--- End of context ---"
        
        text_result = kigate.execute_agent(
            agent_name='github-issue-creation-agent',
            provider='openai',
            model='gpt-4',
            message=normalization_message,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to normalize text')}, status=500)
        
        normalized_text = text_result.get('result', text_result.get('response', description))
        
        # Step 3: Generate title from normalized text using text-to-title-generator
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=normalized_text,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        enhanced_title = title
        if title_result.get('success'):
            generated_title = title_result.get('result', title_result.get('response', '')).strip()
            generated_title = strip_quotes_from_title(generated_title)
            if generated_title:
                enhanced_title = generated_title[:255]  # Limit to field max length
        
        # Step 4: Extract keywords/tags using text-keyword-extractor-de
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=normalized_text,
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        # Parse keywords and create/get tags
        tags_list = []
        if keyword_result.get('success'):
            keywords_response = keyword_result.get('result', keyword_result.get('response', ''))
            # Extract keywords from response (can be comma-separated or line-separated)
            keywords = []
            for line in keywords_response.split('\n'):
                for k in line.split(','):
                    cleaned_keyword = clean_tag_name(k)
                    if cleaned_keyword and cleaned_keyword not in keywords:
                        keywords.append(cleaned_keyword)
            
            # Get or create tags (avoid duplicates)
            for keyword in keywords[:max_tags]:
                # Check if tag already exists (case-insensitive to avoid duplicates)
                tag = Tag.objects.filter(name__iexact=keyword).first()
                if not tag:
                    tag = Tag.objects.create(name=keyword)
                tags_list.append(tag.name)
        
        return JsonResponse({
            'success': True,
            'title': enhanced_title,
            'description': normalized_text,
            'tags': tags_list
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except WeaviateTaskSyncServiceError as e:
        logger.error(f'Weaviate error: {e.message}')
        return JsonResponse({'error': 'Weaviate service error', 'details': e.message}, status=500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task AI enhance error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during AI enhancement'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_generate_title(request, item_id):
    """
    API endpoint to generate item title from description using AI.
    POST /api/items/{item_id}/generate-title
    Body: {"description": "..."}
    
    Uses KiGate API with "text-to-title-generator" agent.
    Can work with unsaved items (item_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item
    
    try:
        # Item ID might be "new" for unsaved items
        if item_id != 'new':
            item = Item.objects.get(id=item_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to generate title
        kigate = KiGateService()
        
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not title_result.get('success'):
            return JsonResponse({'error': title_result.get('error', 'Failed to generate title')}, status=500)
        
        generated_title = title_result.get('result', title_result.get('response', '')).strip()
        generated_title = strip_quotes_from_title(generated_title)
        if generated_title:
            generated_title = generated_title[:255]  # Limit to field max length
        
        return JsonResponse({
            'success': True,
            'title': generated_title
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Item title generation error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during title generation'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_extract_tags(request, item_id):
    """
    API endpoint to extract tags from item description using AI.
    POST /api/items/{item_id}/extract-tags
    Body: {"description": "..."}
    
    Uses KiGate API with "text-keyword-extractor-de" agent.
    Can work with unsaved items (item_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Tag, Settings
    
    try:
        # Item ID might be "new" for unsaved items
        if item_id != 'new':
            item = Item.objects.get(id=item_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Use KiGate service to extract tags
        kigate = KiGateService()
        
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        if not keyword_result.get('success'):
            return JsonResponse({'error': keyword_result.get('error', 'Failed to extract tags')}, status=500)
        
        # Parse keywords and create/get tags
        tags_list = []
        keywords_response = keyword_result.get('result', keyword_result.get('response', ''))
        # Extract keywords from response (can be comma-separated or line-separated)
        keywords = []
        for line in keywords_response.split('\n'):
            for k in line.split(','):
                cleaned_keyword = clean_tag_name(k)
                if cleaned_keyword and cleaned_keyword not in keywords:
                    keywords.append(cleaned_keyword)
        
        # Get or create tags (avoid duplicates)
        for keyword in keywords[:max_tags]:
            # Check if tag already exists (case-insensitive to avoid duplicates)
            tag = Tag.objects.filter(name__iexact=keyword).first()
            if not tag:
                tag = Tag.objects.create(name=keyword)
            tags_list.append(tag.name)
        
        return JsonResponse({
            'success': True,
            'tags': tags_list
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Item tag extraction error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during tag extraction'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_optimize_description(request, item_id):
    """
    API endpoint to optimize/normalize item description using AI.
    POST /api/items/{item_id}/optimize-description
    Body: {"description": "..."}
    
    Uses KiGate API with "text-optimization-agent" agent.
    Can work with unsaved items (item_id is optional in that case).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item
    
    try:
        # Item ID might be "new" for unsaved items
        if item_id != 'new':
            item = Item.objects.get(id=item_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use KiGate service to optimize description
        kigate = KiGateService()
        
        text_result = kigate.execute_agent(
            agent_name='text-optimization-agent',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to optimize description')}, status=500)
        
        optimized_text = text_result.get('result', text_result.get('response', description))
        
        return JsonResponse({
            'success': True,
            'description': optimized_text
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Item description optimization error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during description optimization'}, status=500)


@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_item_ai_enhance(request, item_id):
    """
    API endpoint to enhance item with AI using KiGate agents.
    
    This function performs three main tasks:
    1. Text normalization (spelling, grammar, flow, comprehensibility) using 'text-optimization-agent'
    2. Title generation from normalized text using 'text-to-title-generator'
    3. Tag/keyword extraction from item context using 'text-keyword-extractor-de'
    
    The generated tags replace any existing tags on the item to avoid duplicates.
    Tags are properly attached to the Item entity via the ManyToMany relationship.
    
    GET /api/items/{item_id}/ai-enhance
    Returns endpoint information and usage instructions.
    
    POST /api/items/{item_id}/ai-enhance
    Body: {"title": "...", "description": "..."}
    
    Returns:
        JSON response with enhanced title, description, and tags list
    """
    # Handle GET requests with endpoint information
    if request.method == 'GET':
        return JsonResponse({
            'error': 'Method not allowed',
            'message': 'This endpoint only accepts POST requests',
            'method': 'POST',
            'endpoint': f'/api/items/{item_id}/ai-enhance',
            'required_body': {
                'title': 'string (required)',
                'description': 'string (required)'
            },
            'description': 'Enhances item with AI by normalizing text, generating title, and extracting tags'
        }, status=405)
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Tag, Settings
    
    try:
        item = Item.objects.get(id=item_id)
        
        # Check ownership
        if item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        title = data.get('title', '').strip()
        description = data.get('description', '').strip()
        
        if not title or not description:
            return JsonResponse({'error': 'Title and description are required'}, status=400)
        
        # Get settings for max tags
        settings = Settings.objects.first()
        max_tags = settings.max_tags_per_idea if settings else 5
        
        # Use KiGate service to enhance content
        kigate = KiGateService()
        
        # Step 1: Optimize/normalize the text (spelling, grammar, flow, comprehensibility)
        text_result = kigate.execute_agent(
            agent_name='text-optimization-agent',
            provider='openai',
            model='gpt-4',
            message=description,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        if not text_result.get('success'):
            return JsonResponse({'error': text_result.get('error', 'Failed to enhance text')}, status=500)
        
        # Use 'result' field from KiGate API response, not 'response'
        enhanced_text = text_result.get('result', description)
        
        # Step 2: Generate a title from the normalized text
        title_result = kigate.execute_agent(
            agent_name='text-to-title-generator',
            provider='openai',
            model='gpt-4',
            message=enhanced_text,
            user_id=str(user.id),
            parameters={'language': 'de'}
        )
        
        # Use generated title if successful, otherwise keep original
        enhanced_title = title
        if title_result.get('success'):
            generated_title = title_result.get('result', '').strip()
            generated_title = strip_quotes_from_title(generated_title)
            if generated_title:
                enhanced_title = generated_title[:255]  # Limit to field max length
        
        # Step 3: Extract keywords/tags from the item context
        keyword_result = kigate.execute_agent(
            agent_name='text-keyword-extractor-de',
            provider='openai',
            model='gpt-4',
            message=f"Title: {enhanced_title}\n\nDescription:\n{enhanced_text}",
            user_id=str(user.id),
            parameters={'max_keywords': max_tags}
        )
        
        # Parse keywords and manage tags
        tags_list = []
        if keyword_result.get('success'):
            keywords_text = keyword_result.get('result', '')
            # Extract keywords from response (handle comma-separated or newline-separated)
            keywords = []
            for k in keywords_text.replace('\n', ',').split(','):
                cleaned_keyword = clean_tag_name(k)
                if cleaned_keyword and cleaned_keyword not in keywords:
                    keywords.append(cleaned_keyword)
            
            # Clear existing tags to replace them with new ones
            item.tags.clear()
            
            # Get or create tags and attach to item (prevent duplicates)
            for keyword in keywords[:max_tags]:
                # Check if tag already exists (case-insensitive to avoid duplicates)
                tag = Tag.objects.filter(name__iexact=keyword).first()
                if not tag:
                    tag = Tag.objects.create(name=keyword)
                # Add tag to item (ManyToManyField handles duplicates automatically)
                item.tags.add(tag)
                tags_list.append(tag.name)
            
            # Mark that AI tags have been generated
            item.ai_tags_generated = True
        
        # Mark item as AI enhanced
        item.ai_enhanced = True
        item.save()
        
        return JsonResponse({
            'success': True,
            'title': enhanced_title,
            'description': enhanced_text,
            'tags': tags_list
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Item AI enhance error: {str(e)}')
        return JsonResponse({'error': 'An error occurred during AI enhancement'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_build_tasks(request, item_id):
    """
    API endpoint to build/decompose tasks from an item using AI.
    POST /api/items/{item_id}/build-tasks
    Body: {"title": "...", "description": "..."}
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Task, Tag, Settings
    
    try:
        item = Item.objects.get(id=item_id)
        
        # Check ownership
        if item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        title = data.get('title', item.title).strip()
        description = data.get('description', item.description).strip()
        
        if not title or not description:
            return JsonResponse({'error': 'Title and description are required'}, status=400)
        
        # Use KiGate service to decompose item into tasks
        kigate = KiGateService()
        
        # Use task decomposition agent to generate tasks
        decompose_result = kigate.execute_agent(
            agent_name='task-decomposition-agent',
            provider='openai',
            model='gpt-4',
            message=f"Title: {title}\n\nDescription:\n{description}\n\nPlease decompose this into actionable tasks.",
            user_id=str(user.id),
            parameters={'max_tasks': 10}
        )
        
        if not decompose_result.get('success'):
            return JsonResponse({'error': decompose_result.get('error', 'Failed to decompose tasks')}, status=500)
        
        # Parse the response to extract tasks
        # Expected format: The agent should return tasks in a structured format
        response_text = decompose_result.get('response', '')
        
        # Parse tasks from response (assuming line-by-line format or JSON)
        tasks_created = []
        try:
            # Try to parse as JSON first
            import json as json_lib
            tasks_data = json_lib.loads(response_text)
            if isinstance(tasks_data, list):
                for task_data in tasks_data[:10]:  # Limit to 10 tasks
                    if isinstance(task_data, dict):
                        task_title = task_data.get('title', '')
                        task_desc = task_data.get('description', '')
                    else:
                        task_title = str(task_data)
                        task_desc = ''
                    
                    if task_title:
                        task = Task.objects.create(
                            title=task_title[:255],
                            description=task_desc,
                            status='new',
                            item=item,
                            created_by=user,
                            assigned_to=user,
                            ai_generated=True
                        )
                        tasks_created.append({
                            'id': str(task.id),
                            'title': task.title,
                            'description': task.description
                        })
        except (json_lib.JSONDecodeError, ValueError):
            # Fallback: Parse as line-separated tasks
            lines = response_text.split('\n')
            for line in lines[:10]:  # Limit to 10 tasks
                line = line.strip()
                # Remove common prefixes like "1.", "-", "*", etc.
                line = line.lstrip('0123456789.-* ')
                if line and len(line) > 3:
                    task = Task.objects.create(
                        title=line[:255],
                        description='',
                        status='new',
                        item=item,
                        created_by=user,
                        assigned_to=user,
                        ai_generated=True
                    )
                    tasks_created.append({
                        'id': str(task.id),
                        'title': task.title,
                        'description': task.description
                    })
        
        return JsonResponse({
            'success': True,
            'tasks': tasks_created,
            'count': len(tasks_created)
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except KiGateServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'KiGate API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Build tasks error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while building tasks'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_check_similarity(request, item_id):
    """
    API endpoint to check similarity for an item using Weaviate.
    POST /api/items/{item_id}/check-similarity
    Body: {"title": "...", "description": "..."}
    
    Returns only items with a relevance/similarity score of at least 0.8.
    The relevance score is calculated as: relevance = 1 - (distance / 2)
    where distance is the Weaviate cosine distance (0-2 range).
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item, Settings
    from core.services.weaviate_sync_service import WeaviateItemSyncService, WeaviateItemSyncServiceError
    
    try:
        item = Item.objects.get(id=item_id)
        
        # Check ownership
        if item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        data = json.loads(request.body)
        title = data.get('title', item.title).strip()
        description = data.get('description', item.description).strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use Weaviate to find similar items
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({'error': 'Settings not configured'}, status=500)
        
        weaviate_service = WeaviateItemSyncService(settings)
        
        # Search for similar items (request more results to ensure we have enough after filtering)
        search_text = f"{title}\n\n{description}"
        result = weaviate_service.search_similar(search_text, n_results=20)
        
        if not result.get('success'):
            return JsonResponse({'error': 'Failed to search for similar items'}, status=500)
        
        # Minimum relevance threshold (0.8 = 80% similarity)
        MIN_RELEVANCE = 0.8
        
        # Filter results by relevance and exclude current item
        similar_items = []
        for similar_item in result.get('results', []):
            # Skip the current item
            if similar_item.get('id') == str(item_id):
                continue
            
            # Convert Weaviate distance to relevance/similarity score
            # Weaviate uses cosine distance where 0 = identical, 2 = opposite
            # Relevance formula: 1 - (distance / 2)
            distance = similar_item.get('distance', 2.0)
            relevance = 1.0 - (distance / 2.0)
            
            # Only include items with relevance >= 0.8
            if relevance >= MIN_RELEVANCE:
                # Add relevance score to the item data
                similar_item['relevance'] = round(relevance, 3)
                similar_items.append(similar_item)
        
        return JsonResponse({
            'success': True,
            'similar_items': similar_items[:5]  # Limit to 5 most relevant results
        })
        
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except WeaviateItemSyncServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Weaviate error: {e.message}')
        return JsonResponse(e.to_dict(), status=500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Check similarity error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while checking similarity'}, status=500)


def get_or_create_github_copilot_user():
    """
    Get or create the 'GitHub Copilot' user for auto-assignment.
    
    Returns:
        User: The GitHub Copilot user instance
    """
    from .models import Settings
    import secrets
    
    COPILOT_USERNAME = "GitHub Copilot"
    
    # Try to get existing user
    try:
        user = User.objects.get(username=COPILOT_USERNAME)
        return user
    except User.DoesNotExist:
        pass
    
    # User doesn't exist, create it
    settings = Settings.objects.first()
    
    # Use default mail sender or fallback email
    email = settings.default_mail_sender if settings and settings.default_mail_sender else "copilot@ideagraph.local"
    
    # Create user with random password
    copilot_user = User.objects.create(
        username=COPILOT_USERNAME,
        email=email,
        first_name="GitHub",
        last_name="Copilot",
        role="developer",
        is_active=True,
        auth_type="local"
    )
    
    # Set a random password (user won't be able to log in as they don't know it)
    random_password = secrets.token_urlsafe(32)
    copilot_user.set_password(random_password)
    copilot_user.save()
    
    logger.info(f'GitHub Copilot user created: {copilot_user.id}')
    
    return copilot_user


@csrf_exempt
@require_http_methods(["POST"])
def api_task_create_github_issue(request, task_id):
    """
    API endpoint to create GitHub issue from task.
    POST /api/tasks/{task_id}/create-github-issue
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Check status
        if task.status != 'ready':
            return JsonResponse({'error': 'Task must be in Ready status to create GitHub issue'}, status=400)
        
        # Check if issue already exists
        if task.github_issue_id:
            return JsonResponse({'error': 'GitHub issue already exists for this task'}, status=400)
        
        # Get GitHub repository from item
        if not task.item or not task.item.github_repo:
            return JsonResponse({'error': 'No GitHub repository configured for this item'}, status=400)
        
        # Parse owner/repo from github_repo field
        repo_parts = task.item.github_repo.split('/')
        if len(repo_parts) != 2:
            return JsonResponse({'error': 'Invalid GitHub repository format. Expected: owner/repo'}, status=400)
        
        owner, repo = repo_parts
        
        # Prepare labels from tags
        labels = [tag.name for tag in task.tags.all()]
        
        # Get settings for GitHub Copilot username
        from .models import Settings
        settings = Settings.objects.first()
        assignees = []
        if settings and settings.github_copilot_username:
            assignees = [settings.github_copilot_username]
        
        # Create GitHub issue
        # NOTE: GitHub milestone support is available but requires:
        # 1. Milestone must exist in GitHub repository first
        # 2. GitHub milestone number (not name) must be used
        # To enable: Add milestone_number field to Milestone model or map by name
        github = GitHubService()
        result = github.create_issue(
            title=task.title,
            body=task.description,
            owner=owner,
            repo=repo,
            labels=labels,
            assignees=assignees
        )
        
        if result.get('success'):
            issue_number = result.get('issue_number')
            
            # Add comment with IdeaGraph reference
            try:
                # Get the host URL from the request
                host = request.get_host()
                scheme = 'https' if request.is_secure() else 'http'
                base_url = f"{scheme}://{host}"
                
                # Construct the link to the task in IdeaGraph
                task_url = f"{base_url}/tasks/{task.id}"
                
                # Create comment body
                comment_body = f"Created with IdeaGraph v1.0\n\nTask: {task_url}"
                
                # Add comment to the issue
                github.create_issue_comment(
                    issue_number=issue_number,
                    body=comment_body,
                    owner=owner,
                    repo=repo
                )
            except Exception as e:
                # Log error but don't fail the whole operation
                import logging
                logger = logging.getLogger(__name__)
                logger.warning(f'Failed to add comment to GitHub issue: {str(e)}')
            
            # Update task with GitHub issue info and assign to GitHub Copilot user
            task.github_issue_id = issue_number
            task.github_issue_url = result.get('url')
            task.github_synced_at = timezone.now()
            
            # Assign task to GitHub Copilot user (keep requester unchanged)
            copilot_user = get_or_create_github_copilot_user()
            task.assigned_to = copilot_user
            
            task.save()
            
            # Create a comment about the GitHub issue creation
            try:
                from core.services.task_comment_service import TaskCommentService
                TaskCommentService.create_github_issue_created_comment(
                    task=task,
                    issue_number=issue_number,
                    issue_url=result.get('url')
                )
            except Exception as e:
                # Log error but don't fail the whole operation
                logger.warning(f'Failed to create GitHub issue comment: {str(e)}')
            
            return JsonResponse({
                'success': True,
                'issue_number': task.github_issue_id,
                'issue_url': task.github_issue_url,
                'message': 'GitHub issue created successfully'
            })
        else:
            return JsonResponse({'error': result.get('error', 'Failed to create GitHub issue')}, status=500)
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except GitHubServiceError as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'GitHub API error: {e.message}')
        return JsonResponse(e.to_dict(), status=e.status_code or 500)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Create GitHub issue error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while creating GitHub issue'}, status=500)


@csrf_exempt
@require_http_methods(["GET"])


@csrf_exempt
@require_http_methods(["GET"])
def api_task_overview(request):
    """
    API endpoint for global task overview with filtering and pagination.
    GET /api/tasks/overview?status=new&item=uuid&has_github=true&query=search&page=1&limit=20
    """
    user = get_user_from_token(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Item
    from django.db.models import Q, Count
    
    try:
        # Base query - show only user's tasks unless admin
        if user.role == 'admin':
            tasks = Task.objects.all()
        else:
            tasks = tasks = Task.objects.filter(created_by=user)
        
        # Apply filters
        status_filter = request.GET.get('status', '').strip()
        if status_filter:
            tasks = tasks.filter(status=status_filter)
        
        item_filter = request.GET.get('item', '').strip()
        if item_filter:
            tasks = tasks.filter(item_id=item_filter)
        
        has_github = request.GET.get('has_github', '').strip().lower()
        if has_github == 'true':
            tasks = tasks.filter(github_issue_id__isnull=False)
        elif has_github == 'false':
            tasks = tasks.filter(github_issue_id__isnull=True)
        
        query = request.GET.get('query', '').strip()
        if query:
            tasks = tasks.filter(
                Q(title__icontains=query) | 
                Q(description__icontains=query)
            )
        
        # Get status counts for badges (before pagination)
        status_counts = {}
        for status_key, status_label in Task.STATUS_CHOICES:
            if user.role == 'admin':
                count = Task.objects.filter(status=status_key).count()
            else:
                count = Task.objects.filter(status=status_key, created_by=user).count()
            status_counts[status_key] = {
                'label': status_label,
                'count': count
            }
        
        # Pagination
        page = int(request.GET.get('page', 1))
        limit = min(int(request.GET.get('limit', 20)), 100)  # Max 100 per page
        
        total_count = tasks.count()
        total_pages = (total_count + limit - 1) // limit if limit > 0 else 1
        
        start_index = (page - 1) * limit
        end_index = start_index + limit
        
        # Get tasks with related data
        tasks = tasks.select_related('item', 'assigned_to', 'created_by').prefetch_related('tags')
        tasks = tasks.order_by('-updated_at')[start_index:end_index]
        
        # Prepare response data
        tasks_data = []
        for task in tasks:
            tasks_data.append({
                'id': str(task.id),
                'title': task.title,
                'description': task.description,
                'status': task.status,
                'status_display': task.get_status_display(),
                'item': {
                    'id': str(task.item.id),
                    'title': task.item.title
                } if task.item else None,
                'github_issue_id': task.github_issue_id,
                'github_issue_url': task.github_issue_url,
                'github_synced_at': task.github_synced_at.isoformat() if task.github_synced_at else None,
                'assigned_to': {
                    'id': str(task.assigned_to.id),
                    'username': task.assigned_to.username
                } if task.assigned_to else None,
                'created_by': {
                    'id': str(task.created_by.id),
                    'username': task.created_by.username
                } if task.created_by else None,
                'created_at': task.created_at.isoformat(),
                'updated_at': task.updated_at.isoformat(),
                'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                'tags': [{'id': str(tag.id), 'name': tag.name, 'color': tag.color} for tag in task.tags.all()],
                'ai_enhanced': task.ai_enhanced,
                'ai_generated': task.ai_generated,
            })
        
        return JsonResponse({
            'success': True,
            'tasks': tasks_data,
            'status_counts': status_counts,
            'pagination': {
                'page': page,
                'limit': limit,
                'total_count': total_count,
                'total_pages': total_pages,
                'has_next': page < total_pages,
                'has_previous': page > 1
            }
        })
        
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Task overview error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while fetching task overview'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_send_item_email(request, item_id):
    """
    API endpoint to send item details via email.
    POST /api/items/{item_id}/send-email
    Body: {"email": "recipient@example.com"}
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Item
    from .mail_utils import send_item_email
    
    try:
        # Get the item
        item = Item.objects.get(id=item_id)
        
        # Check ownership (only owner or admin can send)
        if user.role != 'admin' and item.created_by != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        
        recipient_email = data.get('email', '').strip()
        
        if not recipient_email:
            return JsonResponse({'error': 'Email address is required'}, status=400)
        
        # Validate email format (basic validation)
        if '@' not in recipient_email or '.' not in recipient_email:
            return JsonResponse({'error': 'Invalid email address format'}, status=400)
        
        # Send the email
        success, message = send_item_email(item_id, recipient_email)
        
        if success:
            logger.info(f'Item {item.title} sent via email to {recipient_email} by user {user.username}')
            return JsonResponse({
                'success': True,
                'message': message
            })
        else:
            logger.error(f'Failed to send item {item.title} via email: {message}')
            return JsonResponse({
                'success': False,
                'error': message
            }, status=500)
            
    except Item.DoesNotExist:
        return JsonResponse({'error': 'Item not found'}, status=404)
    except Exception as e:
        logger.error(f'Send item email error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while sending email'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_send_task_email(request, task_id):
    """
    API endpoint to send email from task context with conversation threading.
    POST /api/tasks/{task_id}/send-email
    Body: {
        "email": "recipient@example.com" or "recipient1@example.com,recipient2@example.com",
        "subject": "Email subject",
        "body": "<p>HTML email body</p>",
        "cc": "cc@example.com" or "cc1@example.com,cc2@example.com" (optional),
        "in_reply_to": "<message-id@domain>" (optional)
    }
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    from .mail_utils import send_task_email
    
    try:
        # Get the task
        task = Task.objects.get(id=task_id)
        
        # Check permissions (admin, developer, or task owner can send)
        if user.role not in ['admin', 'developer'] and task.created_by != user and task.assigned_to != user:
            return JsonResponse({'error': 'Access denied'}, status=403)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        
        recipient_email = data.get('email', '').strip()
        subject = data.get('subject', '').strip()
        body = data.get('body', '').strip()
        cc = data.get('cc', '').strip()
        in_reply_to = data.get('in_reply_to', '').strip()
        
        if not recipient_email:
            return JsonResponse({'error': 'Email address is required'}, status=400)
        
        if not subject:
            return JsonResponse({'error': 'Subject is required'}, status=400)
        
        if not body:
            return JsonResponse({'error': 'Body is required'}, status=400)
        
        # Validate email format using Django's EmailValidator
        from django.core.validators import validate_email
        from django.core.exceptions import ValidationError
        
        # Validate all recipient emails
        recipient_emails = [email.strip() for email in recipient_email.split(',') if email.strip()]
        for email in recipient_emails:
            try:
                validate_email(email)
            except ValidationError:
                return JsonResponse({'error': f'Invalid email address format: {email}'}, status=400)
        
        # Validate all CC emails if provided
        if cc:
            cc_emails = [email.strip() for email in cc.split(',') if email.strip()]
            for email in cc_emails:
                try:
                    validate_email(email)
                except ValidationError:
                    return JsonResponse({'error': f'Invalid CC email address format: {email}'}, status=400)
        
        # Send the email
        success, result = send_task_email(
            task_id=task_id,
            recipient_email=recipient_email,
            subject=subject,
            body=body,
            user=user,
            in_reply_to=in_reply_to if in_reply_to else None,
            cc=cc if cc else None
        )
        
        if success:
            logger.info(f'Task email sent to {recipient_email} for task {task.title} by user {user.username}')
            return JsonResponse({
                'success': True,
                'message': 'Email sent successfully',
                'short_id': result.get('short_id') if isinstance(result, dict) else None,
                'message_id': result.get('message_id') if isinstance(result, dict) else None
            })
        else:
            error_msg = result if isinstance(result, str) else result.get('message', 'Unknown error')
            logger.error(f'Failed to send task email for task {task.title}: {error_msg}')
            return JsonResponse({
                'success': False,
                'error': 'Failed to send email'
            }, status=500)
            
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except Exception as e:
        logger.error(f'Send task email error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while sending email'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_process_incoming_email(request):
    """
    API endpoint to process incoming emails and assign to tasks.
    POST /api/emails/process-incoming
    Body: {
        "message": {
            "id": "message-id",
            "subject": "Email subject with [IG-TASK:#XXXXXX]",
            "body": {"content": "<p>HTML body</p>"},
            "from": {"emailAddress": {"address": "sender@example.com", "name": "Sender Name"}},
            "internetMessageHeaders": [...]
        }
    }
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    # Admins and developers can process incoming emails
    if user.role not in ['admin', 'developer']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    from core.services.email_conversation_service import EmailConversationService
    from .models import Settings
    
    try:
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        
        message = data.get('message')
        
        if not message:
            return JsonResponse({'error': 'Message data is required'}, status=400)
        
        # Get settings
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({'error': 'Settings not configured'}, status=500)
        
        # Initialize email conversation service
        email_service = EmailConversationService(settings)
        
        # Process the incoming email
        result = email_service.process_incoming_email(message)
        
        if result.get('success'):
            logger.info(f"Incoming email processed successfully: {result}")
            return JsonResponse(result)
        else:
            logger.warning(f"Failed to process incoming email: {result}")
            # Don't expose detailed error information
            return JsonResponse({
                'success': False,
                'message': 'Failed to process email'
            }, status=400)
            
    except Exception as e:
        logger.error(f'Process incoming email error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while processing email'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_bulk_delete(request):
    """
    API endpoint for bulk task deletion.
    POST /api/tasks/bulk-delete
    Body: {"task_ids": ["uuid1", "uuid2", ...]}
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Settings
    from django.core.exceptions import ValidationError
    
    try:
        data = json.loads(request.body)
        task_ids = data.get('task_ids', [])
        
        if not task_ids:
            return JsonResponse({'error': 'No task IDs provided'}, status=400)
        
        if not isinstance(task_ids, list):
            return JsonResponse({'error': 'task_ids must be a list'}, status=400)
        
        # Validate UUIDs
        valid_task_ids = []
        for task_id in task_ids:
            try:
                import uuid
                uuid.UUID(str(task_id))
                valid_task_ids.append(task_id)
            except (ValueError, AttributeError):
                # Skip invalid UUIDs
                pass
        
        if not valid_task_ids:
            return JsonResponse({'error': 'No valid task IDs provided'}, status=400)
        
        # Get all tasks by ID (authentication already verified)
        # Note: No created_by filter to match single task delete behavior
        # Any authenticated user can delete tasks, same as individual deletion
        tasks = Task.objects.filter(id__in=valid_task_ids)
        
        if not tasks.exists():
            return JsonResponse({'error': 'No tasks found'}, status=404)
        
        # Store task IDs for Weaviate sync before deletion
        deleted_task_ids = [str(task.id) for task in tasks]
        deleted_count = tasks.count()
        
        # Delete tasks
        tasks.delete()
        
        # Sync with Weaviate
        try:
            settings = Settings.objects.first()
            if settings:
                sync_service = WeaviateTaskSyncService(settings)
                for task_id in deleted_task_ids:
                    try:
                        sync_service.sync_delete(task_id)
                    except Exception as sync_error:
                        logger.warning(f'Weaviate sync failed for task {task_id}: {str(sync_error)}')
        except Exception as e:
            logger.warning(f'Weaviate sync error: {str(e)}')
        
        logger.info(f'User {user.username} deleted {deleted_count} task(s)')
        
        return JsonResponse({
            'success': True,
            'message': f'{deleted_count} task(s) deleted successfully',
            'deleted_count': deleted_count
        })
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Bulk delete error: {str(e)}')
        return JsonResponse({'error': 'An error occurred while deleting tasks'}, status=500)


@csrf_exempt
@require_http_methods(['POST'])
def api_task_move(request, task_id):
    """
    API endpoint to move a task to a different item
    
    Expects JSON body:
    {
        "target_item_id": "uuid-of-target-item"
    }
    
    Returns:
    {
        "success": true,
        "message": "Task moved successfully",
        "moved": true,
        "files_moved": true,
        "files_count": 2
    }
    """
    from .models import Task, Item, Settings, User
    from core.services.task_move_service import TaskMoveService, TaskMoveServiceError
    
    try:
        # Get current user from session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        try:
            user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        
        # Validate required fields
        target_item_id = data.get('target_item_id')
        if not target_item_id:
            return JsonResponse({'error': 'target_item_id is required'}, status=400)
        
        # Verify task exists
        try:
            task = Task.objects.get(id=task_id)
        except Task.DoesNotExist:
            return JsonResponse({'error': 'Task not found'}, status=404)
        
        # Check permissions - user must be the creator or admin
        if user.role != 'admin' and task.created_by != user:
            return JsonResponse({'error': 'Permission denied'}, status=403)
        
        # Initialize move service
        try:
            settings = Settings.objects.first()
            move_service = TaskMoveService(settings)
        except Exception as e:
            logger.error(f'Failed to initialize TaskMoveService: {str(e)}')
            return JsonResponse({
                'error': 'Service initialization failed'
            }, status=500)
        
        # Perform the move
        try:
            result = move_service.move_task(
                task_id=str(task_id),
                target_item_id=str(target_item_id),
                user=user
            )
            
            logger.info(f'Task {task_id} moved by user {user.username}')
            return JsonResponse(result)
            
        except TaskMoveServiceError as e:
            logger.error(f'Task move failed: {e.message}')
            return JsonResponse({
                'error': e.message
            }, status=400)
    
    except Exception as e:
        logger.error(f'Task move error: {str(e)}')
        return JsonResponse({
            'error': 'An error occurred while moving the task'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_support_analysis_internal(request, task_id):
    """
    API endpoint to perform internal support analysis for a task using Weaviate knowledge base
    
    POST /api/tasks/{task_id}/support-analysis-internal
    Body: {"description": "..."}
    
    Uses SupportAdvisorService with internal mode (Weaviate RAG)
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use SupportAdvisorService for internal analysis
        advisor = SupportAdvisorService()
        
        result = advisor.analyze_internal(
            task_description=description,
            task_title=task.title,
            user_id=str(user.id),
            max_results=5
        )
        
        return JsonResponse(result)
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except SupportAdvisorServiceError as e:
        logger.error(f'Support analysis error: {e.message}')
        return JsonResponse(e.to_dict(), status=500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Internal support analysis error: {str(e)}')
        return JsonResponse({
            'error': 'An error occurred during internal support analysis'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_support_analysis_external(request, task_id):
    """
    API endpoint to perform external support analysis for a task using web search
    
    POST /api/tasks/{task_id}/support-analysis-external
    Body: {"description": "..."}
    
    Uses SupportAdvisorService with external mode (Web Search + AI)
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        description = data.get('description', '').strip()
        
        if not description:
            return JsonResponse({'error': 'Description is required'}, status=400)
        
        # Use SupportAdvisorService for external analysis
        advisor = SupportAdvisorService()
        
        result = advisor.analyze_external(
            task_description=description,
            task_title=task.title,
            user_id=str(user.id),
            max_results=5
        )
        
        return JsonResponse(result)
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except SupportAdvisorServiceError as e:
        logger.error(f'Support analysis error: {e.message}')
        return JsonResponse(e.to_dict(), status=500)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'External support analysis error: {str(e)}')
        return JsonResponse({
            'error': 'An error occurred during external support analysis'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_support_analysis_save(request, task_id):
    """
    API endpoint to save support analysis results
    
    POST /api/tasks/{task_id}/support-analysis-save
    Body: {
        "analysis": "markdown content",
        "mode": "internal" or "external"
    }
    
    Saves the analysis result as:
    - Markdown file uploaded to SharePoint
    - KnowledgeObject in Weaviate
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task, Settings
    from datetime import datetime
    from core.services.weaviate_sync_service import WeaviateItemSyncService
    
    try:
        task = Task.objects.get(id=task_id)
        
        data = json.loads(request.body)
        analysis = data.get('analysis', '').strip()
        mode = data.get('mode', 'internal')
        
        if not analysis:
            return JsonResponse({'error': 'Analysis content is required'}, status=400)
        
        # Generate filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        mode_prefix = 'intern' if mode == 'internal' else 'extern'
        filename = f"Support_Analyse_{mode_prefix}_{timestamp}.md"
        
        # Convert analysis to bytes
        file_content = analysis.encode('utf-8')
        
        # Upload file to SharePoint using TaskFileService
        try:
            file_service = TaskFileService()
            upload_result = file_service.upload_file(
                task=task,
                file_content=file_content,
                filename=filename,
                content_type='text/markdown',
                user=user
            )
            
            if not upload_result['success']:
                return JsonResponse({
                    'success': False,
                    'error': 'Failed to upload file to SharePoint',
                    'details': upload_result.get('error', '')
                }, status=500)
            
            logger.info(f"Support analysis saved as file: {filename}")
            
        except TaskFileServiceError as e:
            logger.error(f'File upload error: {e.message}')
            return JsonResponse({
                'success': False,
                'error': 'Failed to save analysis file',
                'details': e.details
            }, status=500)
        
        # Save to Weaviate as KnowledgeObject
        try:
            settings = Settings.objects.first()
            weaviate_service = WeaviateItemSyncService(settings)
            
            # Get collection
            collection = weaviate_service._client.collections.get(weaviate_service.COLLECTION_NAME)
            
            # Create metadata for KnowledgeObject
            import uuid
            analysis_id = str(uuid.uuid4())
            
            properties = {
                'type': 'SupportAnalysis',
                'title': f"Support-Analyse: {task.title}",
                'description': analysis,
                'section': '',
                'owner': user.username,
                'status': 'completed',
                'createdAt': datetime.now().isoformat(),
                'tags': [mode, 'support-analysis'],
                'url': f'/tasks/{task.id}/',
                'parent_id': str(task.id),
                'context_inherited': True,
            }
            
            # Add to Weaviate
            collection.data.insert(
                properties=properties,
                uuid=analysis_id
            )
            
            logger.info(f"Support analysis saved to Weaviate: {analysis_id}")
            
        except Exception as e:
            logger.warning(f'Failed to save to Weaviate: {str(e)}')
            # Don't fail the request if Weaviate fails, file was already saved
        
        return JsonResponse({
            'success': True,
            'message': 'Analysis saved successfully',
            'filename': filename,
            'sharepoint_url': upload_result.get('sharepoint_url', ''),
            'file_id': upload_result.get('file_id', '')
        })
        
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Save support analysis error: {str(e)}')
        return JsonResponse({
            'error': 'An error occurred while saving analysis'
        }, status=500)


@csrf_exempt
@require_http_methods(['GET'])
def api_tags_network_data(request):
    """
    API endpoint to fetch network graph data for tags, items, and tasks.
    Returns nodes and edges for visualization.
    Only shows items and tasks owned by the current user, and only tags linked to those items/tasks.
    """
    try:
        from .models import Tag, Item, Task, User
        
        nodes = []
        edges = []
        
        # Get current user from session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        try:
            current_user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Filter items by current user ownership
        items = Item.objects.filter(created_by=current_user).prefetch_related('tags')
        
        # Add item nodes and edges to tags
        for item in items:
            # Truncate title if too long
            label = item.title[:25] + '...' if len(item.title) > 25 else item.title
            
            # Determine color based on status
            status_colors = {
                'new': '#6366f1',          # Indigo
                'spec_review': '#8b5cf6',  # Violet
                'working': '#f59e0b',      # Amber
                'ready': '#22c55e',        # Green
                'done': '#10b981',         # Emerald
                'rejected': '#ef4444',     # Red
            }
            
            nodes.append({
                'id': f'item-{item.id}',
                'label': label,
                'title': f'{item.title}\nStatus: {item.get_status_display()}',
                'group': 'item',
                'color': status_colors.get(item.status, '#3b82f6'),
                'shape': 'box',
                'size': 40,
                'font': {'size': 12, 'color': '#ffffff'},
                'url': f'/items/{item.id}/'
            })
            
            # Create edges from item to its tags
            for tag in item.tags.all():
                edges.append({
                    'from': f'tag-{tag.id}',
                    'to': f'item-{item.id}',
                    'color': {'color': tag.color, 'opacity': 0.5},
                    'width': 2
                })
        
        # Filter tasks by current user ownership
        tasks = Task.objects.filter(created_by=current_user).prefetch_related('tags', 'item')
        
        # Collect all tag IDs that are actually used by items or tasks
        used_tag_ids = set()
        for item in items:
            used_tag_ids.update(item.tags.values_list('id', flat=True))
        for task in tasks:
            used_tag_ids.update(task.tags.values_list('id', flat=True))
        
        # Add tag nodes only for tags that are linked to items or tasks
        tags = Tag.objects.filter(id__in=used_tag_ids)
        for tag in tags:
            nodes.append({
                'id': f'tag-{tag.id}',
                'label': tag.name[:20] + '...' if len(tag.name) > 20 else tag.name,
                'title': tag.name,  # Full name on hover
                'group': 'tag',
                'color': tag.color,
                'shape': 'dot',
                'size': 15,
                'font': {'size': 14, 'color': '#ffffff'}
            })
        
        # Add task nodes and edges to items/tags
        for task in tasks:
            # Truncate title if too long
            label = task.title[:20] + '...' if len(task.title) > 20 else task.title
            
            # Determine color based on status
            task_status_colors = {
                'new': '#6366f1',      # Indigo
                'working': '#f59e0b',  # Amber
                'review': '#8b5cf6',   # Violet
                'ready': '#22c55e',    # Green
                'done': '#10b981',     # Emerald
            }
            
            nodes.append({
                'id': f'task-{task.id}',
                'label': label,
                'title': f'{task.title}\nStatus: {task.get_status_display()}',
                'group': 'task',
                'color': task_status_colors.get(task.status, '#3b82f6'),
                'shape': 'diamond',
                'size': 15,
                'font': {'size': 10, 'color': '#ffffff'},
                'url': f'/tasks/{task.id}/'
            })
            
            # Create edge from task to its item
            if task.item:
                edges.append({
                    'from': f'item-{task.item.id}',
                    'to': f'task-{task.id}',
                    'color': {'color': '#9ca3af', 'opacity': 0.4},
                    'width': 1.5,
                    'dashes': True
                })
            
            # Create edges from task to its tags
            for tag in task.tags.all():
                edges.append({
                    'from': f'tag-{tag.id}',
                    'to': f'task-{task.id}',
                    'color': {'color': tag.color, 'opacity': 0.3},
                    'width': 1,
                    'dashes': True
                })
        
        return JsonResponse({
            'success': True,
            'nodes': nodes,
            'edges': edges
        })
    
    except Exception as e:
        logger.error(f'Error fetching tags network data: {str(e)}')
        return JsonResponse({'error': 'Failed to load network data'}, status=500)


@require_http_methods(["GET"])
def api_semantic_network(request, object_type, object_id):
    """
    Generate semantic network for an object (Item, Task, etc.)
    
    Query parameters:
        - depth: Network depth (1-3, default: 3)
        - threshold_1: Similarity threshold for level 1 (default: 0.8)
        - threshold_2: Similarity threshold for level 2 (default: 0.7)
        - threshold_3: Similarity threshold for level 3 (default: 0.6)
        - summaries: Generate AI summaries ('true'/'false', default: 'true')
        - include_hierarchy: Include parent-child relationships ('true'/'false', default: 'false')
    
    Returns:
        JSON response with:
            - nodes: List of graph nodes
            - edges: List of graph edges
            - levels: Level-by-level breakdown with summaries
            - source_id: ID of the source object
            - hierarchy: Parent and child relationships (if include_hierarchy=true)
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        logger.warning(f'Unauthenticated request to semantic network API')
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.semantic_network_service import SemanticNetworkService, SemanticNetworkServiceError
        
        # Parse query parameters
        depth = int(request.GET.get('depth', 3))
        generate_summaries = request.GET.get('summaries', 'true').lower() == 'true'
        include_hierarchy = request.GET.get('include_hierarchy', 'false').lower() == 'true'
        
        logger.info(f'Semantic network request: object_type={object_type}, object_id={object_id}, depth={depth}, summaries={generate_summaries}, hierarchy={include_hierarchy}')
        
        # Custom thresholds if provided
        thresholds = {}
        for level in [1, 2, 3]:
            threshold_key = f'threshold_{level}'
            if threshold_key in request.GET:
                try:
                    thresholds[level] = float(request.GET[threshold_key])
                except ValueError:
                    pass
        
        # Generate semantic network
        service = SemanticNetworkService()
        try:
            result = service.generate_network(
                object_type=object_type,
                object_id=str(object_id),
                depth=depth,
                user_id=str(user.id),
                thresholds=thresholds if thresholds else None,
                generate_summaries=generate_summaries,
                include_hierarchy=include_hierarchy
            )
            
            logger.info(f'Semantic network generated successfully: {len(result.get("nodes", []))} nodes, {len(result.get("edges", []))} edges')
            return JsonResponse(result)
            
        finally:
            service.close()
    
    except SemanticNetworkServiceError as e:
        logger.error(f'Semantic network service error for {object_type}/{object_id}: {str(e)}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Unexpected error generating semantic network for {object_type}/{object_id}: {str(e)}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': 'Failed to generate semantic network',
            'details': str(e)
        }, status=500)


def api_milestone_semantic_network(request, milestone_id):
    """
    Generate semantic network for a milestone
    
    Query parameters:
        - depth: Network depth (1-3, default: 3)
        - threshold_1: Similarity threshold for level 1 (default: 0.8)
        - threshold_2: Similarity threshold for level 2 (default: 0.7)
        - threshold_3: Similarity threshold for level 3 (default: 0.6)
        - summaries: Generate AI summaries ('true'/'false', default: 'true')
    
    Returns:
        JSON response with semantic network data
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        logger.warning(f'Unauthenticated request to milestone semantic network API')
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from main.models import Milestone
        from core.services.semantic_network_service import SemanticNetworkService, SemanticNetworkServiceError
        
        # Verify milestone exists
        try:
            milestone = Milestone.objects.get(id=milestone_id)
        except Milestone.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Milestone not found'
            }, status=404)
        
        # Parse query parameters
        depth = int(request.GET.get('depth', 3))
        generate_summaries = request.GET.get('summaries', 'true').lower() == 'true'
        
        logger.info(f'Milestone semantic network request: milestone_id={milestone_id}, depth={depth}, summaries={generate_summaries}')
        
        # Custom thresholds if provided
        thresholds = {}
        for level in [1, 2, 3]:
            threshold_key = f'threshold_{level}'
            if threshold_key in request.GET:
                try:
                    thresholds[level] = float(request.GET[threshold_key])
                except ValueError:
                    pass
        
        # Generate semantic network
        service = SemanticNetworkService()
        try:
            result = service.generate_network(
                object_type='milestone',
                object_id=str(milestone_id),
                depth=depth,
                user_id=str(user.id),
                thresholds=thresholds if thresholds else None,
                generate_summaries=generate_summaries,
                include_hierarchy=False  # Milestones don't have hierarchical relationships
            )
            
            logger.info(f'Milestone semantic network generated successfully: {len(result.get("nodes", []))} nodes, {len(result.get("edges", []))} edges')
            return JsonResponse(result)
            
        finally:
            service.close()
    
    except SemanticNetworkServiceError as e:
        logger.error(f'Semantic network service error for milestone/{milestone_id}: {str(e)}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Unexpected error generating semantic network for milestone/{milestone_id}: {str(e)}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': 'Failed to generate semantic network'
        }, status=500)


# File Upload API Endpoints

@csrf_exempt
@require_http_methods(["POST"])
def api_item_file_upload(request, item_id):
    """
    Upload one or more files for an item
    
    Supports both JSON API responses and htmx responses.
    For htmx requests, returns the updated file list after upload.
    
    POST data:
        - file: Single file upload (legacy)
        - files: Multiple file uploads
    
    Returns:
        - HTML partial with updated file list for htmx requests
        - JSON response with upload result for regular API requests
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from main.models import Item
        from core.services.item_file_service import ItemFileService, ItemFileServiceError
        from django.shortcuts import render
        
        # Get item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Item not found'})
            return JsonResponse({
                'success': False,
                'error': 'Item not found'
            }, status=404)
        
        # Check permission
        if user.role != 'admin' and item.created_by != user:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Permission denied'})
            return JsonResponse({
                'success': False,
                'error': 'You do not have permission to upload files for this item'
            }, status=403)
        
        # Get uploaded files - support both 'file' (single) and 'files' (multiple)
        uploaded_files = []
        if 'files' in request.FILES:
            uploaded_files = request.FILES.getlist('files')
        elif 'file' in request.FILES:
            uploaded_files = [request.FILES['file']]
        
        if not uploaded_files:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'No files provided'})
            return JsonResponse({
                'success': False,
                'error': 'No files provided'
            }, status=400)
        
        # Upload all files
        service = ItemFileService()
        upload_results = []
        errors = []
        
        for uploaded_file in uploaded_files:
            try:
                # Read file content
                file_content = uploaded_file.read()
                filename = uploaded_file.name
                content_type = uploaded_file.content_type or 'application/octet-stream'
                
                # Upload file
                result = service.upload_file(
                    item=item,
                    file_content=file_content,
                    filename=filename,
                    content_type=content_type,
                    user=user
                )
                
                upload_results.append(result)
                logger.info(f'File uploaded for item {item_id}: {filename}')
            except ItemFileServiceError as e:
                logger.error(f'File upload error for {uploaded_file.name}: {str(e)}')
                errors.append(f'{uploaded_file.name}: {e.message}')
            except Exception as e:
                logger.error(f'Error uploading file {uploaded_file.name}: {str(e)}')
                errors.append(f'{uploaded_file.name}: Failed to upload')
        
        # For htmx requests, return updated file list
        if request.headers.get('HX-Request'):
            # Fetch updated file list with pagination
            page = request.GET.get('page', 1)
            list_result = service.list_files(str(item_id), page=page, per_page=20)
            
            context = {
                'files': list_result.get('files', []),
                'page': list_result.get('page', 1),
                'total_pages': list_result.get('total_pages', 1),
                'total_count': list_result.get('total_count', 0),
                'item_id': item_id,
            }
            
            # Add error message if any
            if errors:
                context['error'] = f'Some files failed to upload: {"; ".join(errors)}'
            
            return render(request, 'main/items/_files_list.html', context)
        
        # For regular API requests, return JSON
        return JsonResponse({
            'success': True,
            'uploaded': len(upload_results),
            'failed': len(errors),
            'results': upload_results,
            'errors': errors
        })
    
    except ItemFileServiceError as e:
        logger.error(f'File upload error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error uploading files: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Failed to upload files'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to upload files'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_item_file_list(request, item_id):
    """
    List all files for an item with pagination
    
    Supports both JSON API responses and htmx HTML partial responses.
    
    Query parameters:
        - page: Page number (default: 1)
        - per_page: Items per page (default: 20)
    
    Returns:
        - HTML partial template for htmx requests
        - JSON response with list of files for regular API requests
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        # For htmx requests, return error HTML
        if request.headers.get('HX-Request'):
            from django.shortcuts import render
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Authentication required'})
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from main.models import Item
        from core.services.item_file_service import ItemFileService, ItemFileServiceError
        from django.shortcuts import render
        
        # Get item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Item not found'})
            return JsonResponse({
                'success': False,
                'error': 'Item not found'
            }, status=404)
        
        # Check permission
        if user.role != 'admin' and item.created_by != user:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Permission denied'})
            return JsonResponse({
                'success': False,
                'error': 'You do not have permission to view files for this item'
            }, status=403)
        
        # Get pagination parameters
        page = request.GET.get('page', 1)
        try:
            page = int(page)
        except (ValueError, TypeError):
            page = 1
        
        per_page = request.GET.get('per_page', 20)
        try:
            per_page = int(per_page)
        except (ValueError, TypeError):
            per_page = 20
        
        # List files with pagination
        service = ItemFileService()
        result = service.list_files(str(item_id), page=page, per_page=per_page)
        
        # For htmx requests, return HTML partial
        if request.headers.get('HX-Request'):
            context = {
                'files': result.get('files', []),
                'page': result.get('page', 1),
                'total_pages': result.get('total_pages', 1),
                'total_count': result.get('total_count', 0),
                'item_id': item_id,
            }
            return render(request, 'main/items/_files_list.html', context)
        
        # For regular API requests, return JSON
        return JsonResponse(result)
    
    except ItemFileServiceError as e:
        logger.error(f'File list error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error listing files: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Failed to list files'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to list files'
        }, status=500)


@csrf_exempt
@require_http_methods(["DELETE"])
def api_item_file_delete(request, file_id):
    """
    Delete a file
    
    Supports both JSON API responses and htmx responses.
    For htmx requests, triggers a file list refresh after deletion.
    
    Returns:
        - HTML partial with updated file list for htmx requests
        - JSON response with deletion result for regular API requests
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.item_file_service import ItemFileService, ItemFileServiceError
        from main.models import ItemFile
        from django.shortcuts import render
        
        # Get item_id before deleting the file (for htmx refresh)
        try:
            item_file = ItemFile.objects.get(id=file_id)
            item_id = str(item_file.item.id)
        except ItemFile.DoesNotExist:
            if request.headers.get('HX-Request'):
                return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'File not found'})
            return JsonResponse({
                'success': False,
                'error': 'File not found'
            }, status=404)
        
        # Delete file
        service = ItemFileService()
        result = service.delete_file(file_id, user)
        
        logger.info(f'File deleted: {file_id}')
        
        # For htmx requests, return updated file list
        if request.headers.get('HX-Request'):
            # Fetch updated file list
            list_result = service.list_files(item_id)
            # Return HTML partial with updated file list
            return render(request, 'main/items/_files_list.html', {'files': list_result.get('files', [])})
        
        # For regular API requests, return JSON
        return JsonResponse(result)
    
    except ItemFileServiceError as e:
        logger.error(f'File delete error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error deleting file: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {'files': [], 'error': 'Failed to delete file'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to delete file'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_item_file_download(request, file_id):
    """
    Get download URL for a file
    
    Returns:
        JSON response with download URL
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.item_file_service import ItemFileService, ItemFileServiceError
        
        # Get download URL
        service = ItemFileService()
        result = service.get_download_url(file_id, user)
        
        return JsonResponse(result)
    
    except ItemFileServiceError as e:
        logger.error(f'File download error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error getting download URL: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to get download URL'
        }, status=500)


@require_http_methods(["GET"])
def api_item_file_markdown_content(request, file_id):
    """
    Get markdown content for inline viewing
    
    Returns:
        JSON response with markdown content
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.item_file_service import ItemFileService, ItemFileServiceError
        
        # Get markdown content
        service = ItemFileService()
        result = service.get_markdown_content(file_id, user)
        
        return JsonResponse(result)
    
    except ItemFileServiceError as e:
        logger.error(f'Markdown content error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error getting markdown content: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to get markdown content'
        }, status=500)


# ==================== Zammad Integration API ====================

@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_zammad_test_connection(request):
    """
    Test connection to Zammad API
    POST /api/zammad/test-connection
    
    Returns:
        JSON response with connection status
    """
    try:
        from core.services.zammad_sync_service import ZammadSyncService, ZammadSyncServiceError
        
        service = ZammadSyncService()
        result = service.test_connection()
        
        return JsonResponse(result)
    
    except ZammadSyncServiceError as e:
        logger.error(f'Zammad connection test error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error testing Zammad connection: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to test connection'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
@require_admin
def api_zammad_sync(request):
    """
    Manually trigger Zammad ticket synchronization
    POST /api/zammad/sync
    Body (optional): {"groups": ["Group1", "Group2"]}
    
    Returns:
        JSON response with sync results
    """
    try:
        from core.services.zammad_sync_service import ZammadSyncService, ZammadSyncServiceError
        
        # Parse optional group filter
        groups = None
        if request.body:
            try:
                data = json.loads(request.body)
                groups = data.get('groups')
            except json.JSONDecodeError:
                pass
        
        service = ZammadSyncService()
        
        if groups:
            # Fetch and sync specific groups
            tickets = service.fetch_open_tickets(groups)
            
            results = {
                'success': True,
                'total_tickets': len(tickets),
                'created': 0,
                'updated': 0,
                'failed': 0,
                'errors': []
            }
            
            for ticket in tickets:
                result = service.sync_ticket_to_task(ticket)
                if result.get('success'):
                    if result.get('action') == 'created':
                        results['created'] += 1
                    elif result.get('action') == 'updated':
                        results['updated'] += 1
                else:
                    results['failed'] += 1
                    results['errors'].append({
                        'ticket_id': result.get('ticket_id'),
                        'error': result.get('error')
                    })
        else:
            # Sync all configured groups
            results = service.sync_all_tickets()
        
        return JsonResponse(results)
    
    except ZammadSyncServiceError as e:
        logger.error(f'Zammad sync error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error syncing Zammad tickets: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to sync tickets'
        }, status=500)


@require_http_methods(["GET"])
@require_admin
def api_zammad_status(request):
    """
    Get Zammad synchronization status
    GET /api/zammad/status
    
    Returns:
        JSON response with sync status and statistics
    """
    try:
        from main.models import Task, Settings
        
        # Get settings
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({
                'success': False,
                'error': 'Settings not found'
            }, status=404)
        
        # Get statistics about Zammad-synced tasks
        zammad_tasks = Task.objects.filter(type='ticket').exclude(external_id='')
        
        total_tasks = zammad_tasks.count()
        new_tasks = zammad_tasks.filter(status='new').count()
        working_tasks = zammad_tasks.filter(status='working').count()
        done_tasks = zammad_tasks.filter(status='done').count()
        
        # Get last synced task
        last_synced = zammad_tasks.order_by('-updated_at').first()
        last_sync_time = last_synced.updated_at.isoformat() if last_synced else None
        
        return JsonResponse({
            'success': True,
            'enabled': settings.zammad_enabled,
            'api_url': settings.zammad_api_url,
            'configured_groups': [g.strip() for g in settings.zammad_groups.split(',') if g.strip()],
            'sync_interval_minutes': settings.zammad_sync_interval,
            'statistics': {
                'total_tasks': total_tasks,
                'new': new_tasks,
                'working': working_tasks,
                'done': done_tasks,
                'last_sync': last_sync_time
            }
        })
    
    except Exception as e:
        logger.error(f'Error getting Zammad status: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to get status'
        }, status=500)


# ==================== Task File Upload API ====================

@csrf_exempt
@require_http_methods(["POST"])
def api_task_file_upload(request, task_id):
    """
    Upload a file to a task
    
    Uploads file to SharePoint under: IdeaGraph/{item_title}/{task_uuid}/
    or IdeaGraph/Tasks/{task_uuid}/ for standalone tasks
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.task_file_service import TaskFileService, TaskFileServiceError
        from main.models import Task
        from django.shortcuts import render
        
        # Get task
        try:
            task = Task.objects.get(id=task_id)
        except Task.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Task not found'
            }, status=404)
        
        # Get uploaded file
        if 'file' not in request.FILES:
            return JsonResponse({
                'success': False,
                'error': 'No file provided'
            }, status=400)
        
        uploaded_file = request.FILES['file']
        
        # Read file content
        file_content = uploaded_file.read()
        filename = uploaded_file.name
        content_type = uploaded_file.content_type or 'application/octet-stream'
        
        # Upload file
        service = TaskFileService()
        result = service.upload_file(
            task=task,
            file_content=file_content,
            filename=filename,
            content_type=content_type,
            user=user
        )
        
        logger.info(f'File uploaded: {filename} for task {task_id}')
        
        # For htmx requests, return updated file list
        if request.headers.get('HX-Request'):
            # Fetch updated file list
            list_result = service.list_files(task_id)
            # Return HTML partial with updated file list
            return render(request, 'main/tasks/_files_list.html', {'files': list_result.get('files', [])})
        
        # For regular API requests, return JSON
        return JsonResponse(result)
    
    except TaskFileServiceError as e:
        logger.error(f'File upload error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error uploading file: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': 'Failed to upload file'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to upload file'
        }, status=500)


@require_http_methods(["GET"])
def api_task_file_list(request, task_id):
    """
    List files for a task
    
    Returns:
        JSON response with list of files or HTML partial for htmx
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.task_file_service import TaskFileService, TaskFileServiceError
        from django.shortcuts import render
        
        # List files
        service = TaskFileService()
        result = service.list_files(task_id)
        
        # For htmx requests, return HTML partial
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': result.get('files', [])})
        
        # For regular API requests, return JSON
        return JsonResponse(result)
    
    except TaskFileServiceError as e:
        logger.error(f'File list error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error listing files: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': 'Failed to list files'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to list files'
        }, status=500)


@csrf_exempt
@require_http_methods(["DELETE", "POST"])
def api_task_file_delete(request, file_id):
    """
    Delete a file
    
    Returns:
        JSON response with success status or HTML partial for htmx
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.task_file_service import TaskFileService, TaskFileServiceError
        from main.models import TaskFile
        from django.shortcuts import render
        
        # Get task_id before deleting the file (for htmx refresh)
        try:
            task_file = TaskFile.objects.get(id=file_id)
            task_id = str(task_file.task.id)
        except TaskFile.DoesNotExist:
            if request.headers.get('HX-Request'):
                return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': 'File not found'})
            return JsonResponse({
                'success': False,
                'error': 'File not found'
            }, status=404)
        
        # Delete file
        service = TaskFileService()
        result = service.delete_file(file_id, user)
        
        logger.info(f'File deleted: {file_id}')
        
        # For htmx requests, return updated file list
        if request.headers.get('HX-Request'):
            # Fetch updated file list
            list_result = service.list_files(task_id)
            # Return HTML partial with updated file list
            return render(request, 'main/tasks/_files_list.html', {'files': list_result.get('files', [])})
        
        # For regular API requests, return JSON
        return JsonResponse(result)
    
    except TaskFileServiceError as e:
        logger.error(f'File delete error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': e.message})
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error deleting file: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {'files': [], 'error': 'Failed to delete file'})
        return JsonResponse({
            'success': False,
            'error': 'Failed to delete file'
        }, status=500)


@require_http_methods(["GET"])
def api_task_file_download(request, file_id):
    """
    Get download URL for a file
    
    Returns:
        JSON response with download URL
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.task_file_service import TaskFileService, TaskFileServiceError
        
        # Get download URL
        service = TaskFileService()
        result = service.get_download_url(file_id, user)
        
        return JsonResponse(result)
    
    except TaskFileServiceError as e:
        logger.error(f'File download error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error getting download URL: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to get download URL'
        }, status=500)


@require_http_methods(["GET"])
def api_task_file_markdown_content(request, file_id):
    """
    Get markdown content for inline viewing
    
    Returns:
        JSON response with markdown content
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.task_file_service import TaskFileService, TaskFileServiceError
        
        # Get markdown content
        service = TaskFileService()
        result = service.get_markdown_content(file_id, user)
        
        return JsonResponse(result)
    
    except TaskFileServiceError as e:
        logger.error(f'Markdown content error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error getting markdown content: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to get markdown content'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_process_link(request, task_id):
    """
    Process a link URL: download, clean, AI process, and save as task file
    
    POST /api/tasks/{task_id}/process-link
    
    Body (JSON):
        {
            "url": "https://example.com/article"
        }
    
    Returns:
        JSON response with success status or HTML partial for htmx
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.link_content_service import LinkContentService, LinkContentServiceError
        from core.services.task_file_service import TaskFileService
        from main.models import Task
        from django.shortcuts import render
        
        # Get task
        try:
            task = Task.objects.get(id=task_id)
        except Task.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Task not found'
            }, status=404)
        
        # Parse request body
        try:
            data = json.loads(request.body)
            url = data.get('url', '').strip()
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Invalid JSON in request body'
            }, status=400)
        
        # Validate URL
        if not url:
            return JsonResponse({
                'success': False,
                'error': 'URL is required'
            }, status=400)
        
        # Process link
        logger.info(f'Processing link for task {task_id}: {url}')
        service = LinkContentService()
        result = service.process_link(
            task=task,
            url=url,
            user=user
        )
        
        logger.info(f'Link processed successfully: {url}')
        
        # For htmx requests, return updated file list
        if request.headers.get('HX-Request'):
            # Fetch updated file list
            file_service = TaskFileService()
            list_result = file_service.list_files(task_id)
            # Return HTML partial with updated file list
            return render(request, 'main/tasks/_files_list.html', {
                'files': list_result.get('files', []),
                'success_message': result.get('message')
            })
        
        # For regular API requests, return JSON
        return JsonResponse({
            'success': True,
            'message': result.get('message'),
            'title': result.get('title'),
            'file_id': str(result.get('file').id) if result.get('file') else None
        })
    
    except LinkContentServiceError as e:
        logger.error(f'Link processing error: {str(e)}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {
                'files': [],
                'error': f"{e.message}: {e.details}" if e.details else e.message
            })
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        # Log the full exception with traceback for debugging
        logger.error(f'Unexpected error processing link for task {task_id}: {str(e)}\n{traceback.format_exc()}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/tasks/_files_list.html', {
                'files': [],
                'error': 'Failed to process link. Please check the server logs for details.'
            })
        return JsonResponse({
            'success': False,
            'error': 'Failed to process link',
            'details': 'An unexpected error occurred. Please check the server logs.'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_item_process_link(request, item_id):
    """
    Process a link URL: download, clean, AI process, and save as item file
    
    POST /api/items/{item_id}/process-link
    
    Body (JSON):
        {
            "url": "https://example.com/article"
        }
    
    Returns:
        JSON response with success status or HTML partial for htmx
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from core.services.link_content_service import LinkContentService, LinkContentServiceError
        from core.services.item_file_service import ItemFileService
        from main.models import Item
        from django.shortcuts import render
        
        # Get item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Item not found'
            }, status=404)
        
        # Parse request body
        try:
            data = json.loads(request.body)
            url = data.get('url', '').strip()
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Invalid JSON in request body'
            }, status=400)
        
        # Validate URL
        if not url:
            return JsonResponse({
                'success': False,
                'error': 'URL is required'
            }, status=400)
        
        # Process link
        logger.info(f'Processing link for item {item_id}: {url}')
        service = LinkContentService()
        result = service.process_link_for_item(
            item=item,
            url=url,
            user=user
        )
        
        logger.info(f'Link processed successfully: {url}')
        
        # For htmx requests, return updated file list
        if request.headers.get('HX-Request'):
            # Fetch updated file list
            file_service = ItemFileService()
            list_result = file_service.list_files(item_id)
            # Return HTML partial with updated file list
            return render(request, 'main/items/_files_list.html', {
                'files': list_result.get('files', []),
                'item_id': item_id,
                'page': 1,
                'total_pages': list_result.get('total_pages', 1),
                'total_count': list_result.get('total_count', 0),
                'success_message': result.get('message')
            })
        
        # For regular API requests, return JSON
        return JsonResponse({
            'success': True,
            'message': result.get('message'),
            'title': result.get('title'),
            'file_id': str(result.get('file').id) if result.get('file') else None
        })
    
    except LinkContentServiceError as e:
        logger.error(f'Link processing error: {str(e)}')
        if request.headers.get('HX-Request'):
            # Fetch current file list to show with error
            try:
                file_service = ItemFileService()
                list_result = file_service.list_files(item_id)
                files = list_result.get('files', [])
            except:
                files = []
            
            return render(request, 'main/items/_files_list.html', {
                'files': files,
                'item_id': item_id,
                'error': f"{e.message}: {e.details}" if e.details else e.message
            })
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=400)
    
    except Exception as e:
        # Log the full exception with traceback for debugging
        logger.error(f'Unexpected error processing link for item {item_id}: {str(e)}\n{traceback.format_exc()}')
        if request.headers.get('HX-Request'):
            return render(request, 'main/items/_files_list.html', {
                'files': [],
                'item_id': item_id,
                'error': 'Failed to process link. Please check the server logs for details.'
            })
        return JsonResponse({
            'success': False,
            'error': 'Failed to process link',
            'details': 'An unexpected error occurred. Please check the server logs.'
        }, status=500)


# ===== Quick Task Management API Endpoints =====

@csrf_exempt
@require_http_methods(["POST"])
def api_task_quick_delete(request, task_id):
    """
    API endpoint for quick task deletion without confirmation.
    DELETE /api/tasks/{task_id}/quick-delete
    
    Used by the item detail view task table for instant deletion.
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        task_id_str = str(task.id)
        task.delete()
        
        # Sync with Weaviate
        try:
            from main.models import Settings
            settings = Settings.objects.first()
            if settings:
                sync_service = WeaviateTaskSyncService(settings)
                sync_service.sync_delete(task_id_str)
        except WeaviateTaskSyncServiceError as e:
            logger.warning(f'Weaviate sync failed for task {task_id_str}: {e.message}')
        except Exception as e:
            logger.warning(f'Weaviate sync error for task {task_id_str}: {str(e)}')
        
        return JsonResponse({'success': True, 'message': 'Task deleted successfully'})
    
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except Exception as e:
        logger.error(f'Task deletion error: {str(e)}')
        return JsonResponse({'error': 'Failed to delete task'}, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_quick_status_update(request, task_id):
    """
    API endpoint for quick task status update.
    POST /api/tasks/{task_id}/quick-status-update
    Body: {"status": "new|working|review|ready|done"}
    
    Used by the item detail view task table for inline status changes.
    Updates the database and syncs with Weaviate.
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Parse request body
        data = json.loads(request.body)
        new_status = data.get('status', '').strip()
        
        # Validate status
        valid_statuses = ['new', 'working', 'review', 'ready', 'test', 'done']
        if new_status not in valid_statuses:
            return JsonResponse({'error': 'Invalid status value'}, status=400)
        
        previous_status = task.status
        task.status = new_status
        
        # Mark as done if status changed to done
        if new_status == 'done' and previous_status != 'done':
            task.save()
            task.mark_as_done()
        else:
            task.save()
        
        # Sync with Weaviate
        try:
            from main.models import Settings
            settings = Settings.objects.first()
            if settings:
                sync_service = WeaviateTaskSyncService(settings)
                sync_service.sync_update(task)
        except WeaviateTaskSyncServiceError as e:
            logger.warning(f'Weaviate sync failed for task {task.id}: {e.message}')
        except Exception as e:
            logger.warning(f'Weaviate sync error for task {task.id}: {str(e)}')
        
        return JsonResponse({
            'success': True,
            'status': task.status,
            'status_display': task.get_status_display()
        })
    
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task status update error: {str(e)}')
        return JsonResponse({'error': 'Failed to update task status'}, status=500)


@csrf_exempt
@require_http_methods(['POST'])
def api_task_quick_type_update(request, task_id):
    """
    API endpoint for quick task type update.
    POST /api/tasks/{task_id}/quick-type-update
    Body: {"type": "bug|feature|frage|support|idee|sonstige"}
    
    Used by the task list view for inline type changes.
    Updates the database and syncs with Weaviate.
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Parse request body
        data = json.loads(request.body)
        new_type = data.get('type', '').strip()
        
        # Validate type
        valid_types = ['bug', 'feature', 'frage', 'support', 'idee', 'sonstige']
        if new_type not in valid_types:
            return JsonResponse({'error': 'Invalid type value'}, status=400)
        
        task.type = new_type
        task.save()
        
        # Sync with Weaviate
        try:
            from main.models import Settings
            settings = Settings.objects.first()
            if settings:
                sync_service = WeaviateTaskSyncService(settings)
                sync_service.sync_update(task)
        except WeaviateTaskSyncServiceError as e:
            logger.warning(f'Weaviate sync failed for task {task.id}: {e.message}')
        except Exception as e:
            logger.warning(f'Weaviate sync error for task {task.id}: {str(e)}')
        
        return JsonResponse({
            'success': True,
            'type': task.type,
            'type_display': task.get_type_display()
        })
    
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f'Task type update error: {str(e)}')
        return JsonResponse({'error': 'Failed to update task type'}, status=500)


@csrf_exempt
@require_http_methods(['POST'])
def api_task_mark_done(request, task_id):
    """
    API endpoint to mark a task as done.
    POST /api/tasks/{task_id}/mark-done
    
    Sets the task status to 'done' and updates completed_at timestamp.
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    from .models import Task
    
    try:
        task = Task.objects.get(id=task_id)
        
        # Mark as done
        task.mark_as_done()
        
        # Sync with Weaviate
        try:
            from main.models import Settings
            settings = Settings.objects.first()
            if settings:
                sync_service = WeaviateTaskSyncService(settings)
                sync_service.sync_update(task)
        except WeaviateTaskSyncServiceError as e:
            logger.warning(f'Weaviate sync failed for task {task.id}: {e.message}')
        except Exception as e:
            logger.warning(f'Weaviate sync error for task {task.id}: {str(e)}')
        
        return JsonResponse({
            'success': True,
            'status': task.status,
            'status_display': task.get_status_display(),
            'completed_at': task.completed_at.isoformat() if task.completed_at else None
        })
    
    except Task.DoesNotExist:
        return JsonResponse({'error': 'Task not found'}, status=404)
    except Exception as e:
        logger.error(f'Task mark done error: {str(e)}')
        return JsonResponse({'error': 'Failed to mark task as done'}, status=500)


# ===== Milestone Knowledge Hub API Endpoints =====

@csrf_exempt
@require_http_methods(['POST'])
def api_milestone_context_add(request, milestone_id):
    """
    Add a context object to a milestone
    
    POST /api/milestones/<milestone_id>/context/add
    
    Supports two modes:
    1. JSON body (for note/email/transcript):
    {
        "type": "email|transcript|note",
        "title": "Context title",
        "content": "Text content",
        "source_id": "Optional source ID",
        "url": "Optional URL",
        "auto_analyze": true
    }
    
    2. Multipart form data (for file uploads):
    - file: uploaded file
    - auto_analyze: true/false (optional, default true)
    """
    from main.models import Milestone, MilestoneContextObject
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    from core.services.file_extraction_service import FileExtractionService
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Check if this is a file upload or JSON request
        if request.FILES.get('file'):
            # Handle file upload
            uploaded_file = request.FILES['file']
            auto_analyze = request.POST.get('auto_analyze', 'true').lower() == 'true'
            
            # Extract text from file
            file_service = FileExtractionService()
            if not file_service.can_extract_text(uploaded_file.name):
                return JsonResponse({
                    'success': False,
                    'error': f'Unsupported file type: {uploaded_file.name}'
                }, status=400)
            
            # Read file content
            file_content = uploaded_file.read()
            
            # Extract text
            extraction_result = file_service.extract_text(file_content, uploaded_file.name)
            
            if not extraction_result.get('success'):
                logger.error(f'Failed to extract text from file {uploaded_file.name}: {extraction_result.get("error", "")}')
                return JsonResponse({
                    'success': False,
                    'error': 'Failed to extract text from file'
                }, status=400)
            
            # Upload to SharePoint if configured
            sharepoint_file_id = ''
            sharepoint_url = ''
            try:
                from core.services.graph_service import GraphService, GraphServiceError
                graph = GraphService()
                
                # Create milestone-specific folder path
                # Format: Milestones/<ItemID>/<MilestoneID>
                folder_path = f"Milestones/{milestone.item.id}/{milestone.id}"
                
                # Upload file to SharePoint
                upload_result = graph.upload_sharepoint_file(
                    folder_path=folder_path,
                    file_name=uploaded_file.name,
                    content=file_content
                )
                
                if upload_result.get('success'):
                    sharepoint_file_id = upload_result.get('file_id', '')
                    # Construct SharePoint URL
                    if 'metadata' in upload_result and 'webUrl' in upload_result['metadata']:
                        sharepoint_url = upload_result['metadata']['webUrl']
                    
                    logger.info(f'File uploaded to SharePoint: {uploaded_file.name} (ID: {sharepoint_file_id})')
            except GraphServiceError as e:
                logger.warning(f'SharePoint upload failed, continuing without SharePoint storage: {str(e)}')
                # Continue without SharePoint - not a critical error
            except Exception as e:
                logger.warning(f'Unexpected error during SharePoint upload: {str(e)}')
                # Continue without SharePoint - not a critical error
            
            # Use extracted text as content
            context_type = 'file'
            title = uploaded_file.name
            content = extraction_result.get('text', '')
            source_id = sharepoint_file_id
            url = sharepoint_url
        else:
            # Handle JSON request
            data = json.loads(request.body)
            
            context_type = data.get('type', '')
            title = data.get('title', '').strip()
            content = data.get('content', '').strip()
            source_id = data.get('source_id', '').strip()
            url = data.get('url', '').strip()
            auto_analyze = data.get('auto_analyze', True)
        
        if not context_type or not title:
            return JsonResponse({
                'success': False,
                'error': 'Type and title are required'
            }, status=400)
        
        # Add context object using service
        service = MilestoneKnowledgeService()
        result = service.add_context_object(
            milestone=milestone,
            context_type=context_type,
            title=title,
            content=content,
            source_id=source_id,
            url=url,
            user=user,
            auto_analyze=auto_analyze
        )
        
        return JsonResponse(result)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Milestone knowledge service error: {str(e)}')
        return JsonResponse(e.to_dict(), status=400)
    
    except json.JSONDecodeError:
        return JsonResponse({
            'success': False,
            'error': 'Invalid JSON'
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error adding context object: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to add context object',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(['DELETE'])
def api_milestone_context_remove(request, context_id):
    """
    Remove a context object from a milestone
    
    DELETE /api/milestones/context/<context_id>/remove
    """
    from main.models import MilestoneContextObject
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        context_obj.delete()
        
        return JsonResponse({
            'success': True,
            'message': 'Context object removed successfully'
        })
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except Exception as e:
        logger.error(f'Error removing context object: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to remove context object'
        }, status=500)


@csrf_exempt
@require_http_methods(['POST'])
def api_milestone_context_summarize(request, milestone_id):
    """
    Generate AI summary for all context objects in a milestone
    
    POST /api/milestones/<milestone_id>/context/summarize
    """
    from main.models import Milestone
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Generate summary using service
        service = MilestoneKnowledgeService()
        result = service.generate_milestone_summary(milestone)
        
        return JsonResponse(result)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Milestone knowledge service error: {str(e)}')
        return JsonResponse(e.to_dict(), status=400)
    
    except Exception as e:
        logger.error(f'Error generating summary: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to generate summary',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET", "POST"])
def api_milestone_context_analyze(request, context_id):
    """
    Analyze a specific context object (summary + task derivation) or retrieve existing analysis
    
    GET /api/milestones/context/<context_id>/analyze - Get existing analysis
    POST /api/milestones/context/<context_id>/analyze - Run new analysis
    """
    from main.models import MilestoneContextObject
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # GET request: Return existing analysis data
        if request.method == 'GET':
            return JsonResponse({
                'success': True,
                'context': {
                    'id': str(context_obj.id),
                    'title': context_obj.title,
                    'type': context_obj.type,
                    'summary': context_obj.summary,
                    'derived_tasks': context_obj.derived_tasks,
                    'analyzed': context_obj.analyzed
                }
            })
        
        # POST request: Run analysis
        service = MilestoneKnowledgeService()
        result = service.analyze_context_object(context_obj)
        
        return JsonResponse(result)
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Milestone knowledge service error: {str(e)}')
        return JsonResponse(e.to_dict(), status=400)
    
    except Exception as e:
        logger.error(f'Error analyzing context object: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to analyze context object',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(['GET'])
def api_milestone_context_list(request, milestone_id):
    """
    Get list of context objects for a milestone
    
    GET /api/milestones/<milestone_id>/context
    """
    from main.models import Milestone
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Get all context objects
        context_objects = milestone.context_objects.all()
        
        result = {
            'success': True,
            'milestone_id': str(milestone.id),
            'milestone_name': milestone.name,
            'context_objects': []
        }
        
        for ctx in context_objects:
            result['context_objects'].append({
                'id': str(ctx.id),
                'type': ctx.type,
                'type_display': ctx.get_type_display(),
                'title': ctx.title,
                'url': ctx.url,
                'summary': ctx.summary,
                'analyzed': ctx.analyzed,
                'derived_tasks_count': len(ctx.derived_tasks) if ctx.derived_tasks else 0,
                'created_at': ctx.created_at.isoformat(),
                'uploaded_by': ctx.uploaded_by.username if ctx.uploaded_by else None
            })
        
        return JsonResponse(result)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except Exception as e:
        logger.error(f'Error listing context objects: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to list context objects'
        }, status=500)


@csrf_exempt
@require_http_methods(['POST'])
def api_milestone_context_create_tasks(request, context_id):
    """
    Create tasks from derived tasks in a context object
    
    POST /api/milestones/context/<context_id>/create-tasks
    """
    from main.models import MilestoneContextObject
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Create tasks using service
        service = MilestoneKnowledgeService()
        result = service.create_tasks_from_context(context_obj, milestone, user)
        
        return JsonResponse(result)
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Milestone knowledge service error: {str(e)}')
        return JsonResponse(e.to_dict(), status=400)
    
    except Exception as e:
        logger.error(f'Error creating tasks from context: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to create tasks',
            'details': 'An error occurred'
        }, status=500)


@csrf_exempt
@require_http_methods(['GET'])
def api_milestone_context_download(request, context_id):
    """
    Download a file from SharePoint for a context object
    
    GET /api/milestones/context/<context_id>/download
    """
    from main.models import MilestoneContextObject
    from core.services.graph_service import GraphService, GraphServiceError
    from django.http import HttpResponse
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Check if file has SharePoint ID
        if not context_obj.source_id or context_obj.type != 'file':
            return JsonResponse({
                'success': False,
                'error': 'File not available for download'
            }, status=400)
        
        # Download from SharePoint
        try:
            graph = GraphService()
            download_result = graph.get_sharepoint_file(context_obj.source_id)
            
            if download_result.get('success'):
                file_content = download_result.get('content')
                file_name = download_result.get('file_name', context_obj.title)
                
                # Determine content type based on file extension
                import mimetypes
                content_type, _ = mimetypes.guess_type(file_name)
                if not content_type:
                    content_type = 'application/octet-stream'
                
                # Create HTTP response with file
                response = HttpResponse(file_content, content_type=content_type)
                response['Content-Disposition'] = f'attachment; filename="{file_name}"'
                return response
            else:
                return JsonResponse({
                    'success': False,
                    'error': 'Failed to download file from SharePoint'
                }, status=500)
                
        except GraphServiceError as e:
            logger.error(f'SharePoint download error: {str(e)}')
            return JsonResponse({
                'success': False,
                'error': 'Failed to download file'
            }, status=500)
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except Exception as e:
        logger.error(f'Error downloading file: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to download file',
            'details': 'An error occurred'
        }, status=500)


@require_http_methods(["POST"])
def api_milestone_optimize_summary(request, milestone_id):
    """
    Optimize milestone summary using AI (summary-enhancer-agent)
    
    POST /api/milestones/<milestone_id>/optimize-summary
    
    Returns optimized summary without saving (preview mode)
    """
    from main.models import Milestone
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Check if summary exists
        if not milestone.summary or not milestone.summary.strip():
            return JsonResponse({
                'success': False,
                'error': 'No summary available to optimize. Generate a summary first.'
            }, status=400)
        
        # Optimize summary
        service = MilestoneKnowledgeService()
        result = service.optimize_summary(milestone, user=user)
        
        return JsonResponse(result, status=200)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Milestone summary optimization error: {str(e)}')
        return JsonResponse(e.to_dict(), status=500)
    
    except Exception as e:
        logger.error(f'Error optimizing milestone summary: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to optimize summary',
            'details': str(e)
        }, status=500)


@csrf_exempt
def api_milestone_context_enhance_summary(request, context_id):
    """
    Enhance a context object's summary using summary-enhancer-agent
    
    POST /api/milestones/context/<context_id>/enhance-summary
    """
    from main.models import MilestoneContextObject
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Enhance summary
        service = MilestoneKnowledgeService()
        result = service.enhance_summary(context_obj)
        
        return JsonResponse(result)
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Summary enhancement error: {str(e)}')
        return JsonResponse(e.to_dict(), status=500)
    
    except Exception as e:
        logger.error(f'Error enhancing summary: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to enhance summary',
            'details': 'An error occurred'
        }, status=500)


@require_http_methods(["POST"])
def api_milestone_save_optimized_summary(request, milestone_id):
    """
    Save an optimized summary to the milestone
    
    POST /api/milestones/<milestone_id>/save-optimized-summary
    
    Request body:
    {
        "optimized_summary": "The optimized text to save",
        "agent_name": "summary-enhancer-agent",
        "model_name": "gpt-4"
    }
    """
    from main.models import Milestone
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    import json
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Invalid JSON in request body'
            }, status=400)
        
        optimized_summary = data.get('optimized_summary', '').strip()
        agent_name = data.get('agent_name', 'summary-enhancer-agent')
        model_name = data.get('model_name', 'gpt-4')
        
        if not optimized_summary:
            return JsonResponse({
                'success': False,
                'error': 'optimized_summary is required'
            }, status=400)
        
        # Save optimized summary
        service = MilestoneKnowledgeService()
        result = service.save_optimized_summary(
            milestone=milestone,
            optimized_summary=optimized_summary,
            user=user,
            agent_name=agent_name,
            model_name=model_name
        )
        
        return JsonResponse(result, status=200)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Error saving optimized summary: {str(e)}')
        return JsonResponse(e.to_dict(), status=500)
    
    except Exception as e:
        logger.error(f'Error saving optimized summary: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to save optimized summary',
            'details': str(e)
        }, status=500)


@csrf_exempt
def api_milestone_context_accept_results(request, context_id):
    """
    Accept and apply analysis results after user review/editing
    
    POST /api/milestones/context/<context_id>/accept-results
    Body: {
        "summary": "edited summary text",
        "derived_tasks": [{"title": "...", "description": "..."}]
    }
    """
    from main.models import MilestoneContextObject
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        context_obj = MilestoneContextObject.objects.get(id=context_id)
        milestone = context_obj.milestone
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Invalid JSON in request body'
            }, status=400)
        
        summary = data.get('summary')
        derived_tasks = data.get('derived_tasks')
        
        # Accept results
        service = MilestoneKnowledgeService()
        result = service.accept_analysis_results(context_obj, summary, derived_tasks)
        
        return JsonResponse(result)
        
    except MilestoneContextObject.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Context object not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Accept results error: {str(e)}')
        return JsonResponse(e.to_dict(), status=500)
    
    except Exception as e:
        logger.error(f'Error accepting results: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to accept results',
            'details': 'An error occurred'
        }, status=500)


@require_http_methods(["GET"])
def api_milestone_summary_history(request, milestone_id):
    """
    Get version history of milestone summaries
    
    GET /api/milestones/<milestone_id>/summary-history
    """
    from main.models import Milestone
    from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Get summary history
        service = MilestoneKnowledgeService()
        result = service.get_summary_history(milestone)
        
        return JsonResponse(result, status=200)
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except MilestoneKnowledgeServiceError as e:
        logger.error(f'Error retrieving summary history: {str(e)}')
        return JsonResponse(e.to_dict(), status=500)
    
    except Exception as e:
        logger.error(f'Error retrieving summary history: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to retrieve summary history',
            'details': str(e)
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_milestone_generate_changelog(request, milestone_id):
    """
    Generate or Recreate AI-powered ChangeLog for a milestone using KiGate
    
    POST /api/milestones/<milestone_id>/generate-changelog
    
    When called, this function will:
    1. Clean up any existing changelogs (files, Weaviate entries, and database field)
    2. Generate a new changelog based on completed tasks
    
    Generates a changelog based on:
    - Item name
    - Milestone name
    - List of completed tasks in the milestone
    
    Stores the new changelog in:
    1. Milestone.changelog field
    2. MilestoneFile as a markdown file
    3. Weaviate as a KnowledgeObject
    
    This allows users to recreate the changelog at any time, replacing old versions.
    """
    from main.models import Milestone, MilestoneFile
    from core.services.kigate_service import KiGateService, KiGateServiceError
    from core.services.weaviate_sync_service import WeaviateItemSyncService, WeaviateItemSyncServiceError
    import os
    from datetime import datetime
    
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        milestone = Milestone.objects.get(id=milestone_id)
        
        # Check permissions
        if user.role != 'admin' and milestone.item.created_by != user:
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
        
        # Clean up old changelogs (for recreation)
        # This allows users to regenerate changelogs without accumulating old versions
        old_changelog_files = MilestoneFile.objects.filter(
            milestone=milestone,
            content_type='text/markdown'
        )
        
        if old_changelog_files.exists():
            logger.info(f'Cleaning up {old_changelog_files.count()} old changelog file(s) for milestone {milestone_id}')
            
            # Delete from Weaviate first
            weaviate_service = None
            try:
                weaviate_service = WeaviateItemSyncService()
                for old_file in old_changelog_files:
                    if old_file.weaviate_synced:
                        try:
                            weaviate_service.sync_delete(str(old_file.id))
                            logger.info(f'Deleted old changelog from Weaviate: {old_file.id}')
                        except WeaviateItemSyncServiceError as e:
                            logger.warning(f'Failed to delete old changelog from Weaviate: {str(e)}')
            except WeaviateItemSyncServiceError as e:
                logger.warning(f'Failed to initialize Weaviate service for cleanup: {str(e)}')
            except Exception as e:
                logger.warning(f'Unexpected error during Weaviate cleanup: {str(e)}')
            
            # Delete physical files from filesystem
            for old_file in old_changelog_files:
                if old_file.file_path and os.path.exists(old_file.file_path):
                    try:
                        os.remove(old_file.file_path)
                        logger.info(f'Deleted old changelog file: {old_file.file_path}')
                    except OSError as e:
                        logger.warning(f'Failed to delete old changelog file {old_file.file_path}: {str(e)}')
            
            # Delete MilestoneFile records from database
            old_changelog_files.delete()
            logger.info('Deleted old MilestoneFile records')
        
        # Clear the changelog field in the milestone (will be replaced with new content)
        if milestone.changelog:
            logger.info(f'Clearing old changelog content from milestone {milestone_id}')
            milestone.changelog = ''
            milestone.save()
        
        # Gather information for changelog generation
        item_name = milestone.item.title
        milestone_name = milestone.name
        
        # Get completed tasks
        completed_tasks = milestone.tasks.filter(status='done')
        task_list = []
        for task in completed_tasks:
            task_info = {
                'title': task.title,
                'description': task.description[:200] if task.description else '',  # Truncate long descriptions
                'type': task.get_type_display(),
                'completed_at': task.completed_at.isoformat() if task.completed_at else 'Unknown'
            }
            task_list.append(task_info)
        
        # Prepare message for KiGate agent
        message = f"""Generate a comprehensive ChangeLog for the following milestone:

Item: {item_name}
Milestone: {milestone_name}
Due Date: {milestone.due_date}
Status: {milestone.get_status_display()}

Completed Tasks ({len(task_list)}):
"""
        
        for i, task in enumerate(task_list, 1):
            message += f"\n{i}. {task['title']}"
            if task['description']:
                message += f"\n   Description: {task['description']}"
            message += f"\n   Type: {task['type']}"
            message += f"\n   Completed: {task['completed_at']}"
            message += "\n"
        
        message += """

Please generate a professional ChangeLog in Markdown format that:
1. Summarizes the completed work
2. Lists key features and improvements
3. Mentions any bug fixes
4. Includes a risk assessment
5. Uses proper Markdown formatting with headers and lists

Format the output as a standard CHANGELOG.md file.
"""
        
        # Call KiGate service
        try:
            kigate_service = KiGateService()
            result = kigate_service.execute_agent(
                agent_name='changelog-creation-risk-assessment-agent',
                provider='openai',
                model='gpt-4',
                message=message,
                user_id=str(user.id)
            )
            
            if not result.get('success'):
                raise KiGateServiceError('Agent execution failed', details=result.get('error', 'Unknown error'))
            
            changelog_content = result.get('result', '')
            
        except KiGateServiceError as e:
            logger.error(f'KiGate service error: {str(e)}')
            return JsonResponse({
                'success': False,
                'error': 'Failed to generate changelog using AI'
            }, status=500)
        
        # Save changelog to milestone
        milestone.changelog = changelog_content
        milestone.save()
        
        # Create changelog file
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        # Sanitize milestone name for safe filename
        safe_milestone_name = ''.join(c if c.isalnum() or c in ('_', '-') else '_' for c in milestone_name)
        filename = f"CHANGELOG_{safe_milestone_name}_{timestamp}.md"
        file_content = changelog_content.encode('utf-8')
        file_size = len(file_content)
        
        # Create MilestoneFile record
        milestone_file = MilestoneFile.objects.create(
            milestone=milestone,
            filename=filename,
            file_size=file_size,
            content_type='text/markdown',
            uploaded_by=user
        )
        
        # Store file content in a local path (you may want to adjust this based on your storage strategy)
        # For now, we'll store it as a temporary approach
        files_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'media', 'milestone_files')
        os.makedirs(files_dir, exist_ok=True)
        # Use milestone_file.id for secure filename
        safe_filename = f"{milestone_file.id}.md"
        file_path = os.path.join(files_dir, safe_filename)
        
        with open(file_path, 'wb') as f:
            f.write(file_content)
        
        milestone_file.file_path = file_path
        milestone_file.save()
        
        # Sync to Weaviate as KnowledgeObject
        try:
            weaviate_service = WeaviateItemSyncService()
            
            # Prepare data for Weaviate
            weaviate_data = {
                'object_type': 'milestone_changelog',
                'object_id': str(milestone_file.id),
                'title': f"ChangeLog: {milestone_name}",
                'content': changelog_content,
                'metadata': {
                    'milestone_id': str(milestone.id),
                    'milestone_name': milestone_name,
                    'item_id': str(milestone.item.id),
                    'item_name': item_name,
                    'filename': filename,
                    'created_at': milestone_file.created_at.isoformat(),
                    'created_by': user.username
                }
            }
            
            # Store in Weaviate (you'll need to implement a method for generic KnowledgeObject storage)
            # For now, we'll mark it as synced and handle the actual sync separately
            milestone_file.weaviate_synced = True
            milestone_file.save()
            
        except WeaviateItemSyncServiceError as e:
            logger.warning(f'Failed to sync changelog to Weaviate: {str(e)}')
            # Don't fail the operation if Weaviate sync fails
        
        except Exception as e:
            logger.warning(f'Unexpected error syncing to Weaviate: {str(e)}')
        
        return JsonResponse({
            'success': True,
            'message': 'ChangeLog generated successfully',
            'changelog': changelog_content,
            'file_id': str(milestone_file.id),
            'filename': filename
        })
        
    except Milestone.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Milestone not found'
        }, status=404)
    
    except Exception as e:
        logger.error(f'Error generating changelog: {str(e)}', exc_info=True)
        return JsonResponse({
            'success': False,
            'error': 'Failed to generate changelog'
        }, status=500)


@require_http_methods(["GET"])
def check_weaviate_status(request, object_type, object_id):
    """
    Check if an Item, Task, Milestone, or File exists in Weaviate database.
    
    Args:
        object_type: 'item', 'task', 'milestone', 'item_file', or 'task_file'
        object_id: UUID of the object
    
    Returns:
        JSON with 'exists' boolean and optional 'data' if object exists
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'success': False, 'error': 'Unauthorized'}, status=401)
    
    try:
        from .models import Item, Task, Milestone, ItemFile, TaskFile, Settings
        from core.services.weaviate_sync_service import WeaviateItemSyncService
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({
                'success': False,
                'error': 'Settings not configured'
            }, status=500)
        
        # Initialize Weaviate service
        weaviate_service = WeaviateItemSyncService(settings)
        
        # Get the collection
        collection = weaviate_service._client.collections.get('KnowledgeObject')
        
        # Check if object exists in Weaviate
        try:
            existing_obj = collection.query.fetch_object_by_id(str(object_id))
            exists = existing_obj is not None
            
            if exists:
                # Object exists, return its properties
                return JsonResponse({
                    'success': True,
                    'exists': True,
                    'data': {
                        'id': str(existing_obj.uuid),
                        'properties': existing_obj.properties
                    }
                })
            else:
                # Object doesn't exist
                return JsonResponse({
                    'success': True,
                    'exists': False
                })
        except Exception as e:
            logger.debug(f"Error checking object {object_id}: {str(e)}")
            return JsonResponse({
                'success': True,
                'exists': False
            })
        finally:
            weaviate_service.close()
            
    except Exception as e:
        logger.error(f'Error checking Weaviate status: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@require_http_methods(["POST"])
def add_to_weaviate(request, object_type, object_id):
    """
    Add an Item, Task, Milestone, or File to Weaviate database.
    
    Args:
        object_type: 'item', 'task', 'milestone', 'item_file', or 'task_file'
        object_id: UUID of the object
    
    Returns:
        JSON with success status and message
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'success': False, 'error': 'Unauthorized'}, status=401)
    
    try:
        from .models import Item, Task, Milestone, ItemFile, TaskFile, Settings
        from core.services.weaviate_sync_service import WeaviateItemSyncService, WeaviateItemSyncServiceError
        from core.services.weaviate_task_sync_service import WeaviateTaskSyncService, WeaviateTaskSyncServiceError
        from core.services.milestone_knowledge_service import MilestoneKnowledgeService, MilestoneKnowledgeServiceError
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({
                'success': False,
                'error': 'Settings not configured'
            }, status=500)
        
        # Handle different object types
        if object_type == 'item':
            try:
                item = Item.objects.get(id=object_id)
                weaviate_service = WeaviateItemSyncService(settings)
                result = weaviate_service.sync_create(item)
                weaviate_service.close()
                
                return JsonResponse({
                    'success': True,
                    'message': f'Item "{item.title}" added to Weaviate successfully'
                })
            except Item.DoesNotExist:
                return JsonResponse({
                    'success': False,
                    'error': 'Item not found'
                }, status=404)
            except WeaviateItemSyncServiceError as e:
                logger.error(f'Weaviate sync error: {str(e)}')
                return JsonResponse({
                    'success': False,
                    'error': str(e)
                }, status=500)
                
        elif object_type == 'task':
            try:
                task = Task.objects.get(id=object_id)
                weaviate_service = WeaviateTaskSyncService(settings)
                result = weaviate_service.sync_create(task)
                weaviate_service.close()
                
                return JsonResponse({
                    'success': True,
                    'message': f'Task "{task.title}" added to Weaviate successfully'
                })
            except Task.DoesNotExist:
                return JsonResponse({
                    'success': False,
                    'error': 'Task not found'
                }, status=404)
            except WeaviateTaskSyncServiceError as e:
                logger.error(f'Weaviate sync error: {str(e)}')
                return JsonResponse({
                    'success': False,
                    'error': str(e)
                }, status=500)
                
        elif object_type == 'milestone':
            try:
                milestone = Milestone.objects.get(id=object_id)
                milestone_service = MilestoneKnowledgeService()
                result = milestone_service.sync_to_weaviate(milestone)
                
                return JsonResponse({
                    'success': True,
                    'message': f'Milestone "{milestone.name}" added to Weaviate successfully'
                })
            except Milestone.DoesNotExist:
                return JsonResponse({
                    'success': False,
                    'error': 'Milestone not found'
                }, status=404)
            except MilestoneKnowledgeServiceError as e:
                logger.error(f'Weaviate sync error: {str(e)}')
                return JsonResponse({
                    'success': False,
                    'error': str(e)
                }, status=500)
                
        elif object_type in ['item_file', 'task_file']:
            # For files, we need to sync them through the parent object's sync service
            try:
                if object_type == 'item_file':
                    file_obj = ItemFile.objects.get(id=object_id)
                    # Mark as synced and trigger parent item sync
                    file_obj.weaviate_synced = True
                    file_obj.save()
                    return JsonResponse({
                        'success': True,
                        'message': f'File "{file_obj.filename}" marked for Weaviate sync'
                    })
                else:
                    file_obj = TaskFile.objects.get(id=object_id)
                    # Mark as synced
                    file_obj.weaviate_synced = True
                    file_obj.save()
                    return JsonResponse({
                        'success': True,
                        'message': f'File "{file_obj.filename}" marked for Weaviate sync'
                    })
            except (ItemFile.DoesNotExist, TaskFile.DoesNotExist):
                return JsonResponse({
                    'success': False,
                    'error': 'File not found'
                }, status=404)
        else:
            return JsonResponse({
                'success': False,
                'error': f'Unsupported object type: {object_type}'
            }, status=400)
            
    except Exception as e:
        logger.error(f'Error adding to Weaviate: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@require_http_methods(["GET"])
def get_weaviate_dump(request, object_type, object_id):
    """
    Get a dump of an object from Weaviate database.
    
    Args:
        object_type: 'item', 'task', 'milestone', 'item_file', or 'task_file'
        object_id: UUID of the object
    
    Returns:
        JSON with object dump from Weaviate
    """
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'success': False, 'error': 'Unauthorized'}, status=401)
    
    try:
        from .models import Settings
        from core.services.weaviate_sync_service import WeaviateItemSyncService
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({
                'success': False,
                'error': 'Settings not configured'
            }, status=500)
        
        # Initialize Weaviate service
        weaviate_service = WeaviateItemSyncService(settings)
        
        # Get the collection
        collection = weaviate_service._client.collections.get('KnowledgeObject')
        
        # Fetch object from Weaviate
        try:
            existing_obj = collection.query.fetch_object_by_id(str(object_id))
            
            if existing_obj is None:
                return JsonResponse({
                    'success': False,
                    'error': 'Object not found in Weaviate'
                }, status=404)
            
            # Format the dump
            dump_data = {
                'id': str(existing_obj.uuid),
                'properties': existing_obj.properties,
                'metadata': {
                    'created_at': existing_obj.properties.get('createdAt', 'N/A'),
                    'type': existing_obj.properties.get('type', 'Unknown')
                }
            }
            
            return JsonResponse({
                'success': True,
                'dump': dump_data
            })
            
        except Exception as e:
            logger.error(f"Error fetching object {object_id}: {str(e)}")
            return JsonResponse({
                'success': False,
                'error': f'Error fetching object: {str(e)}'
            }, status=500)
        finally:
            weaviate_service.close()
            
    except Exception as e:
        logger.error(f'Error getting Weaviate dump: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@require_http_methods(["GET"])
def api_get_items_for_move(request):
    """
    API endpoint to get all items for task move dropdown
    
    Returns:
    {
        "success": true,
        "items": [
            {
                "id": "uuid",
                "title": "Item Title"
            },
            ...
        ]
    }
    """
    from .models import Item, User
    
    try:
        # Get current user from session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        try:
            user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Get all items ordered by title
        items = Item.objects.all().order_by('title').values('id', 'title')
        
        return JsonResponse({
            'success': True,
            'items': list(items)
        })
        
    except Exception as e:
        logger.error(f'Error getting items for move: {str(e)}')
        return JsonResponse({
            'error': 'An error occurred while fetching items'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def create_teams_channel(request, item_id):
    """
    API endpoint to create a Teams channel for an item
    
    This endpoint creates a channel in the configured Teams workspace,
    posts a welcome message, and stores the channel ID in the item.
    
    Args:
        request: HTTP request
        item_id: UUID of the item
        
    Returns:
        JSON response with success status and channel details
    """
    logger.info(f'Creating Teams channel for item {item_id}')
    
    try:
        # Get current user from session
        user_id = request.session.get('user_id')
        if not user_id:
            logger.warning('Unauthorized attempt to create Teams channel')
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        try:
            user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            logger.warning(f'User {user_id} not found')
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Get the item
        from .models import Item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            logger.warning(f'Item {item_id} not found')
            return JsonResponse({'error': 'Item not found'}, status=404)
        
        # Check if channel already exists
        if item.channel_id:
            logger.warning(f'Item {item_id} already has a Teams channel: {item.channel_id}')
            return JsonResponse({
                'error': 'Channel already exists for this item',
                'channel_id': item.channel_id
            }, status=400)
        
        # Initialize Teams service
        try:
            teams_service = TeamsService()
        except TeamsServiceError as e:
            logger.error(f'Failed to initialize Teams service: {str(e)}')
            return JsonResponse({
                'error': 'Teams integration not configured properly. Please contact your administrator.'
            }, status=503)
        
        # Create the channel
        try:
            result = teams_service.create_channel_for_item(
                item_title=item.title
                # Note: Not passing item_description to avoid exceeding 1024 character limit
            )
            
            if result.get('success'):
                # Store channel ID in item
                item.channel_id = result['channel_id']
                item.save(update_fields=['channel_id'])
                
                logger.info(f'Successfully created Teams channel for item {item_id}: {result["channel_id"]}')
                
                return JsonResponse({
                    'success': True,
                    'message': f'Teams channel "{item.title}" created successfully',
                    'channel_id': result['channel_id'],
                    'web_url': result.get('web_url', ''),
                    'display_name': result.get('display_name', item.title)
                })
            else:
                logger.error(f'Failed to create Teams channel for item {item_id}')
                return JsonResponse({
                    'error': 'Failed to create Teams channel. Please try again later.'
                }, status=500)
                
        except TeamsServiceError as e:
            logger.error(f'Teams service error while creating channel: {str(e)}')
            return JsonResponse({
                'error': 'Failed to create Teams channel. Please try again later.'
            }, status=500)
        
    except Exception as e:
        logger.error(f'Unexpected error creating Teams channel for item {item_id}: {str(e)}')
        return JsonResponse({
            'error': 'An unexpected error occurred. Please try again later.'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def poll_teams_messages(request):
    """
    API endpoint to manually trigger Teams message polling
    
    POST /api/teams/poll
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    # Check if user is admin
    if user.role != 'admin':
        return JsonResponse({'error': 'Admin access required'}, status=403)
    
    try:
        from .models import Settings
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({'error': 'Settings not configured'}, status=500)
        
        if not settings.teams_enabled:
            return JsonResponse({'error': 'Teams integration is not enabled'}, status=400)
        
        # Import here to avoid circular dependency
        from core.services.teams_integration_service import TeamsIntegrationService
        
        # Initialize service and poll
        service = TeamsIntegrationService(settings=settings)
        result = service.poll_and_process()
        
        logger.info(f'Manual Teams poll triggered by user {user.username}')
        
        return JsonResponse({
            'success': True,
            'result': {
                'items_checked': result.get('items_checked', 0),
                'messages_found': result.get('messages_found', 0),
                'messages_processed': result.get('messages_processed', 0),
                'tasks_created': result.get('tasks_created', 0),
                'responses_posted': result.get('responses_posted', 0),
                'errors': len(result.get('errors', []))
            }
        })
        
    except Exception as e:
        logger.error(f'Error during manual Teams poll: {str(e)}')
        return JsonResponse({
            'error': 'Failed to poll Teams messages',
            'details': str(e)
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def teams_integration_status(request):
    """
    API endpoint to get Teams integration status
    
    GET /api/teams/status
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({'error': 'Authentication required'}, status=401)
    
    try:
        from .models import Settings, Item, Task
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({'error': 'Settings not configured'}, status=500)
        
        # Get items with channels
        items_with_channels = Item.objects.filter(
            channel_id__isnull=False
        ).exclude(channel_id='').count()
        
        # Get tasks created from Teams messages
        tasks_from_teams = Task.objects.filter(
            message_id__isnull=False
        ).exclude(message_id='').count()
        
        return JsonResponse({
            'success': True,
            'status': {
                'enabled': settings.teams_enabled,
                'team_id': settings.teams_team_id if settings.teams_enabled else None,
                'poll_interval': settings.graph_poll_interval,
                'items_with_channels': items_with_channels,
                'tasks_from_teams': tasks_from_teams
            }
        })
        
    except Exception as e:
        logger.error(f'Error getting Teams integration status: {str(e)}')
        return JsonResponse({
            'error': 'Failed to get status',
            'details': str(e)
        }, status=500)


# ========================================
# Task Comments API
# ========================================

@csrf_exempt
@require_http_methods(["GET"])
def api_task_comments(request, task_id):
    """
    Get all comments for a task
    
    Returns:
        JSON response with list of comments or HTML partial for htmx
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from .models import Task, TaskComment
        from django.shortcuts import render
        
        # Get task
        task = Task.objects.get(id=task_id)
        
        # Get all comments for the task
        comments = TaskComment.objects.filter(task=task).order_by('created_at')
        
        # For htmx requests, return HTML partial with model objects
        if request.headers.get('HX-Request'):
            # Prepare comment data for template (keep datetime objects for Django template filters)
            comment_list = []
            for comment in comments:
                comment_data = {
                    'id': str(comment.id),
                    'author': comment.get_author_display(),
                    'author_id': str(comment.author.id) if comment.author else None,
                    'text': comment.text,
                    'source': comment.source,
                    'created_at': comment.created_at,  # Keep as datetime object
                    'updated_at': comment.updated_at,  # Keep as datetime object
                    'can_edit': comment.author == user if comment.author else False,
                    'can_delete': comment.author == user or user.role == 'admin' if comment.author else user.role == 'admin',
                    # Email-specific fields
                    'email_from': comment.email_from if comment.source == 'email' else '',
                    'email_to': comment.email_to if comment.source == 'email' else '',
                    'email_cc': comment.email_cc if comment.source == 'email' else '',
                    'email_subject': comment.email_subject if comment.source == 'email' else '',
                    'email_direction': comment.email_direction if comment.source == 'email' else '',
                    'email_message_id': comment.email_message_id if comment.source == 'email' else '',
                }
                comment_list.append(comment_data)
            
            return render(request, 'main/tasks/_comments_list.html', {
                'comments': comment_list,
                'task': task,
                'current_user': user
            })
        
        # For regular API requests, return JSON with ISO strings
        comment_list = []
        for comment in comments:
            comment_data = {
                'id': str(comment.id),
                'author': comment.get_author_display(),
                'author_id': str(comment.author.id) if comment.author else None,
                'text': comment.text,
                'source': comment.source,
                'created_at': comment.created_at.isoformat(),
                'updated_at': comment.updated_at.isoformat(),
                'can_edit': comment.author == user if comment.author else False,
                'can_delete': comment.author == user or user.role == 'admin' if comment.author else user.role == 'admin',
                # Email-specific fields
                'email_from': comment.email_from if comment.source == 'email' else '',
                'email_to': comment.email_to if comment.source == 'email' else '',
                'email_cc': comment.email_cc if comment.source == 'email' else '',
                'email_subject': comment.email_subject if comment.source == 'email' else '',
                'email_direction': comment.email_direction if comment.source == 'email' else '',
                'email_message_id': comment.email_message_id if comment.source == 'email' else '',
            }
            comment_list.append(comment_data)
        
        return JsonResponse({
            'success': True,
            'comments': comment_list
        })
    
    except Task.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Task not found'
        }, status=404)
    
    except Exception as e:
        logger.error(f'Error getting task comments: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to get comments'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_comment_create(request, task_id):
    """
    Create a new comment on a task
    
    Body:
        {
            "text": "Comment text",
            "source": "user" or "agent" (optional, defaults to "user"),
            "author_name": "Name" (optional, for agent comments)
        }
    
    Returns:
        JSON response with created comment
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from .models import Task, TaskComment
        
        # Parse request body
        data = json.loads(request.body)
        text = data.get('text', '').strip()
        source = data.get('source', 'user')
        author_name = data.get('author_name', '')
        
        # Validate input
        if not text:
            return JsonResponse({
                'success': False,
                'error': 'Comment text is required'
            }, status=400)
        
        # Get task
        task = Task.objects.get(id=task_id)
        
        # Create comment
        comment = TaskComment.objects.create(
            task=task,
            author=user if source == 'user' else None,
            author_name=author_name if source == 'agent' else '',
            text=text,
            source=source
        )
        
        # Sync task to Weaviate with updated comments
        try:
            from .models import Settings
            settings = Settings.objects.first()
            if settings:
                weaviate_service = WeaviateTaskSyncService(settings)
                weaviate_service.sync_update(task)
                weaviate_service.close()
                logger.info(f'Task {task_id} synced to Weaviate with new comment')
        except WeaviateTaskSyncServiceError as e:
            logger.warning(f'Failed to sync task to Weaviate: {str(e)}')
            # Continue even if Weaviate sync fails
        
        return JsonResponse({
            'success': True,
            'comment': {
                'id': str(comment.id),
                'author': comment.get_author_display(),
                'author_id': str(comment.author.id) if comment.author else None,
                'text': comment.text,
                'source': comment.source,
                'created_at': comment.created_at.isoformat(),
                'updated_at': comment.updated_at.isoformat(),
                'can_edit': comment.author == user if comment.author else False,
                'can_delete': comment.author == user or user.role == 'admin' if comment.author else user.role == 'admin',
            }
        })
    
    except Task.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Task not found'
        }, status=404)
    
    except json.JSONDecodeError:
        return JsonResponse({
            'success': False,
            'error': 'Invalid JSON'
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error creating comment: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to create comment'
        }, status=500)


@csrf_exempt
@require_http_methods(["PUT"])
def api_task_comment_update(request, comment_id):
    """
    Update a comment
    
    Body:
        {
            "text": "Updated comment text"
        }
    
    Returns:
        JSON response with updated comment
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from .models import TaskComment
        
        # Parse request body
        data = json.loads(request.body)
        text = data.get('text', '').strip()
        
        # Validate input
        if not text:
            return JsonResponse({
                'success': False,
                'error': 'Comment text is required'
            }, status=400)
        
        # Get comment
        comment = TaskComment.objects.get(id=comment_id)
        
        # Check permission (only author can edit)
        if comment.author != user:
            return JsonResponse({
                'success': False,
                'error': 'You can only edit your own comments'
            }, status=403)
        
        # Update comment
        comment.text = text
        comment.save()
        
        # Sync task to Weaviate with updated comments
        try:
            from .models import Settings
            settings = Settings.objects.first()
            if settings:
                weaviate_service = WeaviateTaskSyncService(settings)
                weaviate_service.sync_update(comment.task)
                weaviate_service.close()
                logger.info(f'Task {comment.task.id} synced to Weaviate after comment update')
        except WeaviateTaskSyncServiceError as e:
            logger.warning(f'Failed to sync task to Weaviate: {str(e)}')
            # Continue even if Weaviate sync fails
        
        return JsonResponse({
            'success': True,
            'comment': {
                'id': str(comment.id),
                'author': comment.get_author_display(),
                'author_id': str(comment.author.id) if comment.author else None,
                'text': comment.text,
                'source': comment.source,
                'created_at': comment.created_at.isoformat(),
                'updated_at': comment.updated_at.isoformat(),
                'can_edit': comment.author == user if comment.author else False,
                'can_delete': comment.author == user or user.role == 'admin' if comment.author else user.role == 'admin',
            }
        })
    
    except TaskComment.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Comment not found'
        }, status=404)
    
    except json.JSONDecodeError:
        return JsonResponse({
            'success': False,
            'error': 'Invalid JSON'
        }, status=400)
    
    except Exception as e:
        logger.error(f'Error updating comment: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to update comment'
        }, status=500)


@csrf_exempt
@require_http_methods(["DELETE"])
def api_task_comment_delete(request, comment_id):
    """
    Delete a comment
    
    Returns:
        JSON response with success status
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from .models import TaskComment
        
        # Get comment
        comment = TaskComment.objects.get(id=comment_id)
        
        # Check permission (only author or admin can delete)
        if comment.author != user and user.role != 'admin':
            return JsonResponse({
                'success': False,
                'error': 'You can only delete your own comments or you must be an admin'
            }, status=403)
        
        # Store task reference before deletion
        task = comment.task
        
        # Delete comment
        comment.delete()
        
        # Sync task to Weaviate with updated comments
        try:
            from .models import Settings
            settings = Settings.objects.first()
            if settings:
                weaviate_service = WeaviateTaskSyncService(settings)
                weaviate_service.sync_update(task)
                weaviate_service.close()
                logger.info(f'Task {task.id} synced to Weaviate after comment deletion')
        except WeaviateTaskSyncServiceError as e:
            logger.warning(f'Failed to sync task to Weaviate: {str(e)}')
            # Continue even if Weaviate sync fails
        
        return JsonResponse({
            'success': True,
            'message': 'Comment deleted successfully'
        })
    
    except TaskComment.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Comment not found'
        }, status=404)
    
    except Exception as e:
        logger.error(f'Error deleting comment: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Failed to delete comment'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_global_search(request):
    """
    Global semantic search across all KnowledgeObject types
    
    Query Parameters:
        query (required): Search query text (natural language)
        limit (optional): Maximum number of results (default: 10, max: 50)
        types (optional): Comma-separated list of object types to filter by
                          (e.g., "Item,Task,File")
        search_type (optional): Type of search ('hybrid', 'neartext', 'bm25')
                               Default: 'hybrid'
    
    Returns:
        JSON response with:
            - success: bool
            - results: list of search results with metadata
            - total: total number of results
            - query: original query text
            - search_type: type of search performed
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        # Get query parameter
        query = request.GET.get('query', '').strip()
        
        if not query:
            return JsonResponse({
                'success': False,
                'error': 'Query parameter is required'
            }, status=400)
        
        # Get optional parameters
        limit = int(request.GET.get('limit', 10))
        limit = min(max(1, limit), 50)  # Clamp between 1 and 50
        
        types_param = request.GET.get('types', '').strip()
        object_types = None
        if types_param:
            object_types = [t.strip() for t in types_param.split(',') if t.strip()]
        
        # Get search_type parameter
        search_type = request.GET.get('search_type', 'hybrid').strip().lower()
        
        # Perform search
        from core.services.weaviate_search_service import WeaviateSearchService, WeaviateSearchServiceError
        from .models import Settings
        
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({
                'success': False,
                'error': 'Settings not configured'
            }, status=500)
        
        search_service = WeaviateSearchService(settings)
        
        try:
            result = search_service.search(
                query=query,
                limit=limit,
                object_types=object_types,
                search_type=search_type
            )
            
            logger.info(f"Global {search_type} search for '{query}' returned {result.get('total', 0)} results")
            
            return JsonResponse(result)
            
        finally:
            search_service.close()
    
    except WeaviateSearchServiceError as e:
        logger.error(f'Weaviate search error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Search service error'
        }, status=500)
    
    except ValueError as e:
        logger.error(f'Invalid parameter in search: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Invalid parameter'
        }, status=400)
    
    except Exception as e:
        logger.error(f'Global search error: {str(e)}')
        return JsonResponse({
            'success': False,
            'error': 'Search failed'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_file_summary(request, file_id):
    """
    Get AI-generated summary of file content from Weaviate
    
    This endpoint:
    1. Fetches file content from Weaviate database
    2. Sends content to KIGate agent 'weaviate-data-summary-agent'
    3. Returns markdown-formatted summary
    
    Args:
        file_id: UUID of the file (ItemFile or TaskFile)
        
    Returns:
        JSON response with:
        - success: boolean
        - summary: markdown-formatted summary text
        - filename: name of the file
        - file_url: SharePoint URL to open the file
        - error: error message (if failed)
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Authentication required'
        }, status=401)
    
    try:
        from main.models import ItemFile, TaskFile, Settings
        from core.services.weaviate_sync_service import WeaviateItemSyncService
        
        # Try to find the file in ItemFile or TaskFile
        file_obj = None
        file_type = None
        
        try:
            file_obj = ItemFile.objects.get(id=file_id)
            file_type = 'item_file'
        except ItemFile.DoesNotExist:
            try:
                file_obj = TaskFile.objects.get(id=file_id)
                file_type = 'task_file'
            except TaskFile.DoesNotExist:
                return JsonResponse({
                    'success': False,
                    'error': 'File not found'
                }, status=404)
        
        # Check if file is synced to Weaviate
        if not file_obj.weaviate_synced:
            return JsonResponse({
                'success': False,
                'error': 'File content not available in Weaviate'
            }, status=404)
        
        # Fetch file content from Weaviate
        settings = Settings.objects.first()
        if not settings:
            return JsonResponse({
                'success': False,
                'error': 'Settings not configured'
            }, status=500)
        
        weaviate_service = WeaviateItemSyncService(settings)
        collection = weaviate_service._client.collections.get(weaviate_service.COLLECTION_NAME)
        
        # Query Weaviate for this file's content
        # Files can be stored in chunks, so we need to get all chunks
        file_content_parts = []
        
        try:
            # Try to get the single file object
            result = collection.query.fetch_object_by_id(str(file_id))
            if result and result.properties:
                file_content_parts.append(result.properties.get('description', ''))
        except Exception:
            # If single object not found, try to get chunks (file_id_0, file_id_1, etc.)
            for i in range(10):  # Max 10 chunks
                chunk_id = f"{file_id}_{i}" if i > 0 else str(file_id)
                try:
                    result = collection.query.fetch_object_by_id(chunk_id)
                    if result and result.properties:
                        file_content_parts.append(result.properties.get('description', ''))
                    else:
                        break  # No more chunks
                except Exception:
                    break  # No more chunks
        
        weaviate_service.close()
        
        if not file_content_parts:
            return JsonResponse({
                'success': False,
                'error': 'File content not found in Weaviate'
            }, status=404)
        
        # Combine all content parts
        full_content = '\n\n'.join(file_content_parts)
        
        # Use KIGate agent to generate summary
        try:
            kigate_service = KiGateService(settings)
            
            # Prepare message for the agent
            message = f"""Please provide a concise summary of the following file content.

Filename: {file_obj.filename}

Content:
{full_content[:10000]}"""  # Limit to first 10000 chars to avoid token limits
            
            # Execute the weaviate-data-summary-agent
            agent_result = kigate_service.execute_agent(
                agent_name='weaviate-data-summary-agent',
                provider='openai',
                model='gpt-4',
                message=message,
                user_id=str(user.id)
            )
            
            if agent_result.get('success') and agent_result.get('result'):
                summary = agent_result.get('result')
            else:
                # Fallback: use a simple excerpt if agent fails
                summary = f"# {file_obj.filename}\n\n{full_content[:500]}...\n\n*Full AI summary not available*"
                logger.warning(f"KIGate agent failed, using fallback summary for file {file_id}")
        
        except KiGateServiceError as e:
            # Fallback: provide excerpt if KIGate is not available
            logger.warning(f"KIGate service error: {e.message}, using fallback summary")
            summary = f"# {file_obj.filename}\n\n{full_content[:500]}...\n\n*AI summary service not available*"
        
        return JsonResponse({
            'success': True,
            'summary': summary,
            'filename': file_obj.filename,
            'file_url': file_obj.sharepoint_url
        })
    
    except Exception as e:
        logger.error(f'Error generating file summary: {str(e)}')
        import traceback
        logger.error(traceback.format_exc())
        return JsonResponse({
            'success': False,
            'error': 'Failed to generate summary'
        }, status=500)


# ===== Item Question Answering API Endpoints =====

def require_auth(view_func):
    """Decorator to require authentication for API endpoints (supports both JWT and session)"""
    def wrapper(request, *args, **kwargs):
        user = get_user_from_request(request)  # Supports both JWT token and session
        if not user:
            return JsonResponse({'error': 'Authentication required'}, status=401)
        request.user_obj = user
        return view_func(request, *args, **kwargs)
    return wrapper


@require_http_methods(["POST"])
@require_auth
def api_item_ask_question(request, item_id):
    """
    API endpoint to ask a question about an item
    
    Performs semantic search across KnowledgeObjects related to the item
    and generates an AI answer using KIGate.
    
    POST /api/items/<item_id>/ask
    Body: {
        "question": "User's question text"
    }
    
    Returns: {
        "success": true,
        "qa_id": "uuid",
        "question": "question text",
        "answer": "AI-generated answer in markdown",
        "sources": [list of source objects],
        "relevance_score": float
    }
    """
    try:
        from main.models import Item, ItemQuestionAnswer
        from core.services.item_question_answering_service import (
            ItemQuestionAnsweringService,
            ItemQuestionAnsweringServiceError
        )
        
        # Get the item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Item not found'
            }, status=404)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Invalid JSON'
            }, status=400)
        
        question = data.get('question', '').strip()
        conversation_history = data.get('conversation_history', [])
        
        if not question:
            return JsonResponse({
                'success': False,
                'error': 'Question is required'
            }, status=400)
        
        logger.info(f"Processing question for item {item_id}: {question[:100]}")
        
        # Initialize service
        service = ItemQuestionAnsweringService()
        
        # Step 1: Search for related knowledge
        search_results = service.search_related_knowledge(
            item_id=str(item_id),
            question=question,
            limit=10
        )
        
        if not search_results.get('success'):
            return JsonResponse({
                'success': False,
                'error': 'Failed to search related knowledge'
            }, status=500)
        
        results = search_results.get('results', [])
        
        # Step 2: Generate answer using KIGate
        answer_result = service.generate_answer_with_kigate(
            question=question,
            search_results=results,
            item_title=item.title,
            user_id=str(request.user_obj.id),
            conversation_history=conversation_history
        )
        
        if not answer_result.get('success'):
            return JsonResponse({
                'success': False,
                'error': 'Failed to generate answer'
            }, status=500)
        
        answer = answer_result.get('answer', '')
        sources = answer_result.get('sources_used', [])
        
        # Calculate average relevance score
        avg_relevance = sum(s.get('relevance', 0) for s in sources) / len(sources) if sources else 0
        
        # Step 3: Save Q&A to database
        qa = ItemQuestionAnswer.objects.create(
            item=item,
            question=question,
            answer=answer,
            sources=sources,
            asked_by=request.user_obj,
            relevance_score=round(avg_relevance, 2)
        )
        
        logger.info(f"Successfully created Q&A {qa.id} for item {item_id}")
        
        # Close service connection
        service.close()
        
        return JsonResponse({
            'success': True,
            'qa_id': str(qa.id),
            'question': qa.question,
            'answer': qa.answer,
            'sources': qa.sources,
            'relevance_score': qa.relevance_score,
            'created_at': qa.created_at.isoformat()
        })
    
    except ItemQuestionAnsweringServiceError as e:
        logger.error(f"Q&A service error: {e.message}")
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=500)
    
    except Exception as e:
        logger.error(f"Error processing question: {str(e)}")
        logger.error(traceback.format_exc())
        return JsonResponse({
            'success': False,
            'error': 'Failed to process question'
        }, status=500)


@require_http_methods(["GET", "DELETE"])
@require_auth
def api_item_questions_history(request, item_id):
    """
    API endpoint to get or delete Q&A history for an item
    
    GET /api/items/<item_id>/questions/history
    Query params: page (optional, default=1)
    
    Returns: {
        "success": true,
        "questions": [
            {
                "id": "uuid",
                "question": "text",
                "answer": "text",
                "sources": [...],
                "relevance_score": float,
                "asked_by": "username",
                "created_at": "iso8601",
                "saved_as_knowledge_object": bool
            }
        ],
        "total": int,
        "page": int,
        "per_page": int,
        "has_next": bool
    }
    
    DELETE /api/items/<item_id>/questions/history
    
    Returns: {
        "success": true,
        "deleted_count": int,
        "message": "Chat history deleted successfully"
    }
    """
    try:
        from main.models import Item, ItemQuestionAnswer
        
        # Get the item
        try:
            item = Item.objects.get(id=item_id)
        except Item.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Item not found'
            }, status=404)
        
        # Handle DELETE request
        if request.method == 'DELETE':
            # Delete all Q&A history for this item
            deleted_count, _ = ItemQuestionAnswer.objects.filter(item=item).delete()
            
            logger.info(f"Deleted {deleted_count} Q&A records for item {item_id}")
            
            return JsonResponse({
                'success': True,
                'deleted_count': deleted_count,
                'message': 'Chat history deleted successfully'
            })
        
        # Handle GET request
        # Get pagination parameters
        page = int(request.GET.get('page', 1))
        per_page = int(request.GET.get('per_page', 10))
        
        # Get Q&A history
        qa_queryset = ItemQuestionAnswer.objects.filter(item=item).select_related('asked_by')
        
        # Paginate
        paginator = Paginator(qa_queryset, per_page)
        page_obj = paginator.get_page(page)
        
        # Format results
        questions = []
        for qa in page_obj:
            questions.append({
                'id': str(qa.id),
                'question': qa.question,
                'answer': qa.answer,
                'sources': qa.sources,
                'relevance_score': qa.relevance_score,
                'asked_by': qa.asked_by.username if qa.asked_by else 'Unknown',
                'created_at': qa.created_at.isoformat(),
                'saved_as_knowledge_object': qa.saved_as_knowledge_object
            })
        
        return JsonResponse({
            'success': True,
            'questions': questions,
            'total': paginator.count,
            'page': page,
            'per_page': per_page,
            'has_next': page_obj.has_next()
        })
    
    except Exception as e:
        logger.error(f"Error getting Q&A history: {str(e)}")
        logger.error(traceback.format_exc())
        return JsonResponse({
            'success': False,
            'error': 'Failed to get Q&A history'
        }, status=500)


@require_http_methods(["POST"])
@require_auth
def api_item_save_qa_as_knowledge(request, qa_id):
    """
    API endpoint to save a Q&A pair as a KnowledgeObject in Weaviate
    
    POST /api/items/questions/<qa_id>/save
    
    Returns: {
        "success": true,
        "weaviate_uuid": "uuid",
        "message": "Q&A saved as KnowledgeObject"
    }
    """
    try:
        from main.models import ItemQuestionAnswer
        from core.services.item_question_answering_service import (
            ItemQuestionAnsweringService,
            ItemQuestionAnsweringServiceError
        )
        
        # Get the Q&A
        try:
            qa = ItemQuestionAnswer.objects.get(id=qa_id)
        except ItemQuestionAnswer.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Q&A not found'
            }, status=404)
        
        # Check if already saved
        if qa.saved_as_knowledge_object:
            return JsonResponse({
                'success': True,
                'weaviate_uuid': qa.weaviate_uuid,
                'message': 'Q&A already saved as KnowledgeObject'
            })
        
        # Initialize service
        service = ItemQuestionAnsweringService()
        
        # Save to Weaviate
        result = service.save_as_knowledge_object(
            item_id=str(qa.item.id),
            question=qa.question,
            answer=qa.answer,
            qa_id=str(qa.id)
        )
        
        if result.get('success'):
            # Update Q&A record
            qa.saved_as_knowledge_object = True
            qa.weaviate_uuid = result.get('weaviate_uuid')
            qa.save()
            
            logger.info(f"Saved Q&A {qa_id} as KnowledgeObject: {qa.weaviate_uuid}")
        
        # Close service connection
        service.close()
        
        return JsonResponse({
            'success': True,
            'weaviate_uuid': qa.weaviate_uuid,
            'message': 'Q&A saved as KnowledgeObject'
        })
    
    except ItemQuestionAnsweringServiceError as e:
        logger.error(f"Q&A save error: {e.message}")
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=500)
    
    except Exception as e:
        logger.error(f"Error saving Q&A as KnowledgeObject: {str(e)}")
        logger.error(traceback.format_exc())
        return JsonResponse({
            'success': False,
            'error': 'Failed to save Q&A as KnowledgeObject'
        }, status=500)


# =============================================================================
# Weaviate Maintenance API Endpoints
# =============================================================================

@csrf_exempt
@require_http_methods(["GET"])
def api_weaviate_status(request):
    """
    Get Weaviate system status and metadata
    
    Admin only endpoint
    
    GET /api/weaviate/status
    
    Returns: {
        "success": true,
        "meta": {...},
        "version": "1.x.x",
        "hostname": "...",
        "stats": {...}
    }
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Unauthorized'
        }, status=401)
    
    # Check admin permission
    if user.role != 'admin':
        return JsonResponse({
            'success': False,
            'error': 'Admin permission required'
        }, status=403)
    
    try:
        from core.services.weaviate_maintenance_service import (
            WeaviateMaintenanceService,
            WeaviateMaintenanceServiceError
        )
        
        service = WeaviateMaintenanceService()
        
        # Get system metadata
        meta_result = service.get_meta()
        
        # Get collection statistics
        stats_result = service.get_collection_stats()
        
        # Close service connection
        service.close()
        
        return JsonResponse({
            'success': True,
            'meta': meta_result.get('meta', {}),
            'version': meta_result.get('version', 'Unknown'),
            'hostname': meta_result.get('hostname', 'Unknown'),
            'stats': stats_result.get('stats', {})
        })
    
    except WeaviateMaintenanceServiceError as e:
        logger.error(f"Weaviate status error: {e.message}")
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=500)
    
    except Exception as e:
        logger.error(f"Error getting Weaviate status: {str(e)}")
        logger.error(traceback.format_exc())
        return JsonResponse({
            'success': False,
            'error': 'Failed to get Weaviate status'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_weaviate_rebuild(request):
    """
    Trigger Weaviate index rebuild
    
    Admin only endpoint
    
    POST /api/weaviate/rebuild
    
    Returns: {
        "success": true,
        "message": "..."
    }
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Unauthorized'
        }, status=401)
    
    # Check admin permission
    if user.role != 'admin':
        return JsonResponse({
            'success': False,
            'error': 'Admin permission required'
        }, status=403)
    
    try:
        from core.services.weaviate_maintenance_service import (
            WeaviateMaintenanceService,
            WeaviateMaintenanceServiceError
        )
        
        service = WeaviateMaintenanceService()
        
        # Rebuild indices
        result = service.rebuild_index()
        
        # Close service connection
        service.close()
        
        logger.info(f"Index rebuild triggered by user {user.username}")
        
        return JsonResponse({
            'success': result.get('success', False),
            'message': result.get('message', ''),
            'info': result.get('info', '')
        })
    
    except WeaviateMaintenanceServiceError as e:
        logger.error(f"Index rebuild error: {e.message}")
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=500)
    
    except Exception as e:
        logger.error(f"Error rebuilding index: {str(e)}")
        logger.error(traceback.format_exc())
        return JsonResponse({
            'success': False,
            'error': 'Failed to rebuild index'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_weaviate_schema_export(request):
    """
    Export Weaviate schema as JSON
    
    Admin only endpoint
    
    POST /api/weaviate/schema/export
    
    Returns: {
        "success": true,
        "schema": {...},
        "export_time": "2024-01-01T00:00:00"
    }
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Unauthorized'
        }, status=401)
    
    # Check admin permission
    if user.role != 'admin':
        return JsonResponse({
            'success': False,
            'error': 'Admin permission required'
        }, status=403)
    
    try:
        from core.services.weaviate_maintenance_service import (
            WeaviateMaintenanceService,
            WeaviateMaintenanceServiceError
        )
        
        service = WeaviateMaintenanceService()
        
        # Export schema
        result = service.export_schema()
        
        # Close service connection
        service.close()
        
        logger.info(f"Schema exported by user {user.username}")
        
        return JsonResponse({
            'success': True,
            'schema': result.get('schema', {}),
            'export_time': result.get('export_time', '')
        })
    
    except WeaviateMaintenanceServiceError as e:
        logger.error(f"Schema export error: {e.message}")
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=500)
    
    except Exception as e:
        logger.error(f"Error exporting schema: {str(e)}")
        logger.error(traceback.format_exc())
        return JsonResponse({
            'success': False,
            'error': 'Failed to export schema'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_weaviate_schema_restore(request):
    """
    Restore Weaviate schema from backup
    
    Admin only endpoint - DESTRUCTIVE OPERATION
    
    POST /api/weaviate/schema/restore
    Body: {
        "schema": {...},
        "confirm": true
    }
    
    Returns: {
        "success": true/false,
        "message": "..."
    }
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Unauthorized'
        }, status=401)
    
    # Check admin permission
    if user.role != 'admin':
        return JsonResponse({
            'success': False,
            'error': 'Admin permission required'
        }, status=403)
    
    try:
        from core.services.weaviate_maintenance_service import (
            WeaviateMaintenanceService,
            WeaviateMaintenanceServiceError
        )
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Invalid JSON in request body'
            }, status=400)
        
        schema_data = data.get('schema')
        confirm = data.get('confirm', False)
        
        if not schema_data:
            return JsonResponse({
                'success': False,
                'error': 'Schema data required'
            }, status=400)
        
        service = WeaviateMaintenanceService()
        
        # Restore schema
        result = service.restore_schema(schema_data, confirm=confirm)
        
        # Close service connection
        service.close()
        
        if result.get('success'):
            logger.warning(f"Schema restore attempted by user {user.username}")
        
        return JsonResponse(result)
    
    except WeaviateMaintenanceServiceError as e:
        logger.error(f"Schema restore error: {e.message}")
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=500)
    
    except Exception as e:
        logger.error(f"Error restoring schema: {str(e)}")
        logger.error(traceback.format_exc())
        return JsonResponse({
            'success': False,
            'error': 'Failed to restore schema'
        }, status=500)


@csrf_exempt
@require_http_methods(["GET"])
def api_weaviate_search_object(request, object_uuid):
    """
    Search for a specific object by UUID in Weaviate
    
    Admin only endpoint
    
    GET /api/weaviate/object/<uuid>
    
    Returns: {
        "success": true,
        "found": true/false,
        "object": {...}
    }
    """
    # Check authentication
    user = get_user_from_request(request)
    if not user:
        return JsonResponse({
            'success': False,
            'error': 'Unauthorized'
        }, status=401)
    
    # Check admin permission
    if user.role != 'admin':
        return JsonResponse({
            'success': False,
            'error': 'Admin permission required'
        }, status=403)
    
    try:
        from core.services.weaviate_maintenance_service import (
            WeaviateMaintenanceService,
            WeaviateMaintenanceServiceError
        )
        
        service = WeaviateMaintenanceService()
        
        # Search for object
        result = service.search_object(str(object_uuid))
        
        # Close service connection
        service.close()
        
        return JsonResponse({
            'success': True,
            'found': result.get('found', False),
            'object': result.get('object')
        })
    
    except WeaviateMaintenanceServiceError as e:
        logger.error(f"Object search error: {e.message}")
        return JsonResponse({
            'success': False,
            'error': e.message,
            'details': e.details
        }, status=500)
    
    except Exception as e:
        logger.error(f"Error searching for object: {str(e)}")
        logger.error(traceback.format_exc())
        return JsonResponse({
            'success': False,
            'error': 'Failed to search for object'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_close(request, task_id):
    """
    Close a task with optional email notification to requester
    
    Expects JSON body:
    {
        "close_type": "success" | "next_update" | "no_email"
    }
    
    - "success": Task is completed successfully, send email to requester with AI-generated message
    - "next_update": Task will be in next update, send email to requester with AI-generated message
    - "no_email": Just close the task without sending email
    
    Returns:
    {
        "success": true,
        "message": "Task closed successfully",
        "email_sent": true/false
    }
    """
    from .models import Task, Settings, User
    from main.mail_utils import send_task_email
    
    try:
        # Get current user from session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({'error': 'Authentication required'}, status=401)
        
        try:
            user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Parse request body
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)
        
        # Validate required fields
        close_type = data.get('close_type')
        if not close_type or close_type not in ['success', 'next_update', 'no_email']:
            return JsonResponse({'error': 'close_type is required and must be one of: success, next_update, no_email'}, status=400)
        
        # Verify task exists
        try:
            task = Task.objects.get(id=task_id)
        except Task.DoesNotExist:
            return JsonResponse({'error': 'Task not found'}, status=404)
        
        # Mark task as done
        previous_status = task.status
        if previous_status != 'done':
            task.mark_as_done()
            
            # Sync with Weaviate
            try:
                settings = Settings.objects.first()
                if settings:
                    sync_service = WeaviateTaskSyncService(settings)
                    sync_service.sync_update(task)
            except Exception as e:
                logger.warning(f'Weaviate sync failed for task {task.id}: {str(e)}')
        
        email_sent = False
        
        # Send email if requested
        if close_type in ['success', 'next_update'] and task.requester and task.requester.email:
            try:
                settings = Settings.objects.first()
                if not settings:
                    logger.error("No settings found in database")
                    return JsonResponse({
                        'success': False,
                        'error': 'No settings configured'
                    }, status=500)
                
                # Determine which AI agent to use
                agent_name = 'close_task_success_agent' if close_type == 'success' else 'close_task_update_agent'
                
                # Generate email body using KiGate
                try:
                    kigate_service = KiGateService(settings)
                    
                    # Prepare message for the agent with task description
                    agent_message = f"Task: {task.title}\n\nDescription:\n{task.description}"
                    
                    # Execute the agent
                    # Use OpenAI settings as KiGate doesn't have separate provider/model config
                    provider = 'openai'
                    model = settings.openai_default_model if settings.openai_default_model else 'gpt-4'
                    
                    result = kigate_service.execute_agent(
                        agent_name=agent_name,
                        provider=provider,
                        model=model,
                        message=agent_message,
                        user_id=str(user.id)
                    )
                    
                    if result.get('success') and result.get('result'):
                        email_body = result.get('result')
                    else:
                        # Fallback to a default message
                        if close_type == 'success':
                            email_body = f"<p>Hallo,</p><p>der Task <strong>{task.title}</strong> wurde erfolgreich abgeschlossen.</p><p>Beschreibung:<br>{task.description}</p><p>Mit freundlichen Grüßen</p>"
                        else:
                            email_body = f"<p>Hallo,</p><p>der Task <strong>{task.title}</strong> wird im nächsten Update enthalten sein.</p><p>Beschreibung:<br>{task.description}</p><p>Mit freundlichen Grüßen</p>"
                        
                except KiGateServiceError as e:
                    logger.warning(f'KiGate service error: {e.message}, using fallback message')
                    # Fallback to a default message
                    if close_type == 'success':
                        email_body = f"<p>Hallo,</p><p>der Task <strong>{task.title}</strong> wurde erfolgreich abgeschlossen.</p><p>Beschreibung:<br>{task.description}</p><p>Mit freundlichen Grüßen</p>"
                    else:
                        email_body = f"<p>Hallo,</p><p>der Task <strong>{task.title}</strong> wird im nächsten Update enthalten sein.</p><p>Beschreibung:<br>{task.description}</p><p>Mit freundlichen Grüßen</p>"
                
                # Prepare subject
                if close_type == 'success':
                    subject = f"Task abgeschlossen"
                else:
                    subject = f"Task wird im nächsten Update enthalten sein"
                
                # Send email
                success, result = send_task_email(
                    task_id=task.id,
                    recipient_email=task.requester.email,
                    subject=subject,
                    body=email_body,
                    user=user
                )
                
                if success:
                    email_sent = True
                    logger.info(f'Task close email sent to {task.requester.email} for task {task.id}')
                else:
                    logger.error(f'Failed to send task close email: {result}')
                    
            except Exception as e:
                logger.error(f'Error sending task close email: {str(e)}')
                # Don't fail the whole operation if email fails
        
        logger.info(f'Task {task_id} closed by user {user.username} with type {close_type}')
        
        return JsonResponse({
            'success': True,
            'message': 'Task erfolgreich geschlossen',
            'email_sent': email_sent
        })
    
    except Exception as e:
        logger.error(f'Task close error: {str(e)}')
        logger.error(traceback.format_exc())
        return JsonResponse({
            'error': 'An error occurred while closing the task'
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def api_task_quick_create(request):
    """Quick task creation API endpoint for the navigation quick entry modal"""
    from .models import Item, Task
    
    logger = logging.getLogger(__name__)
    
    try:
        # Check authentication using the standard pattern (supports both JWT and session)
        user = get_user_from_request(request)
        if not user:
            return JsonResponse({
                'error': 'Authentication required'
            }, status=401)
        
        # Get form data
        item_id = request.POST.get('item_id', '').strip()
        title = request.POST.get('title', '').strip()
        description = request.POST.get('description', '').strip()
        requester_id = request.POST.get('requester_id', '').strip()
        
        # Validate required fields
        if not item_id or not title:
            return JsonResponse({
                'success': False,
                'error': 'Element und Titel sind Pflichtfelder'
            }, status=400)
        
        # Get item with proper error handling
        try:
            item = Item.objects.get(id=item_id)
        except (Item.DoesNotExist, ValueError):
            return JsonResponse({
                'success': False,
                'error': 'Element nicht gefunden'
            }, status=404)
        
        # Get requester if provided
        requester = None
        if requester_id:
            try:
                requester = User.objects.get(id=requester_id)
            except (User.DoesNotExist, ValueError):
                # Ignore invalid requester ID, just don't set it
                pass
        
        # Create task with logged-in user as assigned_to
        task = Task(
            title=title,
            description=description,
            status='new',
            item=item,
            created_by=user,
            assigned_to=user,  # Automatically assign to logged-in user
            requester=requester
        )
        task.save()
        
        logger.info(f'Quick task created: {task.id} by user {user.username}')
        
        # Sync to Weaviate
        sync_service = None
        try:
            from core.services.weaviate_task_sync_service import WeaviateTaskSyncService
            sync_service = WeaviateTaskSyncService()
            sync_service.sync_create(task)
        except Exception as sync_error:
            # Log error but don't fail the task creation
            logger.warning(f'Weaviate sync failed for quick task {task.id}: {str(sync_error)}')
        finally:
            if sync_service:
                sync_service.close()
        
        return JsonResponse({
            'success': True,
            'message': 'Aufgabe erfolgreich erstellt',
            'task_id': str(task.id),
            'task_title': task.title
        })
    
    except Exception as e:
        logger.error(f'Quick task creation error: {str(e)}')
        logger.error(traceback.format_exc())
        return JsonResponse({
            'success': False,
            'error': 'Fehler beim Erstellen der Aufgabe'
        }, status=500)

